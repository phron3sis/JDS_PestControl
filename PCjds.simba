{$UNDEF SCRIPT_ID}{$DEFINE SCRIPT_ID := 'pest_control_jds'}
{$UNDEF SCRIPT_REVISION}{$DEFINE SCRIPT_REVISION := '6'}
{$DEFINE SCRIPT_GUI}

program WaspPestControl;

{$I SRL-T/osr.simba}
{$I WaspLib/osr.simba}

const
  BoatToUtilize =   3;   //1 Novice, 2 Intermediate, 3 Veteran
  PointsPerGame =   7;   // veterans boat, med diary = 7
  _PCWorld      = 344;   // Pest Control World is 344

  // Boat interiors
  VETERAN_BOAT_BOX     : TBox = [6105, 4695, 6120, 4718];
  INTER_BOAT_BOX       : TBox = [6129, 4723, 6144, 4746];
  NOVICE_BOAT_BOX      : TBox = [6218, 4740, 6233, 4763];

  // Plank tiles
  VETERAN_PLANK_TILE   : TPoint = [6130, 4700];
  INTER_PLANK_TILE     : TPoint = [6154, 4736];
  NOVICE_PLANK_TILE    : TPoint = [6206, 4756];

  // Island areas
  DEFEND_KNIGHT_BOX    : TBox = [5741, 5605, 5775, 5639];
  GAME_START_LANDING_BOX: TBox = [5752, 5532, 5773, 5562];

{********************************************}
{                 ENUM STATES                }
{********************************************}

type
  EPestState = (
    PCS_IN_BOAT,
    PCS_WALK_CENTER,
    PCS_DEFEND,
    PCS_AT_PLANK,
    PCS_UNKNOWN,
    PCS_END_SCRIPT
  );


{********************************************}
{                 SCRIPT RECORD              }
{********************************************}

type
  TJdsPestControl = record(TBaseWalkerScript)
    State            : EPestState;

    CenterTile       : TPoint;
    PlankTile        : TPoint;
    CrossPlankTile   : TPoint;

    LastXP           : Int64;
    LastXPTime       : UInt64;
    NextAttackDelay  : Int32;

    StartTime        : UInt64;

    // === WIN TRACKING ===
    GamesWon      : UInt32;
    LastWinTime   : UInt64;
    WinCooldown   : UInt64;

    CachedPos      : TPoint;
    CachedPosTime  : UInt64;
    PosCacheDelay  : UInt32;   // milliseconds to trust cached pos

    PointsTotal    : UInt32;
    PointsTime     : UInt64;
  end;

  {********************************************}
  {                 HUD RECORD                 }
  {********************************************}

  TPestHUD = record
    LastUpdate: UInt64;
    Text      : TStringArray;
  end;

var
  PestControl: TJdsPestControl;
  PestHUD    : TPestHUD;

procedure ApplyBioMouse();
var
  bh: Double;
begin
  bh := Login.GetPlayerBioHash();  // 0.00..1.00

  // === Mouse speed ===
  // 10–14 (safe human range)
  Mouse.Speed := Round(10 + ((bh - 0.5) * 4));
  Mouse.Speed := EnsureRange(Mouse.Speed, 9, 15);

  // === Gravity ===
  Mouse.Gravity := 8 + (bh * 3);

  // === Wind ===
  // 4–6 (smooth)
  Mouse.Wind := 4 + (bh * 2);

  // === Miss chance ===
  // 10–18% (human-like)
  Mouse.MissChance := 10 + (bh * 8);

  // === Distribution ===
  // GAUSS → ROWP → SKEWED
  if bh < 0.33 then
    Mouse.Distribution := MOUSE_DISTRIBUTION_GAUSS
  else if bh < 0.66 then
    Mouse.Distribution := MOUSE_DISTRIBUTION_ROWP
  else
    Mouse.Distribution := MOUSE_DISTRIBUTION_SKEWED;

  // === Idle interval ===
  Mouse.IdleInterval := 3.9 + (bh * 1.3);
end;


// --- BioHash-Aware Wait Override ---
procedure Wait(Min, Max: Double; Weight: EWaitDir = wdMean);override;
var
  adjMin, adjMax, bias: Double;
begin
  // BioHash → range [-0.05..+0.05]
  bias := (Login.GetPlayerBioHash() - 0.5) * 0.10;

  adjMin := Min + (Min * bias);
  adjMax := Max + (Max * bias);

  case Weight of
    wdLeft:
      System.Wait(Round(SRL.TruncatedGauss(adjMin, adjMax)));

    wdMean:
      System.Wait(Round(SRL.NormalRange(adjMin, adjMax)));

    wdRight:
      System.Wait(Round(SRL.TruncatedGauss(adjMax, adjMin)));
  end;
end;


function HumanGauss(minVal, maxVal, mean, stdev: Double; bioWeight: Double = 0): Int32;
var
  r: Double;
begin
  // Generate base Gaussian
  r := SRL.GaussRand(mean, stdev);

  // Add user-specific noise (zero-mean, does not increase range)
  if bioWeight <> 0 then
    r += (BioHash - 0.5) * bioWeight;

  // Clamp inside range
  if r < minVal then r := minVal;
  if r > maxVal then r := maxVal;

  // Convert to ms
  Result := Round(r * 1000);
end;

function TimeUntilNextBreak(): String;
var
  i: Int32;
  soonest: PBreakTask;
  remaining: Int64;
begin
  // No breaks scheduled
  if Length(Antiban.Breaks) = 0 then
    Exit('N/A');

  // Initialize soonest pointer
  soonest := @Antiban.Breaks[0];

  // Find the break with the smallest NextAtTime
  for i := 1 to High(Antiban.Breaks) do
    if Antiban.Breaks[i].NextAtTime < soonest^.NextAtTime then
      soonest := @Antiban.Breaks[i];

  // Time until it fires (in ms)
  remaining := Round(soonest^.NextAtTime - GetTimeRunning());
  if remaining < 0 then
    remaining := 0;

  // Format like "02m 58s"
  Result := SRL.MsToTime(remaining, Time_Short).Trim();
end;

{********************************************}
{                ANTIBAN SETUP               }
{********************************************}

procedure TAntiban.Setup(); override;
begin
  Self.Skills := [
    ERSSkill.ATTACK,
    ERSSkill.STRENGTH,
    ERSSkill.DEFENCE,
    ERSSkill.HITPOINTS,
    ERSSkill.TOTAL
  ];

  Self.MinZoom := 15;
  Self.MaxZoom := 40;

  inherited;
end;


{********************************************}
{                 LOGGING                    }
{********************************************}

procedure TJdsPestControl.Msg(const s: String);
var
  t: UInt64;
  h, m, sec, ms: UInt64;
begin
  t := GetSystemTime() - Self.StartTime;

  // Convert ms → hh:mm:ss:ms
  h   := t div 3600000;
  m   := (t div 60000) mod 60;
  sec := (t div 1000) mod 60;
  ms  := t mod 1000;

  WriteLn(Format('[%.2d:%.2d:%.2d:%.3d]:[PCjds]: %s', [h, m, sec, ms, s]));
end;


procedure TPestHUD.UpdateAndDraw();
const
  BG_COLOR      = $151515;
  BORDER_COLOR  = $CC2A2A;
  HEADER_COLOR  = $D6B43A;
  TEXT_COLOR    = $E0E0E0;
var
  elapsed: UInt64;
  winsPerHour: Double;
  i, lineHeight: Int32;
  abox: TBox;
  x, y: Int32;
begin
  // Run only every 5 seconds
  if (GetSystemTime - LastUpdate) < 5000 then
    Exit;
  LastUpdate := GetSystemTime;

  // ==== COMPUTE HUD TEXT ====
  Text := [];

  elapsed := PestControl.TimeRunning.ElapsedTime();
  winsPerHour := NumberPerHour(PestControl.GamesWon, elapsed);

  Text += 'Pest Control - by Footballjds | '+ToStr(PestControl.PointsTotal);
  Text += 'Runtime: ' + SRL.MsToTime(elapsed, Time_Short).Trim();
  Text += 'State: ' + ToStr(PestControl.State);
  Text += 'Wins: ' + IntToStr(PestControl.GamesWon);
  Text += 'Wins/hr: ' + SRL.FormatNumber(winsPerHour, 2);
  Text += 'Points/hr: ' + SRL.FormatNumber(winsPerHour * PointsPerGame, 2);
  Text += 'Total EXP: ' + SRL.FormatNumber(XPBar.TotalEarnedXP(), 2);
  Text += 'XP/hr: ' + SRL.FormatNumber(
                     NumberPerHour(XPBar.TotalEarnedXP(), elapsed), 2
                   );
  Text += 'Next Break: ' + TimeUntilNextBreak();

  // ==== DRAW HUD ====
  lineHeight := 14;

  abox := Box(7, 345, 195, 473);

  RSClient.Image().DrawBoxFilled(abox.Expand(1), False, BORDER_COLOR);
  RSClient.Image().DrawBoxFilled(abox, False, BG_COLOR);

  RSClient.Image().SetFontName('Arial');
  RSClient.Image().SetFontSize(11);

  x := abox.X1 + 3;
  y := abox.Y1 + 3;

  for i := 0 to High(Text) do
  begin
    if i = 0 then
      RSClient.Image().DrawText(Text[i], Point(x, y), HEADER_COLOR)
    else
      RSClient.Image().DrawText(Text[i], Point(x, y), TEXT_COLOR);
    y += lineHeight;
  end;
end;



{********************************************}
{           XP STATE / ATTACK LOGIC          }
{********************************************}

procedure TJdsPestControl.UpdateXPState();
var
  xp: Int64;
begin
  xp := XPBar.Read();
  if xp <> Self.LastXP then
  begin
    Self.LastXP     := xp;
    Self.LastXPTime := GetSystemTime();
    Self.NextAttackDelay := Random(2299, 3600);
  end;
end;

function TJdsPestControl.XPStale(): Boolean;
begin
  Result := (GetSystemTime - Self.LastXPTime) > Self.NextAttackDelay;
end;

function TJdsPestControl.GetPos(): TPoint;
begin
  // If cache younger than PosCacheDelay, return cached location
  if (GetSystemTime - Self.CachedPosTime) < Self.PosCacheDelay then
    Exit(Self.CachedPos);

  // Otherwise refresh once
  Self.CachedPos := Self.RSW.GetMyPos();
  Self.CachedPosTime := GetSystemTime();

  Result := Self.CachedPos;
end;

{********************************************}
{               STATE DETECTION              }
{********************************************}

function TJdsPestControl.InBoat(): Boolean;
var
  _ourPos: TPoint;
begin
  _ourPos := self.rsw.GetMyPos();

  result := _ourPos.InBox(VETERAN_BOAT_BOX) or
    _ourPos.InBox(INTER_BOAT_BOX) or
      _ourPos.InBox(NOVICE_BOAT_BOX);
end;

function TJdsPestControl.GetState(): EPestState;
var
  pos: TPoint;
begin
  // Read cached/corrected location once
  pos := Self.GetPos();

  // ================================
  // OUTPOST (boats + planks)
  // ================================
  if pos.InBox(RSRegions.PEST_CONTROL_OUTPOST) then
  begin
    // Inside any of the 3 boats → waiting for game
    if pos.InBox(VETERAN_BOAT_BOX)
    or pos.InBox(INTER_BOAT_BOX)
    or pos.InBox(NOVICE_BOAT_BOX) then
      Exit(PCS_IN_BOAT);

    // At any plank → waiting to board or just returned from game
    if (Distance(pos, VETERAN_PLANK_TILE) <= 5)
    or (Distance(pos, INTER_PLANK_TILE)   <= 5)
    or (Distance(pos, NOVICE_PLANK_TILE)  <= 5) then
      Exit(PCS_AT_PLANK);

    // On outpost but not in boat or at plank
    Exit(PCS_AT_PLANK);  // treat as plank wait (safe default)
  end;


  // ================================
  // GAME ISLAND (actual minigame)
  // ================================
  if pos.InBox(RSRegions.PEST_CONTROL_ISLAND) then
  begin
    // Just spawned in landing boat → walk to center
    if pos.InBox(GAME_START_LANDING_BOX) then
      Exit(PCS_WALK_CENTER);

    // In knight defending box → defend
    if pos.InBox(DEFEND_KNIGHT_BOX) then
      Exit(PCS_DEFEND);

    // On island but not in defend box → walk to center
    Exit(PCS_WALK_CENTER);
  end;


  // ================================
  // Outside all known regions
  // ================================
  Result := PCS_UNKNOWN;
end;


{********************************************}
{                  ACTIONS                   }
{********************************************}

procedure TJdsPestControl.UpdatePoints();
var
  BluePoints: Int32;
  LastCheck : Int32 = 60000;
  PEST_POINTS_BOX: Tbox = [72, 64, 123, 81];
begin
  if GetSystemTime < (LastCheck+Self.PointsTime) then
    EXIT;
  BluePoints := ocr.RecognizeNumber(PEST_POINTS_BOX, TOCRColorFilter.Create([16777113]), RS_FONT_PLAIN_12);

  if BluePoints <= Self.PointsTotal then Exit;

  Self.PointsTotal := BluePoints;
  Self.PointsTime := GetSystemTime;
  Self.Msg('Total Points: '+toStr(Self.PointsTotal));
end;

procedure TJdsPestControl.DoInBoat();
begin
  self.UpdatePoints();
  Wait(700, 1300);
end;

procedure TJdsPestControl.DoWalkCenter();
var
  ChancePrayer: Boolean;
begin
  ChancePrayer := (Random(0, 5) = 0);

  if Self.RSW.AtTile(Self.CenterTile, 15) then
  begin
    Minimap.EnablePrayer();
    Exit;
  end;

  if ChancePrayer then
  begin
    Minimap.EnablePrayer();
    Wait(0, 1000, wdLeft);
  end;

  Self.RSW.WalkBlind(Self.CenterTile, 10);
  Minimap.EnablePrayer();
  Wait(0, 1000, wdLeft);
end;


{********************************************}
{        SMART CLICK POINT FOR MONSTERS      }
{********************************************}
function TJdsPestControl.GetMonsterClickPoint(): TPoint;
const
  BASE_RADIUS = 60; // radius at 50–100% zoom
  BORDER_COLOR = $DD7A26FF;
var
  tileMS     : TRectangle;
  centerMS   : TPoint;
  zoom       : Double;
  radius     : Int32;
  pts, inside: TPointArray;
  clusters   : T2DPointArray;
  pMean, pRand: TPoint;
  dx, dy, s  : Double;
  pt: TPoint;
begin
  Result := [-1, -1];

  //------------------------------------------------------
  // 1. Convert CenterTile → MainScreen projection
  //------------------------------------------------------
  tileMS := Self.RSW.GetTileMS(Self.CenterTile);
  if (tileMS.Top.X = 0) and (tileMS.Top.Y = 0) then
    Exit;

  centerMS := tileMS.Mean;

  //------------------------------------------------------
  // 2. Read real zoom level (0.0 → 1.0)
  //------------------------------------------------------
  zoom := MM2MS.ZoomLevel / 100.0;
  if zoom < 0 then zoom := 0;
  if zoom > 1 then zoom := 1;

  //------------------------------------------------------
  // 3. Convert zoom → search radius
  //------------------------------------------------------
  // zoom=1.0 → 100
  // zoom=0.5 → 150
  // zoom=0.0 → 200
  radius := Round(BASE_RADIUS + (BASE_RADIUS * (1 - zoom)));

  //------------------------------------------------------
  // 4. Find monster colors in MS
  //------------------------------------------------------
  pts := [];
  SRL.FindColors(pts, CTS2(15921928, 2, 0.08, 5.42), MainScreen.Bounds);
  if pts.Len = 0 then Exit;

  //------------------------------------------------------
  // 5. Keep only points inside the zoom-scaled circle
  //------------------------------------------------------
  inside := [];
  for pt in pts do
    if SRL.PointInCircle(pt, centerMS, radius) then
      inside += pt;

  if inside.Len = 0 then Exit;

  //------------------------------------------------------
  // 6. Cluster → pick closest cluster
  //------------------------------------------------------
  clusters := inside.Cluster(2);
  if clusters.Len = 0 then Exit;

  clusters.SortByMiddle(centerMS);

  pMean := clusters[0].Mean();
  pRand := clusters[0].RandomValue();

  //------------------------------------------------------
  // 7. Gaussian smoothly bias click from mean → point
  //------------------------------------------------------
  s := SRL.GaussRand(0.70, 0.10);
  if s < 0.55 then s := 0.55;
  if s > 0.90 then s := 0.90;

  dx := (pRand.X - pMean.X);
  dy := (pRand.Y - pMean.Y);

  Result.X := pMean.X + Round(dx * s);
  Result.Y := pMean.Y + Round(dy * s);

  //------------------------------------------------------
  // 8. Debug: draw outline of search region
  //------------------------------------------------------

  //RSClient.Image.DrawCircle(centerMS, radius, BORDER_COLOR);
end;




{********************************************}
{                 DEFEND LOOP                }
{********************************************}

procedure TJdsPestControl.DoDefend();
var
  M: TPoint;
begin
  // Antiban is handled once per main loop in Run()
  Self.UpdateXPState();

  if Self.XPStale() then
  begin
    M := Self.GetMonsterClickPoint();
    if MainScreen.IsVisible(M) then
    begin
      Mouse.Move(M);
      Wait(60, 120);

      if WaitUntil(MainScreen.GetUpText().Contains('ttack'), 20, 300) then
      begin
        Mouse.Click(MOUSE_LEFT);
        if MainScreen.DidRedClick() then
          Wait(600, 1800);
      end;
    end;
  end;

  Wait(50, 100);
end;


{********************************************}
{           NPC WIN DETECTION                }
{********************************************}

procedure TJdsPestControl.CheckNPCWin();
var
  txt: String;
begin
  // Avoid double counting if chat sits there
  if (GetSystemTime - Self.LastWinTime) < Self.WinCooldown then
    Exit;

  txt := LowerCase(Chat.GetChat());

  if txt.Contains('managed to destroy') then
  begin
    Self.GamesWon += 1;
    Self.LastWinTime := GetSystemTime();
    Self.Msg('Win detected. Total wins: ' + IntToStr(Self.GamesWon));
  end;
end;


{********************************************}
{                PLANK LOGIC                 }
{********************************************}

function TJdsPestControl.CrossPlank(): Boolean;
var
  TileRect : TRectangle;
  ClickPt  : TPoint;
  attempts : Int32;
begin
  Result := False;

  TileRect := Self.RSW.GetTileMS(Self.CrossPlankTile);

  attempts := 0;
  repeat
    Inc(attempts);

    ClickPt := SRL.RandomPoint(TileRect, SRL_GAUSS_CUTOFF / 1.5);
    Mouse.Move(ClickPt);
    Wait(40, 90);

    if WaitUntil(MainScreen.GetUpText().Contains('ross'), 120, 1200) then
    begin
      Mouse.Click(MOUSE_LEFT);

      if MainScreen.DidRedClick() then
      begin
        if WaitUntil(self.InBoat(), 600, 4000) then
        begin
          Result := True;
          Exit;
        end;
      end;
    end;

    Mouse.Move(ClickPt.Random(5, 15, True));
    Wait(60, 120);

    if (attempts mod 3 = 0) then
      Antiban.SmallCameraRotation();

  until attempts > 8;
end;


procedure TJdsPestControl.DoAtPlank();
begin
  // Chat only visible here before we leave the island
  Self.CheckNPCWin();

  if antiban.BioDice(25) then
  begin
    chat.ClickContinue(antiban.BioDice(98));
    wait(600, 1250, wdleft);
  end;

  if not Self.CrossPlank() then
  begin
    Self.RSW.WalkBlind(Self.PlankTile, 4);
    Wait(250, 450);

    // One more chance to catch the win message
    Self.CheckNPCWin();

    Self.CrossPlank();
  end;
end;


{********************************************}
{               INIT / RUN                   }
{********************************************}

procedure TJdsPestControl.Init(maxActions: UInt32; maxTime: UInt64); override;
begin
  Self.StartTime := GetSystemTime();
  Self.Msg('Initializing JDS Pest Control');

  inherited;

  Self.RSW.SetupRegions([RSRegions.PEST_CONTROL_ISLAND, RSRegions.PEST_CONTROL_OUTPOST], 8);
  Self.RSW.ScreenWalk := False;

  Self.PosCacheDelay := HumanGauss(0.75, 1.75, 1.0, 0.20, 0.15);
  Self.CachedPos := Self.RSW.GetMyPos();
  Self.CachedPosTime := GetSystemTime();
  Self.Msg('CachedPosTime: ' + ToStr(Self.PosCacheDelay));

  Self.CenterTile     := DEFEND_KNIGHT_BOX.Middle;

  case BoatToUtilize of
    1: begin
        Self.PlankTile := NOVICE_PLANK_TILE;
        Self.CrossPlankTile := Point(Self.PlankTile.x+4, Self.PlankTile.y);
    end;
    2: begin
        Self.PlankTile := INTER_PLANK_TILE;
        Self.CrossPlankTile := Point(Self.PlankTile.x-4, Self.PlankTile.y);
    end;
    3: begin
        Self.PlankTile := VETERAN_PLANK_TILE;
        Self.CrossPlankTile := Point(Self.PlankTile.x-4, Self.PlankTile.y);
    end;
  else
    begin
      Self.PlankTile := VETERAN_PLANK_TILE; // fallback end;
      Self.CrossPlankTile := Point(Self.PlankTile.x-4, Self.PlankTile.y);
    end;
  end;

  Self.LastXP      := XPBar.Read();
  Self.LastXPTime  := GetSystemTime();
  Self.NextAttackDelay := HumanGauss(2.3, 3.6, 2.9, 0.25, 0.10);
  Self.Msg('AttackDelay: ' + ToStr(Self.NextAttackDelay));

  Self.GamesWon    := 0;
  Self.LastWinTime := 0;
  Self.WinCooldown := 60 * 1000; // 1 min

  Self.PointsTotal := 0;
  Self.PointsTime  := 0;

  // Reset HUD timer
  PestHUD.LastUpdate := 0;
end;


procedure TJdsPestControl.Run(maxActions: UInt32; maxTime: UInt64);
begin
  Self.Init(maxActions, maxTime);

  //Use biohash to affect mouse
  ApplyBioMouse();

  // ===== DO LOGIN IF NEEDED =====
  if not rsclient.IsLoggedIn() then
  begin
    PestControl.Msg('Logging in Forced World ' + ToStr(_PCWorld));
    Login.LoginPlayer(); // no index
    WaitUntil(rsclient.IsLoggedIn(), 600, 15000);
    Wait(650, 1250);
    MainScreen.SetHighestPitch();
    wait(0, 600);
    Antiban.SmallCameraRotation();
  end else if Login.GetCurrentWorld <> _PCWorld then
  begin
    WorldHopper.Hop([_PCWorld], False);
    WaitUntil(rsclient.IsLoggedIn(), 600, 15000);
    Wait(650, 1250);
    MainScreen.SetHighestPitch();
    wait(0, 600);
    Antiban.SmallCameraRotation();
  end;

  repeat
    Self.State := Self.GetState();
    Self.SetAction(ToStr(Self.State));

    case Self.State of
      PCS_IN_BOAT:      Self.DoInBoat();
      PCS_WALK_CENTER:  Self.DoWalkCenter();
      PCS_DEFEND:       Self.DoDefend();
      PCS_AT_PLANK:     Self.DoAtPlank();
    else
      Wait(200, 1200, wdLeft);
    end;

    // Single Torwent-style antiban call per loop
    Self.DoAntiban(True, True);

    // Low-frequency Shifter-themed HUD
    PestHUD.UpdateAndDraw();

  until Self.ShouldStop();
end;


{********************************************}
{           TEXT REPORT + HUD REPORT         }
{********************************************}

function TBaseScript.BuildTextReport(): TStringArray; override;
var
  elapsedTime   : UInt64;
  winsPerHour   : Double;
begin
  Result := [];

  elapsedTime := Self.TimeRunning.ElapsedTime();

  Result += ' Action        : ' + Self.Action;
  Result += ' Runtime       : ' + SRL.MsToTime(elapsedTime, Time_Short).Trim();
  Result += ' Total Exp     : ' + SRL.FormatNumber(XPBar.TotalEarnedXP(), 2);
  Result += ' Exp/Hour      : ' + SRL.FormatNumber(
    NumberPerHour(XPBar.TotalEarnedXP(), elapsedTime), 2
  );

  winsPerHour := NumberPerHour(PestControl.GamesWon, elapsedTime);

  Result += ' Games Won     : ' + IntToStr(PestControl.GamesWon);
  Result += ' Wins / Hour   : ' + SRL.FormatNumber(winsPerHour, 2);
  Result += ' Points / Hour : ' + SRL.FormatNumber(winsPerHour * PointsPerGame, 2);
  Result += ' Next Break    : ' + TimeUntilNextBreak();

  Result += ' PestControl   : Footballjds <3''s waspscripts.com';
end;



{********************************************}
{                 SCRIPT GUI                 }
{********************************************}

{$IFDEF SCRIPT_GUI}
type
  TPestConfig = record(TScriptForm)
    PCInfo: TLabel;
  end;

var
  PestConfig: TPestConfig;

procedure TPestConfig.StartScript(sender: TObject); override;
var
  obj: TJSONObject;
begin
  obj := WLSettings.GetObject('remote_input');
  obj.Put('enabled', True);

  Login.Players[Login.PlayerIndex].Worlds := [_PCWorld];

  inherited;
end;



procedure TPestConfig.Run(); override;
var
  tab: TTabSheet;
begin
  Self.Setup('Wasp Pest Control');
  Self.Start.SetOnClick(@Self.StartScript);

  Self.AddTab('Script Settings');
  tab := Self.Tabs[High(Self.Tabs)];

  Self.CreateAccountManager(tab);

  with Self.PCInfo do
  begin
    Create(tab);
    SetCaption('Stands at center and defends the knight.' + LINEENDING +
               'Make sure you start next to veteran plank.');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(200));
  end;

  Self.CreateAntibanManager();
  Self.CreateWaspLibSettings();
  Self.CreateAPISettings();

  inherited;
end;
{$ENDIF}


{********************************************}
{                    ENTRY                   }
{********************************************}

begin
  {$IFDEF SCRIPT_GUI}
  PestConfig.Run();
  {$ENDIF}
  PestControl.Run(WLSettings.MaxActions, WLSettings.MaxTime);
end.

