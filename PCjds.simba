{$UNDEF SCRIPT_ID}{$DEFINE SCRIPT_ID := 'pest_control_jds'}
{$UNDEF SCRIPT_REVISION}{$DEFINE SCRIPT_REVISION := '6'}
{$DEFINE SCRIPT_GUI}

program WaspPestControl;

{$I SRL-T/osr.simba}
{$I WaspLib/osr.simba}

const
  PointsPerGame =   7;//veterans boat, med diary = 7
  _PCWorld      = 344;// Pest Control World is 344
{********************************************}
{                 ENUM STATES                }
{********************************************}

type
  EPestState = (
    PCS_IN_BOAT,
    PCS_WALK_CENTER,
    PCS_DEFEND,
    PCS_AT_PLANK,
    PCS_UNKNOWN,
    PCS_END_SCRIPT
  );

{********************************************}
{                 SCRIPT RECORD              }
{********************************************}

type
  TPestControl = record(TBaseWalkerScript)
    State            : EPestState;

    CenterTile       : TPoint;
    BoatTile         : TPoint;
    PlankTile        : TPoint;
    CrossPlankTile   : TPoint;

    // Legacy heartbeat fields (unused but harmless)
    LastBeat         : UInt64;
    HeartbeatInterval: Int32;

    LastScan         : UInt64;

    LastXP           : Int64;
    LastXPTime       : UInt64;
    NextAttackDelay  : Int32;

    StartTime        : UInt64;

    // === WIN TRACKING ===
    GamesWon      : UInt32;
    LastWinTime   : UInt64;
    WinCooldown   : UInt64;

    CachedPos      : TPoint;
    CachedPosTime  : UInt64;
    PosCacheDelay  : UInt32;   // milliseconds to trust cached pos
  end;

  {********************************************}
  {                 HUD RECORD                 }
  {********************************************}

  TPestHUD = record
    LastUpdate: UInt64;
    Text      : TStringArray;
  end;

var
  PestControl: TPestControl;
  PestHUD    : TPestHUD;

function HumanGauss(minVal, maxVal, mean, stdev: Double; bioWeight: Double = 0): Int32;
var
  r: Double;
begin
  // Generate base Gaussian
  r := SRL.GaussRand(mean, stdev);

  // Add user-specific noise (zero-mean, does not increase range)
  if bioWeight <> 0 then
    r += (BioHash - 0.5) * bioWeight;

  // Clamp inside range
  if r < minVal then r := minVal;
  if r > maxVal then r := maxVal;

  // Convert to ms
  Result := Round(r * 1000);
end;


{********************************************}
{                ANTIBAN SETUP               }
{********************************************}

procedure TAntiban.Setup(); override;
begin
  Self.Skills := [
    ERSSkill.ATTACK,
    ERSSkill.STRENGTH,
    ERSSkill.DEFENCE,
    ERSSkill.HITPOINTS,
    ERSSkill.TOTAL
  ];

  Self.MinZoom := 15;
  Self.MaxZoom := 40;

  inherited;
end;


{********************************************}
{                 LOGGING                    }
{********************************************}

procedure TPestControl.Msg(const s: String);
var
  t: UInt64;
  h, m, sec, ms: UInt64;
begin
  t := GetSystemTime() - Self.StartTime;

  // Convert ms → hh:mm:ss:ms
  h   := t div 3600000;
  m   := (t div 60000) mod 60;
  sec := (t div 1000) mod 60;
  ms  := t mod 1000;

  WriteLn(Format('[%.2d:%.2d:%.2d:%.3d]:[PCjds]: %s', [h, m, sec, ms, s]));
end;


procedure TPestHUD.UpdateAndDraw();
const
  BG_COLOR      = $151515;
  BORDER_COLOR  = $CC2A2A;
  HEADER_COLOR  = $D6B43A;
  TEXT_COLOR    = $E0E0E0;
var
  elapsed: UInt64;
  winsPerHour: Double;
  i, lineHeight: Int32;
  tbox: TBox;
  x, y: Int32;
begin
  // Run only every 10 seconds
  if (GetSystemTime - LastUpdate) < 10000 then
    Exit;
  LastUpdate := GetSystemTime;

  // ==== COMPUTE HUD TEXT ====
  Text := [];

  elapsed := PestControl.TimeRunning.ElapsedTime();
  winsPerHour := NumberPerHour(PestControl.GamesWon, elapsed);

  Text += 'Pest Control - Defender';
  Text += 'Runtime: ' + SRL.MsToTime(elapsed, Time_Short).Trim();
  Text += 'State: ' + ToStr(PestControl.State);
  Text += 'Wins: ' + IntToStr(PestControl.GamesWon);
  Text += 'Wins/hr: ' + SRL.FormatNumber(winsPerHour, 2);
  Text += 'Points/hr: ' + SRL.FormatNumber(winsPerHour * PointsPerGame, 2);
  Text += 'Total EXP: ' + SRL.FormatNumber(XPBar.TotalEarnedXP(), 2);
  Text += 'XP/hr: ' + SRL.FormatNumber(
                     NumberPerHour(XPBar.TotalEarnedXP(), elapsed), 2
                   );

  // ==== DRAW HUD ====
  lineHeight := 14;

  tbox := Box(
    MainScreen.Bounds.X1 + 10,
    MainScreen.Bounds.Y1 + 345,
    MainScreen.Bounds.X1 + 200,
    MainScreen.Bounds.Y1 + 345 + (lineHeight * (Length(Text)))
  );

  RSClient.Image().DrawBoxFilled(tbox.Expand(1), False, BORDER_COLOR);
  RSClient.Image().DrawBoxFilled(tbox, False, BG_COLOR);

  RSClient.Image().SetFontName('Arial');
  RSClient.Image().SetFontSize(11);

  x := tbox.X1 + 6;
  y := tbox.Y1 + 6;

  for i := 0 to High(Text) do
  begin
    if i = 0 then
      RSClient.Image().DrawText(Text[i], Point(x, y), HEADER_COLOR)
    else
      RSClient.Image().DrawText(Text[i], Point(x, y), TEXT_COLOR);
    y += lineHeight;
  end;
end;



{********************************************}
{           XP STATE / ATTACK LOGIC          }
{********************************************}

procedure TPestControl.UpdateXPState();
var
  xp: Int64;
begin
  xp := XPBar.Read();
  if xp <> Self.LastXP then
  begin
    Self.LastXP     := xp;
    Self.LastXPTime := GetSystemTime();
    Self.NextAttackDelay := Random(2299, 3600);
  end;
end;

function TPestControl.XPStale(): Boolean;
begin
  Result := (GetSystemTime - Self.LastXPTime) > Self.NextAttackDelay;
end;

function TPestControl.GetPos(): TPoint;
begin
  // If cache younger than PosCacheDelay, return cached location
  if (GetSystemTime - Self.CachedPosTime) < Self.PosCacheDelay then
    Exit(Self.CachedPos);

  // Otherwise refresh once
  Self.CachedPos := Self.RSW.GetMyPos();
  Self.CachedPosTime := GetSystemTime();

  Result := Self.CachedPos;
end;

{********************************************}
{               STATE DETECTION              }
{********************************************}

function TPestControl.GetState(): EPestState;
var
  pos: TPoint;
begin
  pos := Self.RSW.GetMyPos();

  if Distance(pos, Self.BoatTile) < 5 then
    Exit(PCS_IN_BOAT);

  if Distance(pos, Self.PlankTile) < 7 then
    Exit(PCS_AT_PLANK);

  if Distance(pos, Self.CenterTile) > 15 then
    Exit(PCS_WALK_CENTER);

  Result := PCS_DEFEND;
end;


{********************************************}
{                  ACTIONS                   }
{********************************************}

procedure TPestControl.DoInBoat();
begin
  Wait(700, 1300);
end;

procedure TPestControl.DoWalkCenter();
var
  ChancePrayer: Boolean;
begin
  ChancePrayer := (Random(0, 5) = 0);

  if Self.RSW.AtTile(Self.CenterTile, 15) then
  begin
    Minimap.EnablePrayer();
    Exit;
  end;

  if ChancePrayer then
  begin
    Minimap.EnablePrayer();
    Wait(0, 1000, wdLeft);
  end;

  Self.RSW.WalkBlind(Self.CenterTile, 10);
  Minimap.EnablePrayer();
  Wait(0, 1000, wdLeft);
end;


{********************************************}
{        SMART CLICK POINT FOR MONSTERS      }
{********************************************}
function TPestControl.GetMonsterClickPoint(): TPoint;
const
  BASE_RADIUS = 60; // radius at 50–100% zoom
  BORDER_COLOR = $DD7A26FF;
var
  tileMS     : TRectangle;
  centerMS   : TPoint;
  zoom       : Double;
  radius     : Int32;
  pts, inside: TPointArray;
  clusters   : T2DPointArray;
  pMean, pRand: TPoint;
  dx, dy, s  : Double;
  pt: TPoint;
begin
  Result := [-1, -1];

  //------------------------------------------------------
  // 1. Convert CenterTile → MainScreen projection
  //------------------------------------------------------
  tileMS := Self.RSW.GetTileMS(Self.CenterTile);
  if (tileMS.Top.X = 0) and (tileMS.Top.Y = 0) then
    Exit;

  centerMS := tileMS.Mean;

  //------------------------------------------------------
  // 2. Read real zoom level (0.0 → 1.0)
  //------------------------------------------------------
  zoom := MM2MS.ZoomLevel / 100.0;
  if zoom < 0 then zoom := 0;
  if zoom > 1 then zoom := 1;

  //------------------------------------------------------
  // 3. Convert zoom → search radius
  //------------------------------------------------------
  // zoom=1.0 → 100
  // zoom=0.5 → 150
  // zoom=0.0 → 200
  radius := Round(BASE_RADIUS + (BASE_RADIUS * (1 - zoom)));

  //------------------------------------------------------
  // 4. Find monster colors in MS
  //------------------------------------------------------
  pts := [];
  SRL.FindColors(pts, CTS2(15921928, 2, 0.08, 5.42), MainScreen.Bounds);
  if pts.Len = 0 then Exit;

  //------------------------------------------------------
  // 5. Keep only points inside the zoom-scaled circle
  //------------------------------------------------------
  inside := [];
  for pt in pts do
    if SRL.PointInCircle(pt, centerMS, radius) then
      inside += pt;

  if inside.Len = 0 then Exit;

  //------------------------------------------------------
  // 6. Cluster → pick closest cluster
  //------------------------------------------------------
  clusters := inside.Cluster(2);
  if clusters.Len = 0 then Exit;

  clusters.SortByMiddle(centerMS);

  pMean := clusters[0].Mean();
  pRand := clusters[0].RandomValue();

  //------------------------------------------------------
  // 7. Gaussian smoothly bias click from mean → point
  //------------------------------------------------------
  s := SRL.GaussRand(0.70, 0.10);
  if s < 0.55 then s := 0.55;
  if s > 0.90 then s := 0.90;

  dx := (pRand.X - pMean.X);
  dy := (pRand.Y - pMean.Y);

  Result.X := pMean.X + Round(dx * s);
  Result.Y := pMean.Y + Round(dy * s);

  //------------------------------------------------------
  // 8. Debug: draw outline of search region
  //------------------------------------------------------

  //RSClient.Image.DrawCircle(centerMS, radius, BORDER_COLOR);
end;





{********************************************}
{                 DEFEND LOOP                }
{********************************************}

procedure TPestControl.DoDefend();
var
  M: TPoint;
begin
  // Antiban is handled once per main loop in Run()
  Self.UpdateXPState();

  if Self.XPStale() then
  begin
    M := Self.GetMonsterClickPoint();
    if MainScreen.IsVisible(M) then
    begin
      Mouse.Move(M);
      Wait(60, 120);

      if WaitUntil(MainScreen.GetUpText().Contains('ttack'), 20, 300) then
      begin
        Mouse.Click(MOUSE_LEFT);
        if MainScreen.DidRedClick() then
          Wait(600, 1800);
      end;
    end;
  end;

  Wait(50, 100);
end;


{********************************************}
{           NPC WIN DETECTION                }
{********************************************}

procedure TPestControl.CheckNPCWin();
var
  txt: String;
begin
  // Avoid double counting if chat sits there
  if (GetSystemTime - Self.LastWinTime) < Self.WinCooldown then
    Exit;

  txt := LowerCase(Chat.GetChat());

  if txt.Contains('managed to destroy') then
  begin
    Self.GamesWon += 1;
    Self.LastWinTime := GetSystemTime();
    Self.Msg('Win detected. Total wins: ' + IntToStr(Self.GamesWon));
  end;
end;


{********************************************}
{                PLANK LOGIC                 }
{********************************************}

function TPestControl.CrossPlank(): Boolean;
var
  TileRect : TRectangle;
  ClickPt  : TPoint;
  attempts : Int32;
begin
  Result := False;

  TileRect := Self.RSW.GetTileMS(Self.CrossPlankTile);

  attempts := 0;
  repeat
    Inc(attempts);

    ClickPt := SRL.RandomPoint(TileRect, SRL_GAUSS_CUTOFF / 1.5);
    Mouse.Move(ClickPt);
    Wait(40, 90);

    if WaitUntil(MainScreen.GetUpText().Contains('ross'), 20, 350) then
    begin
      Mouse.Click(MOUSE_LEFT);

      if MainScreen.DidRedClick() then
      begin
        if WaitUntil(not Self.RSW.AtTile(Self.PlankTile, 2), 150, 4000) then
        begin
          Result := True;
          Exit;
        end;
      end;
    end;

    Mouse.Move(ClickPt.Random(5, 15, True));
    Wait(60, 120);

    if (attempts mod 3 = 0) then
      Antiban.SmallCameraRotation();

  until attempts > 8;
end;


procedure TPestControl.DoAtPlank();
begin
  // Chat only visible here before we leave the island
  Self.CheckNPCWin();

  if not Self.CrossPlank() then
  begin
    Self.RSW.WalkBlind(Self.PlankTile, 4);
    Wait(250, 450);

    // One more chance to catch the win message
    Self.CheckNPCWin();

    Self.CrossPlank();
  end;
end;


{********************************************}
{               INIT / RUN                   }
{********************************************}

procedure TPestControl.Init(maxActions: UInt32; maxTime: UInt64); override;
begin
  Self.StartTime := GetSystemTime();
  Self.Msg('Initializing JDS Pest Control');

  inherited;

  Self.RSW.Setup('C:\Users\jesse\AppData\Local\Simba\Scripts\waspscripts.com\PestControl.png');
  Self.RSW.ScreenWalk := False;

  Self.PosCacheDelay := HumanGauss(0.75, 1.75, 1.0, 0.20, 0.15);
  Self.CachedPos := Self.RSW.GetMyPos();
  Self.CachedPosTime := GetSystemTime();
  self.Msg('CachedPosTime: '+toStr(self.PosCacheDelay));

  Self.CenterTile     := Point(548, 188);
  Self.BoatTile       := Point(120, 172);
  Self.PlankTile      := Point(136, 172);
  Self.CrossPlankTile := Point(131, 172);

  Self.LastBeat          := 0;
  Self.HeartbeatInterval := Random(38000, 67000);

  Self.LastXP      := XPBar.Read();
  Self.LastXPTime  := GetSystemTime();
  Self.NextAttackDelay := HumanGauss(2.3, 3.6, 2.9, 0.25, 0.10);
  self.Msg('AttackDelay: '+toStr(self.NextAttackDelay));

  Self.GamesWon    := 0;
  Self.LastWinTime := 0;
  Self.WinCooldown := 60 * 1000; // 1 min

  // Reset HUD timer
  PestHUD.LastUpdate := 0;
end;


procedure TPestControl.Run(maxActions: UInt32; maxTime: UInt64);
begin
  Self.Init(maxActions, maxTime);
  login.Players[0].Worlds := [344];
  Login.Players[Login.PlayerIndex].Worlds := [_PCWorld];

  // ===== DO LOGIN IF NEEDED =====
  if not rsclient.IsLoggedIn() then
  begin
    PestControl.Msg('Logging in Forced World ' + ToStr(_PCWorld));
    Login.LoginPlayer(); // no index
    WaitUntil(rsclient.IsLoggedIn(), 200, 15000);
    Wait(Random(650, 1350));
    Antiban.SmallCameraRotation();
  end;

  repeat
    Self.State := Self.GetState();
    Self.SetAction(ToStr(Self.State));

    case Self.State of
      PCS_IN_BOAT:      Self.DoInBoat();
      PCS_WALK_CENTER:  Self.DoWalkCenter();
      PCS_DEFEND:       Self.DoDefend();
      PCS_AT_PLANK:     Self.DoAtPlank();
    else
      Wait(200, 1200, wdleft);
    end;

    // Single Torwent-style antiban call per loop
    Self.DoAntiban(True, True);

    // Low-frequency Shifter-themed HUD
    PestHUD.UpdateAndDraw();

  until Self.ShouldStop();
end;


{********************************************}
{           TEXT REPORT + HUD REPORT         }
{********************************************}

function TBaseScript.BuildTextReport(): TStringArray; override;
var
  elapsedTime: UInt64;
  winsPerHour: Double;
begin
  Result := [];

  elapsedTime := Self.TimeRunning.ElapsedTime();

  Result += ' Action        : ' + Self.Action;
  Result += ' Runtime       : ' + SRL.MsToTime(elapsedTime, Time_Short).Trim();
  Result += ' Total Exp     : ' + SRL.FormatNumber(XPBar.TotalEarnedXP(), 2);
  Result += ' Exp/Hour      : ' + SRL.FormatNumber(
    NumberPerHour(XPBar.TotalEarnedXP(), elapsedTime), 2
  );

  winsPerHour := NumberPerHour(PestControl.GamesWon, elapsedTime);

  Result += ' Games Won     : ' + IntToStr(PestControl.GamesWon);
  Result += ' Wins / Hour   : ' + SRL.FormatNumber(winsPerHour, 2);
  Result += ' Points / Hour : ' + SRL.FormatNumber(winsPerHour*PointsPerGame, 2);

  Result += ' PestControl   : Footballjds <3''s' +  ' waspscripts.com';
end;


{********************************************}
{                 SCRIPT GUI                 }
{********************************************}

{$IFDEF SCRIPT_GUI}
type
  TPestConfig = record(TScriptForm)
    PCInfo: TLabel;
  end;

var
  PestConfig: TPestConfig;

procedure TPestConfig.StartScript(sender: TObject); override;
var
  obj: TJSONObject;
begin
  // Force-override the remote_input config that WaspLib actually uses
  obj := WLSettings.GetObject('remote_input');

  obj.Put('enabled', True);
  // We'll use our own HUD instead of WaspLib's internal HUD
  obj.Put('hud_report', False);
  obj.Put('hud_debug', False);
  obj.Put('hud_transparent', True);
  obj.Put('block_real_input', True);

  // Optional: ensure text reports are also enabled
  WLSettings.Put('reports', True);

  inherited;
end;


procedure TPestConfig.Run(); override;
var
  tab: TTabSheet;
begin
  Self.Setup('Wasp Pest Control');
  Self.Start.SetOnClick(@Self.StartScript);

  Self.AddTab('Script Settings');
  tab := Self.Tabs[High(Self.Tabs)];

  Self.CreateAccountManager(tab);

  with Self.PCInfo do
  begin
    Create(tab);
    SetCaption('Stands at center and defends the knight.' + LINEENDING +
               'Make sure you start next to veteran plank.');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(200));
  end;

  Self.CreateAntibanManager();
  Self.CreateWaspLibSettings();
  Self.CreateAPISettings();

  inherited;
end;
{$ENDIF}


{********************************************}
{                    ENTRY                   }
{********************************************}

begin
  {$IFDEF SCRIPT_GUI}
  PestConfig.Run();
  {$ENDIF}
  PestControl.Run(WLSettings.MaxActions, WLSettings.MaxTime);
end.

