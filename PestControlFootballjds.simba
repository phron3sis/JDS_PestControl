{$UNDEF SCRIPT_ID}
{$DEFINE SCRIPT_ID := 'LITE_pest_control_jds'}
{$UNDEF SCRIPT_REVISION}
{$DEFINE SCRIPT_REVISION := '2'}
{$DEFINE SCRIPT_GUI}//Comment this line to disable gui
program WaspPestControl;
{$I SRL-T/osr.simba}
{$I WaspLib/osr.simba}

//USERS - SET THESE 6 CONSTANTS OR USE GUI
const
  USE_SCREEN_WALK:          Boolean = True;//False will use Adaptive
  LEAVE_GAME_EARLY:         Boolean = True;//Exit if activity hits 0
  USE_QUICK_PRAYERS:        Boolean = True;//Use quick prayer
  CHILL_IF_ACTIVE:          Boolean = True;//relax if activity is high
  DEFAULT_ACTIVITY_THRESHOLD: Int32 = 75;//Threshold to relax if desired
  POINTS_PER_GAME:            Int32 = 7;//Med/Hard CA's increase
//USERS - DO NOT MODIFY BELOW THIS LINE
  WARNING_DISABLED: boolean = FALSE;
const
  // Activity bar
  CLR_ACTIVITY_GREEN: Int32 = 40704;
  CLR_ACTIVITY_RED: Int32 = 255;
  ACTIVITY_BOX: TBox = [365, 121, 511, 131];
  // Boat interiors
  VETERAN_BOAT_BOX: TBox = [6105, 4695, 6120, 4718];
  INTER_BOAT_BOX: TBox = [6129, 4723, 6144, 4746];
  NOVICE_BOAT_BOX: TBox = [6218, 4740, 6233, 4763];
  // Plank tiles
  VETERAN_PLANK_TILE: TPoint = [6130, 4700];
  INTER_PLANK_TILE: TPoint = [6154, 4736];
  NOVICE_PLANK_TILE: TPoint = [6206, 4756];
  // Island areas
  DEFEND_KNIGHT_BOX: TBox = [5741, 5605, 5775, 5639];
  GAME_START_LANDING_BOX: TBox = [5752, 5532, 5773, 5562];
  KNIGHT_HP_BOX: TBox = [10, 172, 75, 192];
type
  EPestState = (PCS_IN_BOAT, PCS_WALK_CENTER, PCS_DEFEND, PCS_AT_PLANK, PCS_UNKNOWN, PCS_END_SCRIPT);

type
  TPrayerMode = (pmEarly, pmMid, pmLate);

type
  TAttackTempoProfile = record
    Floor, Mean, Ceil, Jitter: Double;
    TailChance, TailScale, Stick: Double;
  end;
type
  TJdsPestControl = record(TBaseWalkerScript)
    State: EPestState;
    CenterTile: TPoint;
    PlankTile: TPoint;
    CrossPlankTile: TPoint;
    OurBoatBox: TBox;
    GangplankObj: TRSObject;
    LastXP: Int64;
    LastXPTime: UInt64;
    KnightHealth: UInt32;
    KnightHPTimestamp: UInt64;
    ActivityThreshold: Int32;
    CurrentActivity: Int32;
    LastTimeDefendMove: UInt64;
    BoatAnchorPoint: TPoint;
    LastTimeBoatMove: UInt64;
    BoatMoveDelayTime: Double;
    XPAttackDelay: Double;
    NextAttackTime: Double;
    AttackTempo: TAttackTempoProfile;
    StartTime: UInt64;
    GamesWon: UInt32;
    LastWinTime: UInt64;
    WinCooldown: UInt64;
    CoinCountS: UInt64;
    CoinCountC: UInt64;
    PointsTotal: UInt32;
    PointsTime: UInt64;
    OurCmbtLvl: UInt32;
    OurCmbtStyle: String;
    PrayerMode: TPrayerMode;
    PrayerBaseTick: Int32;
    PrayerRunTick: Int32;
    WalkStartTime: Int64;
    UseScreenWalk: Boolean;
    LeaveGameEarly: Boolean;
    InitActivityThreshold: UInt32;
    UseQuickPrayers: Boolean;
    ChillIfActive: Boolean;
    PointsGame: Int32;
    SquireLeave: TRSNPC;
  end;
  TPestHUD = record
    LastUpdate: UInt64;
    Text: TStringArray;
    activityStr, prayerStr: String;
  end;
  TShifterDetection = record
    Mean: TPoint;
    Cluster: TPointArray;
    Secondary: TPointArray;
    ABox: TBox;
  end;
  TShifterDetectionArray = array of TShifterDetection;
var
  PestControl: TJdsPestControl;
  PestHUD: TPestHUD;

//don't wanna enable prayer at 0
function TRSMinimap.EnablePrayer(): Boolean; override;
begin
  if self.GetPrayerLevel <= 0 then exit;
  inherited;
end;

function TimeUntilNextBreak(onBreakOrSleep: boolean = False): String;
var
  i: Int32;
  soonest: PBreakTask;
  remaining: Int64;
begin
  if Length(Antiban.Breaks) = 0 then
    Exit('N/A');
  soonest := @ Antiban.Breaks[0];
  for i := 1 to High(Antiban.Breaks) do
    if Antiban.Breaks[i].NextAtTime < soonest ^.NextAtTime then
      soonest := @ Antiban.Breaks[i];
  remaining := Round(soonest ^.NextAtTime - GetTimeRunning());
  if remaining < 0 then
    remaining := 0;
  Result := SRL.MsToTime(remaining, Time_Short).Trim();
end;

//returns 0.9-1.1
function bMod(): Double;
const
  b: double = 0.9;//base value
  s:double = 0.2;//spread/range
begin
  Result := b + s * Frac(Sin(BioHash * 12.9898) * 43758.5453);
end;

//use to modify a number
//100*bModEx(0.9,0.3); spreads 90-120
function bModEx(base, spread: Double): Double;
var
  x: Double;
begin
  if spread < 0 then spread := 0;
  x := Frac(Sin(BioHash * 12.9898) * 43758.5453); // 0..1
  Result := base + spread * x;
end;

//use to modify a number
//100*bModSpread(1); spread 0-200
function bModSpread(spread: Double): Double;
var
  x: Double;
  s: Double;
begin
  s := spread;
  if s < 0 then s := 0;
  if s > 2 then s := 2;
  x := Frac(Sin(BioHash * 12.9898) * 43758.5453);// 0..1
  Result := 1 + (s * 0.5) * (2*x - 1);      // -1..1 → ±spread/2
end;


function JDSBioGauss(Mean, Dev: Double): Double; static;
const
  SCALE       = 0.2;   // ±20%
  JITTER      = 0.1;   // ±5% per call
  TWO_PI      = 2.0 * PI;
var
  b, meanScale, devScale, adjMean, adjDev, u1: Double;
begin
  b := BioHash;
  if (b <= 0.0) or (b >= 1.0) then
    b := nzRandom();

  meanScale := 1.0 + SCALE * Sin(b * TWO_PI);  // [0.8, 1.2]
  devScale  := 1.0 + SCALE * Cos(b * TWO_PI);  // [0.8, 1.2]

  adjMean := Mean * meanScale * (1.0 + JITTER * (nzRandom() - 0.5));
  adjDev  := Dev  * devScale  * (1.0 + JITTER * (Random()   - 0.5));

  u1 := nzRandom();
  Result := adjMean + adjDev * Sqrt(-2.0 * Ln(u1)) * Cos(TWO_PI * Random());
end;

//Abs(BioGaussian)
procedure BioGWait(Mean, Dev: Double);
begin
  Wait(Abs(Round(JDSBioGauss(Mean, Dev))));
end;

//BioGaussian + 0-Rand | non zero wait
procedure BioGWaitRand(Rand, Mean, Dev: Double);
begin
  Wait(Abs(Round(Random(0.0, Rand)+JDSBioGauss(Mean, Dev))));
end;

//BioGaussian + baseWait
procedure BioGWaitMin(baseWait: Int32; Mean, Dev: Double);
begin
  Wait(Abs(baseWait+Round(JDSBioGauss(Mean, Dev))));
end;

// LOGNORMAL (math form):
//   If Z ~ N(muLog, sigmaLog), then X = exp(Z) is lognormal.
//   Use when you want strictly positive, right-skewed reaction times.
function LogNormalEx(muLog, sigmaLog: Double): Double;
var
  z: Double;
begin
  // Gaussian using SRL RNG (non-deterministic)
  z := SRL.GaussRand(0.0, 1.0);

  // Lognormal transform
  Result := Exp(muLog + sigmaLog * z);

  if Result < 0 then
    Result := 0;
end;

// LOGNORMAL (human form):
//   base_ms       = typical delay (median-ish RT)
//   variation_pct = 0..1 (0.2–0.6 typical humans)
function LogNormal(base, variation: Double): Int32;
var
  muLog, sigma: Double;
begin
  if base <= 1 then
    base := 1;
  if variation < 0 then
    variation := 0;

  muLog := Ln(base);
  sigma := variation;

  Result := Round(LogNormalEx(muLog, sigma));
end;

procedure TAntiban.Setup(); override;
begin
  Self.Skills := [ERSSkill.ATTACK, ERSSkill.STRENGTH, ERSSkill.DEFENCE, ERSSkill.HITPOINTS, ERSSkill.TOTAL];
  Self.MinZoom := 25;
  Self.MaxZoom := 50;
  inherited;
end;

procedure TPestHUD.DrawActivityBar(const hudBox, headerBox: TBox;
  activityPercent, thresholdPercent, barColor: Int32);
const
  TRACK_COLOR     = $202020; // dark track
  THRESHOLD_COLOR = 13097697; // tick marker
var
  barBox, fillBox, tickBox: TBox;
  barHeight, fullWidth, filledWidth, thrX: Int32;
begin
  // Clamp inputs
  if activityPercent < 0 then
    activityPercent := 0;
  if activityPercent > 100 then
    activityPercent := 100;

  if thresholdPercent < 0 then
    thresholdPercent := 0;
  if thresholdPercent > 100 then
    thresholdPercent := 100;

  barHeight := 8;

  // Full-width bar a few pixels under the title
  barBox := Box(
    hudBox.X1 + 10,
    headerBox.Y2 + 6,
    hudBox.X2 - 10,
    headerBox.Y2 + 6 + barHeight
  );

  with RSClient.Image() do
  begin
    // Track
    DrawBoxFilled(barBox, False, TRACK_COLOR);

    // Filled portion
    fullWidth   := barBox.X2 - barBox.X1;
    filledWidth := (fullWidth * activityPercent) div 100;
    if filledWidth > 0 then
    begin
      fillBox := barBox;
      fillBox.X2 := fillBox.X1 + filledWidth;
      DrawBoxFilled(fillBox, False, barColor);
    end;

    // Threshold tick
    thrX := barBox.X1 + (fullWidth * thresholdPercent) div 100;
    tickBox := Box(thrX, barBox.Y1, thrX + 1, barBox.Y2);
    DrawBoxFilled(tickBox, False, THRESHOLD_COLOR);
  end;
end;


// ===========================================================================
// Modern HUD Update + Draw
// ===========================================================================

procedure TPestHUD.UpdateAndDraw(onBreakOrSleep: Boolean = False);
const
  // Palette (BGR)
  BG_COLOR          = $181818;  // panel background
  BORDER_COLOR      = $303030;  // outer border
  HEADER_BG_COLOR   = $181818;  // header bg (same as panel for flat look)
  HEADER_TEXT_COLOR = $3B9FFF;  // warm orange accent
  TEXT_COLOR        = $F0F0F0;  // main text
  TEXT_MUTED_COLOR  = $A5A5A5;  // secondary labels
  SEP_COLOR         = $252525;  // separators

  ACTIVITY_WARN_COLOR = $57C8FF; // between red/green

  PAD_X       = 4;
  PAD_Y       = 6;
  ROW_GAP     = 16;
var
  elapsed: UInt64;
  winsPerHour: Double;
  abox, aboxBorder, headerBox, footerBox, sigLine, sepBox: TBox;
  xLabel, xValue, y: Int32;
  labels: TStringArray;
  i, maxLabelWidth: Int32;
  size, sizeVal, sizeLbl: TPoint;

  activityValue, thrText: String;
  barColor, valueColor: Int32;
  actPercent, thrValueX, thrLabelX: Int32;
  runtimeStr, stateStr, totalPtsStr: String;
  winsStr, winsHrStr, ptsHrStr: String;
  coinsStr, profitStr, atkDelayStr: String;
  xpStr, xpHrStr: String;
  prayerStr, breakStr: String;
  profit: Int64;
  clFlash1, clFlash2: Int32;
begin
  // Throttle draw rate
  if (GetSystemTime - LastUpdate) < 1000 then
    Exit;
  LastUpdate := GetSystemTime();
  elapsed     := PestControl.TimeRunning.ElapsedTime();
  winsPerHour := NumberPerHour(PestControl.GamesWon, elapsed);

  // HUD bounds (same placement as before)
  abox       := Box(552, 206, 731, 463);
  aboxBorder := abox.Expand(2);
  headerBox  := Box(abox.X1, abox.Y1, abox.X2, abox.Y1 + 26);
  footerBox  := Box(abox.X1, abox.Y2 - 22, abox.X2, abox.Y2);

  with RSClient.Image() do
  begin
    // Panel + border
    DrawBoxFilled(aboxBorder, False, BORDER_COLOR);
    DrawBoxFilled(abox, False, BG_COLOR);

    // Header / title
    DrawBoxFilled(headerBox, False, HEADER_BG_COLOR);
    SetFontName('Segoe UI');
    SetFontAntialiasing(True);
    SetFontSize(18);
    DrawText('PEST CONTROL', Point(headerBox.X1 + PAD_X + 6, headerBox.Y1 + 5), HEADER_TEXT_COLOR);

    // Thin line under title
    sepBox := Box(abox.X1 + 8, headerBox.Y2, abox.X2 - 8, headerBox.Y2 + 1);
    DrawBox(sepBox, SEP_COLOR);

    // ===== label width (body font) =====
    SetFontSize(12);
    labels := ['Runtime', 'State', 'Total pts',
               'Wins', 'Wins/hr', 'Pts/hr',
               'Coins', 'Profit',
               'XP', 'XP/hr',
               'Prayer', 'Next break'];

    maxLabelWidth := 0;
    for i := 0 to High(labels) do
    begin
      size := TextSize(labels[i] + ':');
      if size.X > maxLabelWidth then
        maxLabelWidth := size.X;
    end;

    xLabel := abox.X1 + PAD_X + 8;
    xValue := xLabel + maxLabelWidth + 10;

    // ===== Activity block =====
    actPercent := PestControl.CurrentActivity;
    if actPercent < 0 then
      actPercent := 0;
    if actPercent > 100 then
      actPercent := 100;

    if PestControl.CurrentActivity < 0 then
    begin
      activityValue := 'N/A';
      valueColor    := TEXT_MUTED_COLOR;
      barColor      := ACTIVITY_WARN_COLOR;
    end
    else
    begin
      activityValue := IntToStr(PestControl.CurrentActivity) + '%';

      if PestControl.CurrentActivity < 30 then
      begin
        valueColor := CLR_ACTIVITY_RED;
        barColor   := CLR_ACTIVITY_RED;
      end
      else if PestControl.CurrentActivity < PestControl.ActivityThreshold then
      begin
        valueColor := ACTIVITY_WARN_COLOR;
        barColor   := ACTIVITY_WARN_COLOR;
      end
      else
      begin
        valueColor := CLR_ACTIVITY_GREEN;
        barColor   := CLR_ACTIVITY_GREEN;
      end;
    end;

    thrText := 'THR ' + IntToStr(PestControl.ActivityThreshold) + '%';

    // Activity bar right under header
    Self.DrawActivityBar(abox, headerBox, actPercent,
                         PestControl.ActivityThreshold, barColor);

    // Text: "ACTIVITY" label, big % left, THR value right
    y := headerBox.Y2 + 6 + 8 + 4; // header + bar + padding

    // Small ACTIVITY label
    SetFontSize(10);
    DrawText('ACTIVITY', Point(xLabel, y), TEXT_MUTED_COLOR);

    // --- THR small label on the same line as ACTIVITY ---
    SetFontSize(18);
    sizeVal := TextSize(IntToStr(PestControl.ActivityThreshold) + '%');
    thrValueX := abox.X2 - 14 - sizeVal.X; // a bit in from the right edge

    // Center "THR" label above the THR value
    SetFontSize(10);
    sizeLbl := TextSize('THR');
    thrLabelX := thrValueX;
    DrawText('THR', Point(thrLabelX, y), TEXT_MUTED_COLOR);

    // --- Big percentages on the same baseline ---
    SetFontSize(16);
    Inc(y, 10); // move down from labels to baseline

    // Activity %
    DrawText(activityValue, Point(xLabel, y), valueColor);

    // THR %
    DrawText(IntToStr(PestControl.ActivityThreshold) + '%',
             Point(thrValueX, y), TEXT_COLOR);

    // Separator under activity block
    y += 12;
    sepBox := Box(abox.X1 + 8, y, abox.X2 - 8, y + 1);
    DrawBox(sepBox, SEP_COLOR);
    y += 8;

    // ===== Precompute strings =====
    SetFontSize(12);

    runtimeStr   := SRL.MsToTime(elapsed, Time_Short).Trim();
    stateStr     := ToStr(PestControl.State).After('PCS_');
    totalPtsStr  := ToStr(PestControl.PointsTotal);
    winsStr      := IntToStr(PestControl.GamesWon);
    winsHrStr    := SRL.FormatNumber(winsPerHour, 2);
    ptsHrStr     := SRL.FormatNumber(winsPerHour * PestControl.PointsGame, 2);
    coinsStr     := SRL.FormatNumber(PestControl.CoinCountC, 2);
    profit       := Int64(PestControl.CoinCountC) - Int64(PestControl.CoinCountS);
    profitStr    := SRL.FormatNumber(profit, 2);
    xpStr        := SRL.FormatNumber(XPBar.TotalEarnedXP(), 2);
    xpHrStr      := SRL.FormatNumber(NumberPerHour(XPBar.TotalEarnedXP(), elapsed), 2);
    breakStr     := TimeUntilNextBreak();
    atkDelayStr  := toStr(round(PestControl.XPAttackDelay, 2));

    prayerStr := '';
    if PestControl.UseQuickPrayers then
    begin
      prayerStr := ToStr(PestControl.PrayerMode).Trim('pm');
      prayerStr += '(' + IntToStr(PestControl.PrayerRunTick) + ')';
    end;

    // ===== Body rows =====

    // Runtime
    DrawText('Runtime:', Point(xLabel, y), TEXT_MUTED_COLOR);
    DrawText(runtimeStr, Point(xValue, y), TEXT_COLOR);
    Inc(y, ROW_GAP);

    // State
    DrawText('State:', Point(xLabel, y), TEXT_MUTED_COLOR);
    DrawText(stateStr, Point(xValue, y), TEXT_COLOR);
    Inc(y, ROW_GAP);

    // Next break (moved up like reference image)
    DrawText('Next break:', Point(xLabel, y), TEXT_MUTED_COLOR);
    DrawText(breakStr, Point(xValue, y), TEXT_COLOR);
    Inc(y, ROW_GAP);

    // Separator before secondary stats
    sepBox := Box(abox.X1 + 8, y - 4, abox.X2 - 8, y - 3);
    DrawBox(sepBox, SEP_COLOR);

    // Wins
    DrawText('Wins:', Point(xLabel, y), TEXT_MUTED_COLOR);
    DrawText(winsStr, Point(xValue, y), TEXT_COLOR);
    Inc(y, ROW_GAP);

    // Wins/hr
    DrawText('Wins/hr:', Point(xLabel, y), TEXT_MUTED_COLOR);
    DrawText(winsHrStr, Point(xValue, y), TEXT_COLOR);
    Inc(y, ROW_GAP);

    // Pts/hr
    DrawText('Pts/hr:', Point(xLabel, y), TEXT_MUTED_COLOR);
    DrawText(ptsHrStr, Point(xValue, y), TEXT_COLOR);
    Inc(y, ROW_GAP);

    // Coins
    DrawText('Coins:', Point(xLabel, y), TEXT_MUTED_COLOR);
    DrawText(coinsStr, Point(xValue, y), TEXT_COLOR);
    Inc(y, ROW_GAP);

    // Profit
    DrawText('Profit:', Point(xLabel, y), TEXT_MUTED_COLOR);
    DrawText(profitStr, Point(xValue, y), TEXT_COLOR);
    Inc(y, ROW_GAP);

    // XP
    DrawText('XP:', Point(xLabel, y), TEXT_MUTED_COLOR);
    DrawText(xpStr, Point(xValue, y), TEXT_COLOR);
    Inc(y, ROW_GAP);

    // XP/hr
    DrawText('XP/hr:', Point(xLabel, y), TEXT_MUTED_COLOR);
    DrawText(xpHrStr, Point(xValue, y), TEXT_COLOR);
    Inc(y, ROW_GAP);

    // Compact PRAYER block in right-middle HUD area
        // Compact PRAYER block in right-middle HUD area

    if PestControl.UseQuickPrayers and (prayerStr <> '') then
    begin
      // "PRAYER" label
      SetFontSize(13);
      size := TextSize('PRAYER');
      DrawText(
        'PRAYER',
        Point(abox.X2 - 60 + (70 - size.X) div 2, headerBox.Y2 + 96),
        HEADER_TEXT_COLOR
      );

      // "pmMid(13)" style value
      SetFontSize(11);
      size := TextSize(prayerStr);
      DrawText(
        prayerStr,
        Point(abox.X2 - 60 + (70 - size.X) div 2, headerBox.Y2 + 110),
        TEXT_COLOR
      );
    end;

    // "AtkDelay" label
    SetFontSize(13);
    size := TextSize('AtkDelay');
    DrawText(
      'AtkDelay',
      Point(abox.X2 - 60 + (70 - size.X) div 2, headerBox.Y2 + 127),
      HEADER_TEXT_COLOR
    );

    // "3653.23" style value
    SetFontSize(11);
    size := TextSize(atkDelayStr);
    DrawText(
      atkDelayStr,
      Point(abox.X2 - 60 + (70 - size.X) div 2, headerBox.Y2 + 141),
      TEXT_COLOR
    );

    // "Pts Total" label
    SetFontSize(13);
    size := TextSize('Pts Total');
    DrawText(
      'Pts Total',
      Point(abox.X2 - 60 + (70 - size.X) div 2, headerBox.Y2 + 157),
      HEADER_TEXT_COLOR
    );

    // Total points on account
    SetFontSize(11);
    size := TextSize(totalPtsStr);
    DrawText(
      totalPtsStr,
      Point(abox.X2 - 60 + (70 - size.X) div 2, headerBox.Y2 + 171),
      TEXT_COLOR
    );

    // Footer
    DrawBoxFilled(footerBox, False, HEADER_BG_COLOR);
    sigLine := Box(footerBox.X1 + 4, footerBox.Y1 + 4, footerBox.X2 - 4, footerBox.Y1 + 4);
    DrawBox(sigLine, HEADER_TEXT_COLOR);

    SetFontSize(13);
    DrawText('Author: Footballjds',
             Point(footerBox.X1 + PAD_X + 8, footerBox.Y1 + 8),
             HEADER_TEXT_COLOR);

    if (not WARNING_DISABLED) and (Length(Antiban.Sleeps) < 1) and
      (Length(Antiban.Breaks) < 1) and (PestControl.TimeRunning.ElapsedTime() < (1*ONE_MINUTE)) then
    begin
      DrawBoxFilled(Box(33, 360, 225, 390), False, clWhite);
      SetFontName('Helvetica');
      if random(2) = 0 then
      begin
        clFlash1 := clRed;
        clFlash2 := clYellow;
      end else
      begin
        clFlash1 := clYellow;
        clFlash2 := clRed;
      end;
      // "no sleeps or beaks
      SetFontSize(16);
      size := TextSize('!WARNING! - !WARNING!');
      DrawText('!WARNING! - !WARNING!',
        Point(35, 362),
        clFlash1
      );
      SetFontSize(12);
      size := TextSize('Breaks and sleeps are disabled!');
      DrawText(
        'Breaks and sleeps are disabled!',
        Point(35, 362+16),
        clFlash2
      );
    end;
  end;
end;


function TJdsPestControl.ReadActivityBar(): Int32;
var
  greenCount: Int32;
begin
  Result := - 1;
  greenCount := CountColor(CLR_ACTIVITY_GREEN, 368, 126, 509, 126);
  greenCount += Antiban.GetUniqueInt(random(2, 4), 0, 9);
  if greenCount > 0 then
  begin
    Result := Round((greenCount / 141) * 100);
    Result := Max(0, Min(100, Result));
  end;
  Self.CurrentActivity := Result;
end;

procedure TJdsPestControl.SetActivThresh();
var
  theMean: Double;
  v: Int32;
begin
  theMean := self.InitActivityThreshold;
  EnsureRange(theMean, 45.0, 100.0);
  theMean := theMean * bMod();
  EnsureRange(theMean, 45.0, 100.0);
  v := Round(SRL.GaussRand(theMean, 5));
  v := EnsureRange(v, 45, 100);
  self.ActivityThreshold := v;
  Self.DebugLn('[SetAT]Activity threshold: ' + toStr(self.ActivityThreshold));
end;

//redo this procedure, clean and actually what you want
procedure TJdsPestControl.SetXPAttkDelay();
var
  p: TAttackTempoProfile;
  candidate, blended: Double;
begin
  p := Self.AttackTempo;

  // 1) Gaussian core around personal mean
  candidate := SRL.GaussRand(p.Mean, p.Jitter);

  // 2) replace with jds or srl dice
  if Antiban.BioDice(p.TailChance) then
    candidate := candidate + p.Mean * p.TailScale;

  // 3) Respect this account's envelope,
  if candidate < p.Floor then
    candidate := p.Floor
  else
  if candidate > p.Ceil then
    candidate := p.Ceil;

  // 4) Stickiness: blend with previous delay (slowly drifting tempo)
  if Self.XPAttackDelay > 0 then
    blended := p.Stick * Self.XPAttackDelay + (1.0 - p.Stick) * candidate
  else
    blended := candidate;

  Self.XPAttackDelay := blended;
end;

//should we set attack delay based on xp or when we attack?
//you don't get activity unless you get xp, so
procedure TJdsPestControl.UpdateXPState();
var
  xp: UInt64;
begin
  xp := XPBar.Read();
  if xp <> Self.LastXP then
  begin
    Self.LastXP := xp;
    Self.LastXPTime := GetSystemTime();
    Self.SetXPAttkDelay();
  end;
end;

function TJdsPestControl.XPFresh(): Boolean;
var
  lowActivityMod: Double = 0;
begin
  if Self.ActivityThreshold < (37*bMod()) then
  begin
    lowActivityMod := JDSBioGauss(1300,300);
    Debugln('[XPStl]Activity is low, attacking more often');
  end;
  Result := (GetSystemTime - Self.LastXPTime) < (Self.XPAttackDelay-lowActivityMod);
end;

function TJdsPestControl.XPStale(): Boolean;
var
  lowActivityMod: Double = 0;
begin
  if Self.ActivityThreshold < (37*bMod()) then
  begin
    lowActivityMod := JDSBioGauss(1300,300);
    Debugln('[XPStl]Activity is low, attacking more often');
  end;
  Result := (GetSystemTime - Self.LastXPTime) > (Self.XPAttackDelay-lowActivityMod);
end;

function TJdsPestControl.InBoat(): Boolean;
var
  rswPos: TPoint;
begin
  rswPos := self.rsw.GetMyPos();
  result := rswPos.InBox(VETERAN_BOAT_BOX) or rswPos.InBox(INTER_BOAT_BOX) or
    rswPos.InBox(NOVICE_BOAT_BOX);
end;

function TJdsPestControl.GetState(): EPestState;
var
  pos: TPoint;
begin
  pos := Self.RSW.GetMyPos();
  if pos.InBox(RSRegions.PEST_CONTROL_OUTPOST) then
  begin
    if pos.InBox(VETERAN_BOAT_BOX) or pos.InBox(INTER_BOAT_BOX) or pos.InBox(NOVICE_BOAT_BOX) then
      Exit(PCS_IN_BOAT);
    Exit(PCS_AT_PLANK);
  end;
  if pos.InBox(RSRegions.PEST_CONTROL_ISLAND) then
  begin
    if pos.InBox(DEFEND_KNIGHT_BOX) then
      Exit(PCS_DEFEND);
    Exit(PCS_WALK_CENTER);
  end;
  Result := PCS_UNKNOWN;
end;

procedure TJdsPestControl.UpdatePoints();
var
  BluePoints: Int32;

const
  CHECK_INTERVAL: Int32 = 1*ONE_MINUTE;
  PEST_POINTS_BOX: Tbox = [72, 64, 123, 81];
begin
  if GetSystemTime < (CHECK_INTERVAL + Self.PointsTime) then
    EXIT;
  BluePoints := ocr.RecognizeNumber(PEST_POINTS_BOX, TOCRColorFilter.Create([16777113]), RS_FONT_PLAIN_12);
  if BluePoints <= Self.PointsTotal then
    Exit;
  Self.PointsTotal := BluePoints;
  Self.PointsTime := GetSystemTime;
  Self.DebugLn('[UpPts]Total Points: ' + toStr(Self.PointsTotal));
end;

procedure TJdsPestControl.OnWalkingEvent(Sender: PRSWalker; Position: TPoint; Destination: TPoint);
var
  curTick: Int32;
begin
  if (Self.State <> PCS_WALK_CENTER) or (Minimap.IsPrayerEnabled()) or
    (Self.PrayerMode <> pmMid) or (Self.PrayerRunTick < 0) then
      Exit;
  curTick := (GetSystemTime - Self.WalkStartTime) div round(500*bMod());
  if (curTick >= Self.PrayerRunTick) and (self.UseQuickPrayers) then
  begin
    if Minimap.EnablePrayer() then
    begin
      Self.DebugLn('[OnWlk]Enabled prayer - curTick: '+ToStr(curTick));
      if JDSBioGauss(70, 20) > (70*bMod()) then
        Mouse.Move(Mainscreen.Bounds, true, MOUSE_DISTRIBUTION_GAUSS);
    end;
  end;
end;

procedure TJdsPestControl.MoveInsideBoat();
var
  myPos: TPoint;
  anchorMS: TPoint;
  clickSpot: TPoint;
begin
  if GetSystemTime() <= (Self.LastTimeBoatMove + Self.BoatMoveDelayTime) then
    Exit;
  myPos := Self.RSW.GetMyPos();
  if not myPos.InBox(Self.OurBoatBox) then
    Exit;
  anchorMS := minimap.PointToMS(rsw.WorldToMM(self.BoatAnchorPoint));
  if not MainScreen.Bounds.Contains(anchorMS) then
    EXIT;
  clickSpot := SRL.RandomPoint(anchorMS, 150);
  clickSpot := clickSpot.EnsureRange(MainScreen.Bounds);
  Mouse.Move(clickSpot);
  if MainScreen.IsUpText(['Walk here', 'Walk-here'], Random(80, 350)) then
    Mouse.Click(MOUSE_LEFT);
  Self.LastTimeBoatMove := GetSystemTime();
  Self.BoatMoveDelayTime := JDSBioGauss(25*ONE_SECOND, 11*ONE_SECOND);
  self.DebugLn('[MBoat]'+tostr(self.BoatMoveDelayTime));
end;

procedure TJdsPestControl.DoInBoat();
begin
  self.UpdatePoints();
  BioGWait(1600, 500);
  Self.MoveInsideBoat();
  Minimap.DisablePrayer();
end;

procedure TJdsPestControl.DoWalkCenter();
begin
  Self.WalkStartTime := GetSystemTime();
  if (Self.PrayerMode = pmEarly) and self.UseQuickPrayers then
    Minimap.EnablePrayer();
  Self.RSW.WalkBlind(Self.CenterTile.Random(- 8, 8, antiban.BioDice()), random(0, 5));
  if self.UseQuickPrayers and not Minimap.IsPrayerEnabled() then
    Minimap.EnablePrayer();
end;

function TJdsPestControl.GetShifters(): TShifterDetectionArray;
type
  TColorPair = record
    C1, C2: TCTS2Color;
  end;

var
  Profiles: array of TColorPair;
  P: TColorPair;
  primaryTPA, secondTPA: TPointArray;
  clusters: T2DPointArray;
  c: TPointArray;
  abox: TBox;
  tileMS: TRectangle;
  centerMS: TPoint;
  zoom: Double;
  radius: Int32;
  detections: TShifterDetectionArray;
  sh: TShifterDetection;
  msCenter: TPoint;

const
  EXPAND_PX = 7;
  MIN_PRIMARY = 7;
  MIN_SECOND = 7;

  procedure ProcessProfile(const CP: TColorPair);
  var
    i: Int32;
    newDist: Double;
  begin
    primaryTPA := [];
    SRL.FindColors(primaryTPA, CP.C1, MainScreen.Bounds);
    if primaryTPA = [] then
      Exit;
    clusters := primaryTPA.Cluster(6);
    for c in clusters do
    begin
      if c.Len < MIN_PRIMARY then
        Continue;
      abox := c.Bounds().Expand(EXPAND_PX);
      abox := abox.EnsureRange(MainScreen.Bounds);
      secondTPA := [];
      SRL.FindColors(secondTPA, CP.C2, abox);
      if secondTPA.Len >= MIN_SECOND then
      begin
        sh.Mean := c.Mean();
        sh.Cluster := c;
        sh.Secondary := secondTPA;
        sh.ABox := abox;
        if centerMS.DistanceTo(sh.Mean) <= radius then
        begin
          newDist := msCenter.DistanceTo(sh.Mean);
          i := Length(detections);
          SetLength(detections, i + 1);
          while (i > 0) and (msCenter.DistanceTo(detections[i-1].Mean) > newDist) do
          begin
            detections[i] := detections[i-1];
            Dec(i);
          end;
          detections[i] := sh;
        end;
      end;
    end;
  end;

begin
  SetLength(detections, 0);
  tileMS := Self.RSW.GetTileMS(DEFEND_KNIGHT_BOX.Middle());
  if (tileMS.Top.X = 0) and (tileMS.Top.Y = 0) then
    Exit;
  centerMS := tileMS.Mean;
  msCenter := MainScreen.center;

  zoom := MM2MS.ZoomLevel / 100.0;
  zoom := EnsureRange(zoom, 0.0, 1.0);
  radius := Round(100 + (zoom * 70));
  if Self.OurCmbtLvl >= 100 then
  begin
    SetLength(Profiles, 2);
    Profiles[0].C1 := CTS2(2347498, 12, 0.02, 1.15);
    Profiles[0].C2 := CTS2(2177617, 4, 0.20, 0.90);
    Profiles[1].C1 := CTS2(12963018, 3, 0.97, 0.47);
    Profiles[1].C2 := CTS2(9406348, 3, 0.46, 0.26);
  end
  else if Self.OurCmbtLvl >= 70 then
  begin
    SetLength(Profiles, 3);
    Profiles[0].C1 := CTS2(2177290, 5, 0.12, 6.09);
    Profiles[0].C2 := CTS2(3822370, 4, 0.15, 0.81);
    Profiles[1].C1 := CTS2(5066333, 5, 0.23, 0.33);
    Profiles[1].C2 := CTS2(5263713, 4, 0.30, 0.26);
    Profiles[2].C1 := CTS2(2347498, 12, 0.02, 1.15);
    Profiles[2].C2 := CTS2(2177617, 4, 0.20, 0.90);
  end
  else if Self.OurCmbtLvl >= 40 then
  begin
    SetLength(Profiles, 2);
    Profiles[0].C1 := CTS2(2107241, 5, 0.09, 0.60);
    Profiles[0].C2 := CTS2(2173038, 4, 0.11, 0.67);
    Profiles[1].C1 := CTS2(2177290, 5, 0.12, 6.09);
    Profiles[1].C2 := CTS2(3822370, 4, 0.15, 0.81);
  end
  else
    Self.Fatal('CmbtLVL: ' + ToStr(Self.OurCmbtLvl)+' is low.');

  for P in Profiles do
    ProcessProfile(P);

  Result := detections;
end;


procedure TJdsPestControl.MaybeLeaveGame();
var
  tmpPos: TPoint;
begin
  if self.LeaveGameEarly and (self.GetState = PCS_DEFEND) and (self.ReadActivityBar() < 1) then
  begin
    if Antiban.BioDice() then
      BioGWait(3000, 800);
    tmpPos := Self.RSW.GetMyPos();
    if tmpPos.InBox(RSRegions.PEST_CONTROL_ISLAND) then
      for 0 to 2 do
      begin
        tmpPos := Self.RSW.GetMyPos();
        if not tmpPos.InBox(RSRegions.PEST_CONTROL_ISLAND) then EXIT;
        try
          if SquireLeave.WalkSelectOption(['Leave Squire']) then
          begin
            BioGWait(2500,700);
          end;
        except
        end;
        Antiban.DoAntiban(False, False);
        biogwait(1200,300);
      end;
  end;
end;

procedure TJdsPestControl.PaceMidGame();
var
  platformClr: Int32 = 2782859;
  anyShifters: TShifterDetectionArray;
  platTPA_MM, platTPA_MS: TPointArray;
  aPoint: TPoint;
begin
  if self.ReadActivityBar() < self.ActivityThreshold then exit;
  anyShifters := self.GetShifters();
  if length(anyShifters) > 0 then exit;
  if srl.Dice(15+(bMod*10)) and (Self.GetState() = PCS_DEFEND) and
    FindColors(platTPA_MM, platformClr, Minimap.Bounds) then
    begin
      if platTPA_MM.len() < 100 then exit;
      platTPA_MM := platTPA_MM.FilterDist(0, 30+Round(biohash*15), platTPA_MM.mean.x, platTPA_MM.mean.y);
      platTPA_MM := platTPA_MM.FilterDist(0, 70, Minimap.Center.x, Minimap.Center.y);
      platTPA_MS := minimap.PointsToMS(platTPA_MM);
      platTPA_MS.SortCircle(platTPA_MS.mean, random(100)+round(100*biohash), random(2) =0);
      aPoint := platTPA_MS[random(high(platTPA_MS))];
      Mouse.Move(aPoint, 5, true);
      DebugLn('[PaceM]pacing...');
      if mainscreen.IsUpText(['alk-her', 'Walk-here', 'alk here'], round(JDSBioGauss(120, 30))) then
        Mouse.Click(MOUSE_LEFT) else
      begin
        Mouse.Click(MOUSE_RIGHT);
        if ChooseOption.IsOpen(Round(JDSBioGauss(300, 100)), 10) then
        begin
          Wait(LogNormal(200, 0.33));
          ChooseOption.Select(['alk-her', 'Walk-here', 'alk here'], MOUSE_LEFT, false, true);
        end;
      end;
    end;
end;

procedure TJdsPestControl.DoDefend();
var
  shifters: TShifterDetectionArray;
  sh: TShifterDetection;
  idx: UInt32;
  theRadius, dx, dy: Int32;
  clickPoint: TPoint;
  radius, theta, vNxtAttk: Double;
begin
  Self.MaybeLeaveGame();
  if (Self.NextAttackTime > GetSystemTime) then
    Exit;
  Self.UpdateXPState();
  if Self.XPFresh() then
    Exit;
  if self.ChillIfActive and antiban.BioDice(50) then
    if self.ReadActivityBar() > self.ActivityThreshold then
    begin
      PaceMidGame();
      BioGWait(2000, 650);
      EXIT;
    end;
  shifters := Self.GetShifters();
  if Length(shifters) < 1 then
  begin
    BioGWait(140, 45);
    Exit;
  end;
  if Length(shifters) = 1 then
    idx := 0
  else if Length(shifters) = 2 then
  begin
    if BioHash < 0.6 then
      idx := Antiban.GetUniqueInt(6, 0, Length(Shifters)-1)
    else
      idx := Random(0, 1);
  end
  else if Length(shifters) > 2 then
  begin
    idx := Round(Abs(SRL.GaussRand(0, High(shifters) * (0.3 + BioHash * 0.4))));
    idx := EnsureRange(idx, 0, High(shifters));
  end;
  sh := shifters[idx];
  if MM2MS.GetZoomLevel() < 37 then
    theRadius := 8
  else
    theRadius := 12;
  theRadius := Round(theRadius * (0.8 + BioHash * 0.4));
  repeat
    radius := Abs(SRL.GaussRand(2, theRadius * (0.4 + BioHash * 0.3)));
  until radius <= theRadius;
  theta := Random() * 2 * PI;
  dx := Round(radius * Cos(theta));
  dy := Round(radius * Sin(theta));
  clickPoint := Point(sh.Mean.X + dx, sh.Mean.Y + dy);
  Mouse.Move(clickPoint);
  if MainScreen.IsUpText('ttack', logNormal(100, 0.4)) then
  begin
    if (JDSBioGauss(100, 30) > 100) then
      Antiban.BioClick(MOUSE_LEFT, 3) else
        Mouse.click(MOUSE_LEFT);
    if MainScreen.DidRedClick(Round(JDSBioGauss(300, 50))) then
    begin
      vNxtAttk := bModEx(0.8, 0.4)*0.2;
      Self.NextAttackTime := GetSystemTime + lognormal(800, vNxtAttk);;
      Wait(LogNormal(400, vNxtAttk+0.05));
    end;
  end
  else
  begin
    if Antiban.BioDice(20) then
      Mouse.Click(MOUSE_LEFT);
    if Antiban.BioDice() then
      BioGWait(300, 70);
  end;
end;

procedure TJdsPestControl.CheckNPCWin();
var
  txt: String;
begin
  if (GetSystemTime - Self.LastWinTime) < Self.WinCooldown then
    Exit;
  txt := LowerCase(Chat.GetChat());
  if txt.Contains('managed to destroy') then
  begin
    Self.GamesWon += 1;
    Self.LastWinTime := GetSystemTime();
    Self.DebugLn('[IsWin]Win detected. Total wins: ' + IntToStr(Self.GamesWon));
  end;
end;

procedure TJdsPestControl.UpdateCoinCount();
var
  slots: TIntegerArray;
  curCount: UInt32;
begin
  if not Inventory.FindItems([617, 995, 996, 997, 998, 999, 1001, 1002, 1003, 1004], slots) then
    Exit;
  if slots.Len() = 1 then
    curCount := Inventory.CountSlotStack(slots[0]);
  if self.CoinCountS < 1 then
    Self.CoinCountS := curCount;//should only update one time per script run
  if curCount > Self.CoinCountC then Self.CoinCountC := curCount;
end;

function TJdsPestControl.CrossPlank(): Boolean;
begin
  Result := False;
  if self.GangplankObj.Click(Antiban.BioDice(83.7), random(3, 7)) then
    if WaitUntil(self.InBoat(), round(200*(biohash+1)), round(3000*(biohash+1))) then
    begin
      //Change per-game randomness here
      //That way every game our behavior changes
      //but is still unique per player
      Self.SetActivThresh();
      Self.PrayerRunTick := EnsureRange(Round(SRL.GaussRand(Self.PrayerBaseTick, 2.0)), 4, 26);
      self.DebugLn('Self.PrayerRunTick: '+toStr(Self.PrayerRunTick));

      Self.UpdateCoinCount();

      if Antiban.BioDice(5) and (Self.PrayerMode <> pmMid) then
        Self.PrayerMode := TPrayerMode(Ord(pmEarly) + Ord(pmLate) - Ord(Self.PrayerMode));
      if antiban.BioDice(10) then
        self.LastTimeBoatMove := GetSystemTime;
      EXIT(true);
    end;
end;

procedure TJdsPestControl.DoAtPlank();
begin
  Self.CheckNPCWin();
  BioGWait(500, 150);
  if antiban.BioDice then
    BioGWait(1500, 300);
  if antiban.BioDice(25) then
  begin
    chat.ClickContinue(antiban.BioDice(98));
    BioGWait(2000, 500);
  end;
  if not Self.CrossPlank() then
  begin
    Self.RSW.WalkBlind(Self.PlankTile.Random(- 7, 7, True), 4);
    biogwait(800, 250);
    Self.CheckNPCWin();
    Self.CrossPlank();
  end;
end;

procedure TJdsPestControl.InitBoatAnchor();
var
  rPoint: TPoint;
  x, y: Int32;
begin
  rPoint := Self.OurBoatBox.Center;
  x := round((Min(Self.OurBoatBox.Width,Self.OurBoatBox.Height)/2)*(biohash+nzRandom()));
  y := round((Min(Self.OurBoatBox.Width,Self.OurBoatBox.Height)/2)*(biohash+nzRandom()));
  Self.BoatAnchorPoint := rPoint.Offset(x, y);
  Self.BoatAnchorPoint :=
    self.BoatAnchorPoint.EnsureRange(Self.OurBoatBox);
end;

procedure TJdsPestControl.SetAttkProfile();
var
  d, rs: Int32;
  u, t, t3, s: Double;
  meanMid, meanHalf: Double;
const
  // Mean range
  MEAN_MIN_MS      = 2493.0;//3790.0
  MEAN_MAX_MS      = 3563.0;//5413.0

  // Floor / Ceil offsets around Mean
  FLOOR_BASE_MS    = 470.0;   // fastest bucket below mean
  FLOOR_PER_D_MS   = 12.0;    // slower buckets have slightly deeper floor

  CEIL_BASE_MS     = 650.0;   // slack above mean
  CEIL_PER_D_MS    = 150.0;   // slower buckets get more slack

  // Gaussian jitter (σ), driven by spam-click bucket
  JITTER_BASE_MS   = 180.0;
  JITTER_PER_RS_MS = 25.0;

  // Tail behaviour (lapses)
  TAIL_BASE_CH     = 2.0;     // TailChance = 2,4,...,20
  TAIL_PER_D_CH    = 2.0;

  TAILSCALE_BASE   = 0.50;    // TailScale = 0.50..1.58
  TAILSCALE_PER_D  = 0.12;

  // Stickiness (serial smoothing)
  STICK_BASE       = 0.45;    // more “lag” between delays
  STICK_PER_RS     = 0.03;
begin
  // Stable behavior buckets from BioHash digits
  d  := Antiban.GetBehavior(EBioBehavior.REACTION_SPEED);     // 0..9
  rs := Antiban.GetBehavior(EBioBehavior.SPAM_CLICK_CHANCE);  // 0..9

  // Chaotic BioHash → [0,1) seed using digits + behaviour buckets
  // Uses BioHash.GetDigit() like Antiban.GetBehavior/GetChance.
  // This is discrete and jumps around as digits change, so nearby BioHashes decorrelate harder.
  u := (
    BioHash.GetDigit(1)          +   // 0..9
    BioHash.GetDigit(3) * 10     +   // 0..90
    BioHash.GetDigit(5) * 100    +   // 0..900
    d                 * 1000     +   // 0..9000
    rs                * 10000        // 0..90000
  ) / 100000.0;                      // u ∈ [0, ~0.9999]

  // Map [0,1) -> [-0.5,0.5)
  t := u - 0.5;


  // Smooth S-shaped mapping to (-1,1):
  // s = (4*t^3 + 2*t) / 1.5
  t3 := t * t * t;
  s  := (4.0 * t3 + 2.0 * t) / 1.5;

  // Mean in [MEAN_MIN_MS, MEAN_MAX_MS]
  meanMid  := (MEAN_MIN_MS + MEAN_MAX_MS) * 0.5;
  meanHalf := (MEAN_MAX_MS - MEAN_MIN_MS) * 0.5;
  Self.AttackTempo.Mean := meanMid + meanHalf * s;

  // ----- Personal envelope (no clamping needed) -----
  // Floor always < Mean, Ceil always > Mean for bh∈[0,1], d∈[0..9]
  Self.AttackTempo.Floor :=
    Self.AttackTempo.Mean - (FLOOR_BASE_MS + d * FLOOR_PER_D_MS);

  Self.AttackTempo.Ceil :=
    Self.AttackTempo.Mean + (CEIL_BASE_MS + d * CEIL_PER_D_MS);

  // ----- Gaussian jitter (σ) -----
  Self.AttackTempo.Jitter :=
    JITTER_BASE_MS + rs * JITTER_PER_RS_MS;

  // ----- Tail frequency / magnitude (BioDice uses BioHash internally) -----
  Self.AttackTempo.TailChance :=
    TAIL_BASE_CH + d * TAIL_PER_D_CH;

  Self.AttackTempo.TailScale :=
    TAILSCALE_BASE + d * TAILSCALE_PER_D;

  // ----- Stickiness (higher when spam-click bucket is low) -----
  Self.AttackTempo.Stick :=
    STICK_BASE + (9 - rs) * STICK_PER_RS;

  // Start near the personal mean
  Self.XPAttackDelay := (Self.AttackTempo.Mean+JDSBioGauss(300, 100));
end;

procedure TJdsPestControl.LoadDefaults();
begin
  Self.UseScreenWalk      := USE_SCREEN_WALK;
  Self.LeaveGameEarly     := LEAVE_GAME_EARLY;
  Self.UseQuickPrayers    := USE_QUICK_PRAYERS;
  Self.ChillIfActive      := CHILL_IF_ACTIVE;
  Self.InitActivityThreshold  := EnsureRange(DEFAULT_ACTIVITY_THRESHOLD, 45, 100);
  Self.PointsGame         := EnsureRange(POINTS_PER_GAME, 3, 8);
end;

procedure TJdsPestControl.Init(maxActions: UInt32; maxTime: UInt64); override;
begin
  Self.StartTime := GetSystemTime();
  Self.Name := 'PCjds';
  Self.DebugLn('[INIT]: Initializing JDS Pest Control');
  inherited;
  Self.DebugLn('[INIT]: Points/game = ' + ToStr(Self.PointsGame));
  Self.RSW.SetupRegions([RSRegions.PEST_CONTROL_ISLAND, RSRegions.PEST_CONTROL_OUTPOST], 8);
  Self.RSW.ScreenWalk := Self.UseScreenWalk;
  if not Self.UseScreenWalk then
    self.rsw.AdaptiveWalk := true;
  Self.CenterTile := DEFEND_KNIGHT_BOX.Middle;
  Self.GamesWon := 0;
  Self.LastWinTime := 0;
  Self.WinCooldown := 60 * 1000;
  Self.PointsTotal := 0;
  Self.PointsTime := 0;
end;

procedure TJdsPestControl.Run(maxActions: UInt32; maxTime: UInt64);
begin
  Login.Players[Login.PlayerIndex].Worlds := [344];
  Self.Init(maxActions, maxTime);
  Login.Players[Login.PlayerIndex].Worlds := [344];
  RSClient.Image().DrawClear(clRed);
  RSClient.Image().Clear();
  Self.SetActivThresh();
  // 80% mid-run, 7.5% early, 7.5% late
  if SRL.Dice(85*bMod()) then
    Self.PrayerMode := pmMid
  else if BioHash < 0.5 then
    Self.PrayerMode := pmEarly
  else
    Self.PrayerMode := pmLate;
  self.SetAttkProfile();
  Self.DebugLn('AttackDelay: ' + ToStr(Self.XPAttackDelay));
  Self.DebugLn('Prayer mode is: '+toStr(self.PrayerMode));
  Self.PrayerBaseTick := Antiban.GetUniqueInt(16, 6, 24);
  Self.DebugLn('Self.PrayerBaseTick = '+toStr(Self.PrayerBaseTick));
  Self.PrayerRunTick := Self.PrayerBaseTick;
  Self.RSW.OnWalkingEvent := @ Self.OnWalkingEvent;
  Self.BoatMoveDelayTime := JDSBioGauss(25*ONE_SECOND, 11*ONE_SECOND);
  Self.LastTimeBoatMove := 0;
  Self.LastXP := XPBar.Read();
  Self.LastXPTime := GetSystemTime();
  Self.OurCmbtStyle := Combat.GetCombatStyle;
  Self.OurCmbtLvl := combat.GetCombatLevel;
  Self.DebugLn('Combat Level: ' + ToStr(Self.OurCmbtLvl));
  Self.DebugLn('Combat Style: ' + Combat.GetCombatStyle);
  if Self.OurCmbtLvl >= 100 then
  begin
    Self.PlankTile := VETERAN_PLANK_TILE;
    Self.OurBoatBox := VETERAN_BOAT_BOX;
    Self.CrossPlankTile := Point(6125, 4699);
  end
  else if Self.OurCmbtLvl >= 70 then
  begin
    Self.PlankTile := INTER_PLANK_TILE;
    Self.OurBoatBox := INTER_BOAT_BOX;
    Self.CrossPlankTile := Point(6149, 4735);
  end
  else if Self.OurCmbtLvl >= 40 then
  begin
    Self.PlankTile := NOVICE_PLANK_TILE;
    Self.OurBoatBox := NOVICE_BOAT_BOX;
    Self.CrossPlankTile := Point(6210, 4755);
  end
  else
    TerminateScript('Combat Level: ' + ToStr(self.OurCmbtLvl));
  self.InitBoatAnchor();
  with Self.GangplankObj do
  begin
    SetupCoordinates([Self.CrossPlankTile]);
    SetupUpText(['Cross', 'oss G', 'Gang']);
    ShapeArray.SetShape([1, 1, 1]);
    Finder.Colors := [CTS2(5402243, 8, 0.05, 0.06)];
    ActionUpText := ['Cross'];
  end;
  with Self.SquireLeave do
  begin
    Setup(5, 8, [Point(5752, 5564)]);
    SetupUpText(['Squire', 'Talk-to']);
    ActionUpText := ['Leave Squire', 'eave Squire', 'Leave Squi'];
    Filter.MinimapDot := True;
    Filter.Finder := False;
  end;
  repeat
    Self.State := Self.GetState();
    Self.SetAction(ToStr(Self.State));
    PestHUD.UpdateAndDraw();
    case Self.State of
      PCS_IN_BOAT: Self.DoInBoat();
      PCS_WALK_CENTER: Self.DoWalkCenter();
      PCS_DEFEND: Self.DoDefend();
      PCS_AT_PLANK: Self.DoAtPlank();
      else
        BioGWait(1200, 300);
    end;
    if (self.State = PCS_DEFEND) or (self.State = PCS_WALK_CENTER) and
      (self.ReadActivityBar() < self.ActivityThreshold) then
      begin
        //skip antiban when low activity
      end else
        if (self.State = PCS_DEFEND) or (self.State = PCS_WALK_CENTER) then
          Self.DoAntiban(False, False) else Self.DoAntiban(True, True);
    wait(LogNormal(120, 0.4*bModEx(0.7, 0.55)));
    if (self.PointsTotal >= 3900) then
      TerminateScript('Too many points my friend...');
  until Self.ShouldStop();
end;

function TBaseScript.BuildTextReport(): TStringArray; override;
var
  elapsedTime: UInt64;
  winsPerHour: Double;
begin
  Result := [];
  elapsedTime := Self.TimeRunning.ElapsedTime();
  Result += ' Action        : ' + Self.Action;
  Result += ' Runtime       : ' + SRL.MsToTime(elapsedTime, Time_Short).Trim();
  Result += ' Total Exp     : ' + SRL.FormatNumber(XPBar.TotalEarnedXP(), 2);
  Result += ' Exp/Hour      : ' + SRL.FormatNumber(NumberPerHour(XPBar.TotalEarnedXP(), elapsedTime), 2);
  winsPerHour := NumberPerHour(PestControl.GamesWon, elapsedTime);
  Result += ' Games Won     : ' + IntToStr(PestControl.GamesWon);
  Result += ' Wins / Hour   : ' + SRL.FormatNumber(winsPerHour, 2);
  Result += ' Points / Hour : ' + SRL.FormatNumber(winsPerHour * PestControl.PointsGame, 2);
  Result += ' Next Break    : ' + TimeUntilNextBreak();
  Result += ' PestControl   : Footballjds <3' 's waspscripts.com';
end;
{$IFDEF SCRIPT_GUI}

type
  TPestConfig = record(TScriptForm)
    PCInfo: TLabel;
    Config: TConfigJSON;
    slActivity: TTrackBar;

    // pest-control specific controls
    cbScreenWalk,
    cbLeaveEarly,
    cbQuickPrayers,
    cbChillIfActive: TLabeledCheckBox;

    boxActivityThreshold: TLabeledEdit;
    boxPointsPerGame   : TLabeledCombobox;
  end;

var
  PestConfig: TPestConfig;

procedure TPestConfig.OnSliderChanged(sender: TObject);
begin
  // Copy slider value into your existing LabeledEdit
  boxActivityThreshold.SetText(IntToStr(Self.slActivity.GetPosition()));
end;

procedure TPestConfig.StartScript(sender: TObject); override;
var
  obj : TJSONObject;
  cb  : TCheckBox;
  e   : TEdit;
  c   : TComboBox;
  pts : Int32;
begin
  // Existing remote input + world logic
  obj := WLSettings.GetObject('remote_input');
  obj.Put('enabled', True);
  Login.Players[Login.PlayerIndex].Worlds := [344];

  // Use ScreenWalk
  cb := Self.Form.GetChild('cb_screenwalk_checkbox');
  if (cb <> nil) then
  begin
    PestControl.UseScreenWalk := cb.IsChecked;
    Self.Config.Put('use_screenwalk', cb.IsChecked);
  end;

  // Leave game early
  cb := Self.Form.GetChild('cb_leaveearly_checkbox');
  if (cb <> nil) then
  begin
    PestControl.LeaveGameEarly := cb.IsChecked;
    Self.Config.Put('leave_game_early', cb.IsChecked);
  end;

  // Use quick prayers
  cb := Self.Form.GetChild('cb_quickprayers_checkbox');
  if (cb <> nil) then
  begin
    PestControl.UseQuickPrayers := cb.IsChecked;
    Self.Config.Put('use_quick_prayers', cb.IsChecked);
  end;

  // Chill if active
  cb := Self.Form.GetChild('cb_chill_if_active_checkbox');
  if (cb <> nil) then
  begin
    PestControl.ChillIfActive := cb.IsChecked;
    Self.Config.Put('chill_if_active', cb.IsChecked);
  end;

  // Activity threshold: 45–100
  e := Self.Form.GetChild('box_activity_edit');
  if (e <> nil) then
  begin
    PestControl.InitActivityThreshold := 45 + Round((StrToInt(e.getText) - 10) * 0.611111);
    EnsureRange(PestControl.InitActivityThreshold, 37, 100);
    Self.Config.Put('activity_threshold', IntToStr(PestControl.InitActivityThreshold));
  end;

  // Points per game: from combo text, restrict 3–8
  c := Self.Form.GetChild('box_pointspergame_combobox');
  if (c <> nil) then
  begin
    pts := EnsureRange(StrToInt(c.getText), 3, 8);

    PestControl.PointsGame := pts;
    Self.Config.Put('points_per_game', IntToStr(PestControl.PointsGame));
  end;

  inherited;
end;

procedure TPestConfig.Run(); override;
const
  JDS_IMG_PATH = AppPath + 'Resources' + DirectorySeparator + 'JDSPestControl.png';
var
  tab  : TTabSheet;
  y, actualThreshold: Int32;
  Img   : TPicture;//750, 500
  jdsImage : TImage;
begin
  Self.Setup('Pest Control by Footballjds');
  Self.Config.Setup('pest-control-jds');
  self.PageControl.setColor(3380416);

  // Create a single tab
  Self.AddTab('Settings');

  tab := Self.Tabs[High(Self.Tabs)];
  Self.CreateAccountManager(tab);

  // Ensure Resources folder exists
  if not DirectoryExists(AppPath + 'Resources' + DirectorySeparator) then
    CreateDirectory(AppPath + 'Resources');

  DownloadToFile('https://i.imgur.com/tjftZnz.png', JDS_IMG_PATH, false);

  // Global background image (all tabs)
  if FileExists(JDS_IMG_PATH) then
  begin
    Img.Init();
    Img.LoadFromFile(JDS_IMG_PATH);

    jdsImage.Init(Self.PageControl);
    jdsImage.SetParent(Self.PageControl);
    jdsImage.SetBounds(0, 0, Self.Form.getWidth(), Self.Form.getHeight() - TControl.AdjustToDPI(50));
    jdsImage.SetStretch(True);
    jdsImage.setPicture(Img);
  end;

  y := 160;

  cbScreenWalk.Create(tab);
  cbScreenWalk.SetName('cb_screenwalk');
  cbScreenWalk.SetCaption('Use ScreenWalk');
  cbScreenWalk.SetHint('Alternative is adaptive walk');
  cbScreenWalk.SetColor(8101037);
  cbScreenWalk.SetWidth(128);
  cbScreenWalk.SetLeft(30);
  cbScreenWalk.SetTop(y);
  y+=24;

  cbLeaveEarly.Create(tab);
  cbLeaveEarly.SetName('cb_leaveearly');
  cbLeaveEarly.SetCaption('Leave game early');
  cbLeaveEarly.SetHint('If activity hits 0...');
  cbLeaveEarly.SetColor(8101037);
  cbLeaveEarly.SetWidth(128);
  cbLeaveEarly.SetLeft(30);
  cbLeaveEarly.SetTop(y);
  Inc(y, 24);


  cbQuickPrayers.Create(tab);
  cbQuickPrayers.SetName('cb_quickprayers');
  cbQuickPrayers.SetCaption('Use quick prayers');
  cbLeaveEarly.SetHint('Be sure to setup quick prayers!');
  cbQuickPrayers.SetColor(8101037);
  cbQuickPrayers.SetWidth(128);
  cbQuickPrayers.SetLeft(30);
  cbQuickPrayers.SetTop(y);
  Inc(y, 24);

  cbChillIfActive.Create(tab);
  cbChillIfActive.SetName('cb_chill_if_active');
  cbChillIfActive.SetCaption('Relax if high activity');
  cbChillIfActive.SetHint('Want to AFK when activity > threshold?');
  cbChillIfActive.SetColor(8101037);
  cbChillIfActive.SetWidth(128);
  cbChillIfActive.SetLeft(30);
  cbChillIfActive.SetTop(y);
  y := 160;

  boxActivityThreshold.Create(tab);
  boxActivityThreshold.SetName('box_activity');
  boxActivityThreshold.SetCaption('Chill %');
  boxActivityThreshold.SetHint('Activity percent to AFK at');
  boxActivityThreshold.SetColor(8101037);
  boxActivityThreshold.SetLeft(220);
  boxActivityThreshold.SetTop(y);
  boxActivityThreshold.SetWidth(62);
  y+=48;

  // SLIDER for Activity Threshold (45–100)
  slActivity.Create(tab);
  slActivity.SetLeft(282);
  slActivity.SetTop(y-30);
  slActivity.SetWidth(60);
  slActivity.setMin(45);
  slActivity.setMax(100);
  slActivity.setTickStyle(tsNone);

  //Load previous value or use default
  if Self.Config.Has('activity_threshold') then
  begin
    actualThreshold := (Self.Config.GetInt('activity_threshold'));

    //I can't figure out the slider, so I just scale it
    actualThreshold := Round(((actualThreshold-45)/0.611111) + 10);
    Self.slActivity.SetPosition(actualThreshold);
  end else
    Self.slActivity.SetPosition(DEFAULT_ACTIVITY_THRESHOLD);

  // Bind event
  Self.slActivity.SetOnChange(@Self.OnSliderChanged);

  boxPointsPerGame.Create(tab);
  boxPointsPerGame.SetName('box_pointspergame');
  boxPointsPerGame.SetCaption('Points for winning');
  boxPointsPerGame.SetHint('Diaries affect points earned');
  boxPointsPerGame.SetColor(8101037);
  boxPointsPerGame.AddItemArray(['3','4','5','6','7','8']);
  boxPointsPerGame.SetStyle(csDropDownList);
  boxPointsPerGame.SetLeft(220);
  boxPointsPerGame.SetTop(y);
  boxPointsPerGame.SetWidth(124);
  boxPointsPerGame.SetHeight(38);


  with Self.PCInfo do
  begin
    Create(tab);
    SetCaption('Pest Control LITE' + LINEENDING + '     by Footballjds');
    SetLeft(45);
    SetTop(310);
    SetAutoSize(True);
    GetFont().setName('Comic Sans MS');
    GetFont().setColor(8758454);
    GetFont().SetSize(22);
    GetFont().SetStyle([fsBold]);
  end;

  if Self.Config.Has('use_screenwalk') then
    cbScreenWalk.SetChecked(Self.Config.GetBoolean('use_screenwalk'));

  if Self.Config.Has('leave_game_early') then
    cbLeaveEarly.SetChecked(Self.Config.GetBoolean('leave_game_early'));

  if Self.Config.Has('use_quick_prayers') then
    cbQuickPrayers.SetChecked(Self.Config.GetBoolean('use_quick_prayers'));

  if Self.Config.Has('chill_if_active') then
    cbChillIfActive.SetChecked(Self.Config.GetBoolean('chill_if_active'));

  if Self.Config.Has('activity_threshold') then
    boxActivityThreshold.SetText(IntToStr(Self.Config.GetInt('activity_threshold')));

  if Self.Config.Has('points_per_game') then
    boxPointsPerGame.ComboBox.SetCaption(IntToStr(Self.Config.GetInt('points_per_game')));

  Self.CreateAntibanManager();
  Self.CreateWaspLibSettings();
  Self.CreateAPISettings();
  Self.Start.SetOnClick(@Self.StartScript);
  inherited;
end;
{$ENDIF}

begin
  PestControl.LoadDefaults();
{$IFDEF SCRIPT_GUI}
  PestConfig.Run();
{$ENDIF}
  PestControl.Run(WLSettings.MaxActions, WLSettings.MaxTime);
end.
