{$DEFINE SCRIPT_ID := 'pest_control_jds'}
{$DEFINE SCRIPT_REVISION := '1'}
{$DEFINE SCRIPT_GUI}
{$I WaspLib/osrs.simba}
const
  USE_AUTO_START    = TRUE;//auto-start
  AUTO_START_DELAY  = 30;  //delay(in seconds) before auto-starting
type
  TPestControlGameData = record
    Nov, Inter, Vet: record
      AtPlank, PlankObj: TPoint;
      BoatBox: TBox;
    end;

    Portals: record
      W, SW, SE, E: TPoint;
    end;

    Knight, Spawn, LeaveNPC: TPoint;

    OCR: record
      KnightHP: TBox;
      ActivBox, PointsBox, W, E, SE, SW: TBox;
      Shield_W, Shield_E, Shield_SE, Shield_SW: TBox;
      ActivGreen, ActivRed: Int32;
    end;

    GameIsland, OutpostIsland: TBox;
  end;

var
  PCData: TPestControlGameData;

// =============================================================================
// ENUMS
// =============================================================================

type
  EPestState = (
    INIT,
    LOGIN,
    CMBT_LVL,
    
    IN_BOAT,
    WALK_MID,
    DEFEND,
    AT_PLANK,
    EXIT_GAME,
    ANTIBAN,
    BREAK,
    SLEEP,

    NO_ACTIVITY, UNKNOWN, MAX_ACTIONS, MAX_TIME, END_SCRIPT
  );
  EAttackChoice = (Self, Knight, Rand);
// =============================================================================
// TYPES
// =============================================================================
type
  TAttackTempo = record
    XPMean, XPStick, LowMean, LowStick: Double;
  end;
  TStateTimer = record
    Times: array[EPestState] of Int64;  // milliseconds per state
  end;
type
  TUV = record
    Hash, Salt: String;   // Hash string + Salt
    U: Double;// U (0..1)
  end;
  TUVArray = array of TUV;
type
  TFatigue = record
    Lvl: Double;
    Start: UInt64;
    Last: UInt64;

    U: TUVArray;

    Rate: Double;          // 0.015-0.045/min: Exponential rise rate (tau = 22-67 min)
    Drift: Double;         // 0.05-0.15: Random walk volatility (per sqrt(min))
    DriftCur: Double;      // Current drift offset
    Revert: Double;        // 0.03-0.10/min: Mean reversion speed
    OnsetTime: Double;     // 15-35 min: Midpoint of sigmoid ramp
    OnsetSteep: Double;    // Sigmoid steepness

    RTMult: Double;        // 1.15-1.60
    ErrRate: Double;       // 0.02-0.12
    BrkRecov: Double;      // 0.20-0.40/min
    SlpRecov: Double;      // 0.70-1.00/min
  end;
type
  TPestControl = record

    // Account unique decisions
    Flag: record
      NoPray, NoLeave, NoBoatMove, DelayBoatMove: Boolean;
      Choices: TUVArray;
    end;

    State: EPestState;
    StateT: UInt64;
    StateTimer: TStateTimer;
    
    // Map coordinates
    Center, AtPlank, CrossPlank: TPoint;
    BoatBox: TBox;

    // U's and Choices
    P: TUVArray; // Prayer
    M: TUVArray; // Mouse
    attkC: TUVArray; // Attack choices
    AttackChoice: EAttackChoice;
    AttackIndex: Int32;
    AttackWeights: array[0..2] of Double;
    AttackStick: Double;

    // Objects & Entities  
    Gangplank: TRSObject;
    Squire, Shifter: TRSEntity;

    // Timing
    F: TFatigue;//Fatigue
    bRT: Double;
    RT: TUVArray;//0..2 RT_U1, RT_U2, RTC_U
    Tempo: TAttackTempo;
    XPAttkDelay: Double;
    NextAttkDelay, LastAttack: Double;
    LastXP: UInt64;
    LastXPTime: UInt64;
    HUDLastUpdate: UInt64;
    GameStart: UInt64;
    GameStarted: Boolean;

    // Prayer
    PrayerEnableTime: Double;
    
    // Boat movement
    LastBoatMove: UInt64;
    BoatMoveDelay: Double;
    
    // Activity
    ActivityThresh: Int32;
    
    // Stats
    Start, LastWin: UInt64;
    KnightHP, wHP, eHP, seHP, swHP, portalsHP: Int32;
    WShielded, EShielded, SEShielded, SWShielded: Boolean;
    GamesWon, PtsPerGame, LeaveGameCount: UInt32;
    PtsStart, PtsEarned, PtsTotal: Int32;
    
    // Config
    CombatLevel: Int32;
    UserDisableHUD, UserDisableMoveInBoat, UserDisablePace, UserDisableLeaveGame: Boolean;
    Actions, MaxActions, MaxTime: UInt64;
    UserActiveThreshold, UserCombatLevel: Int32;
    UserQuickPrayer, UserChillIfActive, UserDisableFatigue: Boolean;
  end;

var
  PestControl: TPestControl;
  bhM, _bhM: TUV;

// =============================================================================
// HELPER FUNCTIONS - Distribution Math
// =============================================================================

procedure TFatigue.Recover(rate: Double; dt: UInt64);
begin
  Self.Lvl := Self.Lvl * Exp(-rate * dt / 60000.0);
  Self.Last := Time;
end;

property TFatigue.RT: Double;
begin
  Self.Update();
  Result := 1.0 + (Self.RTMult - 1.0) * Self.Lvl;  // Interpolate: fresh=1.0, exhausted=RTMult
end;

property TFatigue.Err: Boolean;
begin
  Self.Update();
  Result := Random() < Self.ErrRate * Self.Lvl;  // Scale: fresh=0%, exhausted=ErrRate
end;

property TFatigue.GetLvl: Double;
begin
  Self.Update();
  Result := Self.Lvl;
end;

// 0 < Random < 1
function NZRandom: Double;
begin
  repeat
    Result := Random;
  until (Result > 0) and (Result < 1);

end;

// LOGNORMAL (math form):
//   If Z ~ N(muLog, sigmaLog), then X = exp(Z) is lognormal.
//   Use when you want strictly positive, right-skewed reaction times.
function LogNormalEx(muLog, sigmaLog: Double): Double;
begin
  // Lognormal transform
  Result := Exp(muLog + sigmaLog * GaussRand(0.0, 1.0));
end;

// LOGNORMAL (human form):
//   mean          = typical delay (mean-ish RT)
//   variation_pct = 0..1 (0.2–0.6 typical humans)
function LogNormal(mean, sigma: Double): Double;
begin
  Result := LogNormalEx(Ln(mean) - 0.5 * sigma * sigma, sigma);
end;

function LogNormalInt(mean, sigma:Double): UInt64;
begin
  Result := Round(LogNormal(mean, sigma));
end;

// EX-GAUSSIAN (math form):
//   X = Gaussian(mu, sigma) + Exponential(tau)
//   This is the classic RT model: Gaussian core + exponential tail.
function ExpoGaussEx(mu, sigma, tau: Double): Double;
begin
  // Gaussian core + Exponential tail (rate = 1/tau)
  Result := GaussRand(mu, sigma) + (-tau * Ln(NZRandom));

  if Result < 0 then
    Result := 0;
end;

//use expogauss for RT and automatically adjust values per account
function ExpoGaussRT(mean, variance, tail: Double): Double;
var
  mu, sigma, tau: Double;
begin
  if mean < 1 then mean := 1;
  if variance < 0 then variance := 0;
  if tail < 0 then tail := 0;

  mean := Mean * PestControl.F.RT;

  mu := mean;
  sigma := mean * (0.21 + 0.13 * variance);
  tau := mean * (0.18 + 0.15*tail);

  Result := ExpoGaussEx(mu, sigma, tau);
end;

function ExGaussInt(mean: Double): UInt64;
begin
  Result := Round(ExpoGaussRT(mean, PestControl.RT[0].U, PestControl.RT[1].U));
end;

// WEIBULL (math form):
//   CDF: 1 - exp(-(x/scale)^shape)
//   shape_k > 0, scale_lambda > 0
//   Useful for fatigue / hazard-rate modeling.
function WeibullEx(shape_k, scale_lambda: Double): Double;
var
  u: Double;
begin
  if shape_k <= 0 then
    shape_k := 0.000001;
  if scale_lambda <= 0 then
    scale_lambda := 0.000001;

  u := NZRandom; // uniform [0,1)

  // Inverse CDF
  Result := scale_lambda * Power(-Ln(u), 1.0 / shape_k);

  if Result < 0 then
    Result := 0;
end;

procedure TUV.Create(salt: String = '');
 var
  hashStr, output: String;
  hashValue: UInt64;
  eps: double = 5.42101086242752E-20;
  r: Double;
begin
  hashStr := HashString(EHashAlgo.SHA1, Profiles[ProfileIndex].Name + Profiles[ProfileIndex].Username + salt);
  Self.Hash := Profiles[ProfileIndex].Name + Profiles[ProfileIndex].Username;
  Self.Salt := salt;
  // Use first 16 hex chars (8 bytes = 64 bits) for full Double precision
  hashValue := StrToInt64('$' + Copy(hashStr, 1, 16));

  r := hashValue / High(UInt64); // Normalize to 0.0 - 1.0

  // patch only the impossible-for-math endpoints
  if r <= 0.0 then r := eps;         // replaces exact 0 only
  if r >= 1.0 then r := 1.0 - eps;   // replaces exact 1 only

  Self.U := r;
  WriteLn(PadR(Self.Salt, 16), Self.U);
end;

procedure TUVArray.Create(salts: TStringArray);
var
  i: Int32;
begin
  SetLength(Self, salts.Length);
  for i := 0 to salts.High do
    Self[i].Create(salts[i]);
end;

function TUVArray.Get(salt: String): Double;
var
  i: Integer;
begin
  for i := 0 to Self.High do
    if Self[i].Salt = salt then
      Exit(Self[i].U);
  Writeln GetDebugLn('Salt not found: ' + salt, ELogLevel.ERROR, True);
end;

//override include to set zoom if it is wrong
function TRSOptions.GetZoomLevel(useCache: Boolean = True): Integer; override;
begin
  if useCache and (Self.ZoomLevel > -1) then
    Exit(Self.ZoomLevel);

  WriteLn GetDebugLn('Options', 'Unknown zoom level, reading from the gametab...');
  if Self.OpenTab(ERSOptionsTab.DISPLAY) then
    Self.ZoomLevel := Self.Sliders[ERSOptionsSlider.ZOOM].GetLevel();
  if Self.ZoomLevel = -1 then
    WriteLn GetDebugLn('Options', 'Failed to read zoom!', ELogLevel.ERROR)
  else
    WriteLn GetDebugLn('Options', 'Current zoom level: ' + ToString(Self.ZoomLevel), ELogLevel.SUCCESS);

  Result := Self.ZoomLevel;
  if InRange(Result, 30, 50) then exit;
  if Self.SetZoomLevel(RandomMode(35+Round(10*bhM.U), 30, 50)) then
  begin
    Result := Self.ZoomLevel;
    WriteLn GetDebugLn('Options', 'Zoom adjusted level: ' + ToString(Self.ZoomLevel), ELogLevel.SUCCESS);
  end;
end;

//override include
function TRSEntity._HoverHelper(action: TStringArray; attempts: Integer): Boolean; override;
var
  shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
  coordinates, tpa: TPointArray;
begin
  Result := Self._UpTextCheck(shouldExit, action);
  if shouldExit then Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(coordinates, atpa) then
    begin
      if Length(coordinates) <> Length(atpa) then
        raise 'SOMETHING WENT WRONG CACHING COORDINATES.';

      if attempt < 2 then i := 0
      else if Length(atpa) > (attempt - 2) then i := attempt - 2
      else i := Random(Low(atpa), High(atpa));

      tpa := atpa[i];
      Self.LastCoordinate := coordinates[i];

      Mouse.Move(tpa.RandomMean());

      if Self.UpText = [] then Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText) then Exit(True);

    if attempt <> (attempts - 1) then
      Continue;
    if not self.UpText.Contains('tack Shifter') then
      Minimap.CompassRadians := Minimap.CompassRadians + PI/3.6 * Random(-1,1);
  end;
end;

// =============================================================================
// PEST CONTROL METHODS
// =============================================================================

function TPestControl.GetReportValues(): TStringArray;
var
  playTime: UInt64;
  winsPerHour, ptsPerHour: Double;
  actionsStr, sleepInfo: String;
begin
  actionsStr := ToStr(Self.Actions);
  if Self.MaxActions <> 0 then
    actionsStr += '/' + ToStr(Self.MaxActions);

  if Antiban.Sleeps = [] then
    sleepInfo := 'No sleep'
  else
    sleepInfo := Antiban.TimeUntilSleep(Antiban.Sleeps.First, TIME_SHORT);

  playTime := Logger.TimeRunning.Elapsed;
  Self.GamesWon := Round(Self.PtsEarned/Self.PtsPerGame);
  winsPerHour := (Self.GamesWon / Max(1, playTime)) * ONE_HOUR;
  ptsPerHour := (Self.PtsEarned / Max(1, playTime)) * ONE_HOUR;


  Result := [
    GetTimeStamp(TIME_SHORT),
    Logger.TimeRunning.ElapsedFmt(TIME_SHORT),
    Antiban.TimeRunning.ElapsedFmt(TIME_SHORT),
    sleepInfo,
    ToStr(Self.GamesWon),
    FormatNumber(winsPerHour, 2),
    ToStr(Self.PtsEarned),
    FormatNumber(ptsPerHour, 2),
    actionsStr
  ];
end;

function TPestControl.InGame(): Boolean;
const
  sBox: Tbox = [11, 94, 49, 108];
begin
  result := Target.CountColor($CCCCCC, 0, sBox) > 35;
  if not result then Self.GameStarted := False;
end;

function TPestControl.ReadActivityBar(): Int32;
var
  greenCount: Int32;
  activBox: TBox = [368, 126, 508, 126];
begin
  result := -1;
  if not Self.InGame() then Exit;
  greenCount := Target.CountColor(PCData.OCR.ActivGreen, 0, activBox);
  Result := Round((greenCount / 141) * 100);
end;

function TPestControl.ReadKnightHP(): Int32;
begin
  Self.KnightHP := OCR.RecognizeNumber(PCData.OCR.KnightHP, RSFonts.PLAIN_11, [$00F800, $0000F8], 0);
  result := Self.KnightHP;
end;

function TPestControl.ReadPortalHP(): Int32;
begin
  Self.wHP := OCR.RecognizeNumber(PCData.OCR.W, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.eHP := OCR.RecognizeNumber(PCData.OCR.E, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.seHP := OCR.RecognizeNumber(PCData.OCR.SE, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.swHP := OCR.RecognizeNumber(PCData.OCR.SW, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.portalsHP := Self.wHP + Self.eHP + Self.seHP + Self.swHP;
  result := Self.portalsHP;
end;

procedure TPestControl.UpdatePortalShields();
const
  SHIELD_COLOR = $73737A;
  TOL = 1;
begin
  Self.ReadPortalHP();
  Self.WShielded := SimilarColors(Target.GetColor(Point(382, 95)), SHIELD_COLOR, TOL);
  Self.EShielded := SimilarColors(Target.GetColor(Point(420, 95)), SHIELD_COLOR, TOL);
  Self.SEShielded := SimilarColors(Target.GetColor(Point(457, 95)), SHIELD_COLOR, TOL);
  Self.SWShielded := SimilarColors(Target.GetColor(Point(495, 95)), SHIELD_COLOR, TOL);
  //writeln('W: ', Self.WShielded, '| E: ', Self.EShielded, '| SE: ', Self.SEShielded, '| SW: ', Self.SWShielded);
end;

function FmtTime(ms: Int64): String;
begin
  if ms < 60000 then
    Result := FormatFloat('0.0', ms / 1000) + 's'
  else if ms < 3600000 then
    Result := FormatMilliseconds(ms, 'm\m s\s')
  else
    Result := FormatMilliseconds(ms, 'h\h m\m');
end;

procedure TPestControl.UpdateAndDrawHUD(onBreak: Boolean = False; onSleep: Boolean = False; remaining: UInt64 = 0; Force: Boolean = False);
const
  REFRESH_RATE = 500;//milliseconds
  HUD_BG_COLOR = $181818;
  HUD_BORDER_COLOR = $404040;
  HUD_HEADER_TEXT = $3B9FFF;
  HUD_TEXT_COLOR = $F0F0F0;
  HUD_TEXT_MUTED = $A5A5A5;
  HUD_SEP_COLOR = $404040;
  HUD_ACTIVITY_RED = $0000F8;
  HUD_ACTIVITY_WARN = $57C8FF;
  HUD_ACTIVITY_GREEN = $47FF47;
  THRESHOLD_COLOR = $F0F0F0;
  TRACK_COLOR = $202020;
  PAD = 8;
  ROW_GAP = 11;
  SEP_MARGIN = 3;
  SEP_HEIGHT = 2;
var
  elapsed: UInt64;
  winsPerHour, ptsPerHour, xpPerHour: Double;
  abox, aboxBorder, headerBox, footerBox, barBox, barBorder, fillBox: TBox;
  xLabel, xVal, xRate, y, fullWidth, filledWidth, thrX, totalWidth: Int32;
  activityValue, runtimeStr, stateStr, winsStr, winsHrStr, ptsStr, ptsHrStr, portalStr: String;
  xpStr, xpHrStr, prayerStr, atkDelayStr, breakStr, sleepStr, maxActStr, maxTimeStr: String;
  breakRemain, sleepRemain: String;
  barColor, valueColor, actPercent, currentMinutes, xPos: Int32;

  function DrawSep(cy: Int32): Int32;
  begin
    Inc(cy, SEP_MARGIN);
    RSClient.Canvas.DrawColor := HUD_SEP_COLOR;
    RSClient.Canvas.DrawBoxFilled(Box(abox.X1 + 6, cy -1, abox.X2 - 6, cy + 1));
    Result := cy + SEP_HEIGHT + SEP_MARGIN;
  end;

  function DrawRow(const lbl, val: String; cy: Int32; const rate: String = ''): Int32;
  begin
    RSClient.Canvas.DrawColor := HUD_TEXT_MUTED;
    RSClient.Canvas.DrawText(lbl, Point(xLabel, cy));
    RSClient.Canvas.DrawColor := HUD_TEXT_COLOR;
    RSClient.Canvas.DrawText(val, Point(xVal, cy));
    if rate <> '' then
      RSClient.Canvas.DrawText(rate, Point(xRate, cy));
    Result := cy + ROW_GAP;
  end;

begin
  if Self.UserDisableHUD then Exit;
  if ((Time - Self.HUDLastUpdate) < REFRESH_RATE) and
    not Force then Exit;
  Self.HUDLastUpdate := Time;

  Self.PtsEarned := Self.PtsTotal - Self.PtsStart;
  Self.GamesWon := Round(Self.PtsEarned / Self.PtsPerGame);
  elapsed := Logger.TimeRunning.Elapsed;
  winsPerHour := (Self.GamesWon / Max(1, elapsed)) * ONE_HOUR;
  ptsPerHour := (Self.PtsEarned / Max(1, elapsed)) * ONE_HOUR;
  xpPerHour := (XPBar.TotalEarnedXP() / Max(1, elapsed)) * ONE_HOUR;

  runtimeStr := FormatMilliseconds(GetTimeRunning, TIME_SHORT);
  stateStr := ToStr(Self.State).After('EPestState.');

  breakRemain := '';
  sleepRemain := '';
  if onBreak then
  begin
    breakStr := FormatMilliseconds(remaining, TIME_SHORT);
    stateStr := 'ON_BREAK';
    breakRemain := 'remaining';
  end else
  begin
    breakStr := 'None';
    if Length(Antiban.Breaks) > 0 then
      breakStr := Antiban.TimeUntilBreak(Antiban.Breaks[0], TIME_SHORT);
  end;
  if onSleep then
  begin
    sleepStr := FormatMilliseconds(remaining, TIME_SHORT);
    stateStr := 'ON_SLEEP';
    sleepRemain := 'remaining';
  end else
  begin
    sleepStr := 'None';
    if Length(Antiban.Sleeps) > 0 then
      sleepStr := Antiban.TimeUntilSleep(Antiban.Sleeps[0], TIME_SHORT);
  end;

  winsStr := ToStr(Self.GamesWon);
  winsHrStr := FormatNumber(winsPerHour, 1);
  ptsStr := ToStr(Self.PtsEarned);
  ptsHrStr := FormatNumber(ptsPerHour, 0);
  xpStr := FormatNumber(XPBar.TotalEarnedXP(), 1);
  xpHrStr := FormatNumber(xpPerHour, 0);

  if (Self.LastXPTime + Self.XPAttkDelay) > Time then
    atkDelayStr := FormatFloat('#,##0', Round(Self.XPAttkDelay)) + 'ms'
  else
    atkDelayStr := FormatFloat('#,##0', Round(Self.NextAttkDelay)) + 'ms';

  prayerStr := 'N/A';
  if Self.UserQuickPrayer then
    prayerStr := FormatFloat('#,##0', Round(Self.PrayerEnableTime)) + 'ms';

  maxActStr := '';
  if Self.MaxActions > 0 then
    maxActStr := ToStr(Self.Actions) + '/' + ToStr(Self.MaxActions);

  maxTimeStr := '';
  if Self.MaxTime > 0 then
  begin
    currentMinutes := GetTimeRunning div 60000;
    maxTimeStr := ToStr(currentMinutes) + '/' + ToStr(Self.MaxTime div 60000);
  end;

  actPercent := Self.ReadActivityBar();
  if actPercent < 0 then
  begin
    activityValue := 'N/A';
    valueColor := HUD_TEXT_MUTED;
    barColor := HUD_ACTIVITY_WARN;
  end
  else
  begin
    activityValue := ToStr(actPercent)+'%';
    if actPercent < 30 then
    begin
      valueColor := HUD_ACTIVITY_RED;
      barColor := HUD_ACTIVITY_RED;
    end
    else if actPercent < Self.ActivityThresh then
    begin
      valueColor := HUD_ACTIVITY_WARN;
      barColor := HUD_ACTIVITY_WARN;
    end
    else
    begin
      valueColor := HUD_ACTIVITY_GREEN;
      barColor := HUD_ACTIVITY_GREEN;
    end;
  end;

  abox := Box(552, 206, 731, 463);
  aboxBorder := abox.Expand(2);
  headerBox := Box(abox.X1, abox.Y1, abox.X2, abox.Y1 + 24);
  footerBox := Box(abox.X1, abox.Y2 - 18, abox.X2, abox.Y2);
  xLabel := abox.X1 + PAD;
  xVal := abox.X1 + 55;
  xRate := abox.X2 - 55;

  with RSClient.Canvas do
  begin
    BeginUpdate();

    DrawColor := HUD_BORDER_COLOR;
    DrawBoxFilled(aboxBorder);
    DrawColor := HUD_BG_COLOR;
    DrawBoxFilled(abox);
    DrawBoxFilled(headerBox);
    DrawBoxFilled(footerBox);

    FontName := 'Segoe UI';
    FontAntialiasing := True;
    FontSize := 16;
    DrawColor := HUD_HEADER_TEXT;
    DrawText('Pest Control LITE', Point(headerBox.X1 + PAD, headerBox.Y1 + 4));

    barBox := Box(abox.X1 + PAD, headerBox.Y2, abox.X1 + PAD +
      TextWidth('Pest Control LITE'), headerBox.Y2 + 8);
    barBorder := barBox.Expand(2);

    DrawColor := TRACK_COLOR;
    DrawBoxFilled(barBox);
    fullWidth := barBox.X2 - barBox.X1;
    filledWidth := (fullWidth * EnsureRange(actPercent, 0, 100)) div 100;
    if filledWidth > 0 then
    begin
      fillBox := barBox;
      fillBox.X2 := fillBox.X1 + filledWidth;
      DrawColor := barColor;
      DrawBoxFilled(fillBox);
      DrawBox(barBorder);
    end;
    thrX := barBox.X1 + (fullWidth * EnsureRange(Self.ActivityThresh, 0, 100)) div 100;
    DrawColor := THRESHOLD_COLOR;
    DrawBoxFilled(Box(thrX, barBox.Y1, thrX + 1, barBox.Y2));

    FontSize := 16;
    DrawColor := valueColor;
    DrawText(activityValue, Point(barBox.X2 + 4, barBox.Y1-2));

    y := barBox.Y2 +4;
    y := DrawSep(y);
    FontSize := 12;
    y := DrawRow('Runtime', runtimeStr, y, 'F '+ FormatFloat('##0.0', Self.F.Lvl*100)+'%');
    if stateStr.Contains('DEFEND') then
      y := DrawRow('State', stateStr, y, FmtTime(Time-Self.GameStart))
    else
      y := DrawRow('State', stateStr, y, FmtTime(Time-Self.StateT));
    y := DrawRow('Break', breakStr, y, breakRemain);
    y := DrawRow('Sleep', sleepStr, y, sleepRemain);
    y := DrawSep(y);
    y := DrawRow('Wins', winsStr, y, winsHrStr + '/hr');
    y := DrawRow('Points', ptsStr, y, ptsHrStr + '/hr');
    y := DrawRow('XP', xpStr, y, xpHrStr + '/hr');
    y := DrawSep(y);
    y := DrawRow('Prayer', prayerStr, y);
    DrawColor := HUD_TEXT_COLOR;
    if not onSleep and not onBreak then
      DrawText('Z: ' + ToStr(Options.ZoomLevel), Point(xRate, y - ROW_GAP));
    y := DrawRow('Attack', atkDelayStr, y);
    if Self.LeaveGameCount > 0 then
      DrawText('L''s: ' + ToStr(Self.LeaveGameCount), Point(xRate, y - ROW_GAP));
    y := DrawSep(y);
    y := DrawRow('Total', 'Points', y, FormatFloat('#,##0', Self.PtsTotal));
    y := DrawRow('Total', ToStr(Self.State).After('.'), y, FmtTime(Self.StateTimer.Times[Self.State]+ (Time - Self.StateT)));
    if Self.InGame() then
      y := DrawRow('Choice', ToStr(Self.AttackChoice).After('.'), y, IntToStr(Self.AttackIndex));
    if maxActStr <> '' then y := DrawRow('Max', 'Actions', y, maxActStr);
    if maxTimeStr <> '' then y := DrawRow('Max', 'Time', y, maxTimeStr);

    if Self.InGame() then
    begin
      Self.UpdatePortalShields();

      //FontSize := 10;

      // Calculate total width for centering
      totalWidth := TextWidth('(W) 999|') + TextWidth('(E) 999|') +
                    TextWidth('(SE)999|') + TextWidth('(SW)999');
      xPos := (abox.X1 + abox.X2) div 2 - totalWidth div 2;

      // W portal
      DrawColor := 16711935;
      if Self.WShielded then DrawText('(W)', Point(xPos, y+1))
      else DrawText('W:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(W) '));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.wHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 16711935;
      DrawText('|', Point(xPos, y+1));
      Inc(xPos, TextWidth('|'));

      // E portal
      DrawColor := 16737894;
      if Self.EShielded then DrawText('(E)', Point(xPos, y+1))
      else DrawText('E:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(E) '));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.eHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 16737894;
      DrawText('|', Point(xPos, y+1));
      Inc(xPos, TextWidth('|'));

      // SE portal
      DrawColor := 65535;
      if Self.SEShielded then DrawText('(SE)', Point(xPos, y+1))
      else DrawText('SE:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(SE)'));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.seHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 65535;
      DrawText('|', Point(xPos, y+1));
      Inc(xPos, TextWidth('|'));

      // SW portal
      DrawColor := 3355647;
      if Self.SWShielded then DrawText('(SW)', Point(xPos, y+1))
      else DrawText('SW:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(SW)'));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.swHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 3355647;
      DrawText('|', Point(xPos, y+1));

      FontSize := 12;
      y += ROW_GAP+2;
    end;

    DrawColor := HUD_SEP_COLOR;
    DrawBoxFilled(Box(abox.X1 + 6, footerBox.Y1, abox.X2 - 6, footerBox.Y1 + SEP_HEIGHT - 1));
    FontSize := 12;
    DrawColor := HUD_HEADER_TEXT;
    DrawText('Author: footballjds', Point(abox.X1 + PAD, footerBox.Y1 + 5));

    EndUpdate();
  end;
end;

function TPestControl.InBoat(): Boolean;
const
  ptsBox: TBox = [7, 62, 77, 80];
begin
  result := (target.CountColor(16777113, 0, ptsBox) = 140);
end;

procedure TPestControl.ReadPoints();
var
  blueNumber: Int32;
begin
  if not Self.InBoat() then Exit;
  blueNumber := OCR.RecognizeNumber(PCData.OCR.PointsBox, RSFonts.PLAIN_12, [16777113], 0);
  if self.PtsStart < 0 then
    self.PtsStart := blueNumber;
  self.PtsTotal := blueNumber;
  self.PtsEarned := self.PtsTotal-self.PtsStart;
end;

function TPestControl.PlatformCenter(var tpOut: TPoint): Boolean;
var
  platPts: TPointArray;
begin
  platPts := Target.FindColor(2782859, 0, Minimap.Bounds);
  if platPts.Length < 1300 then Exit;
  Result := true;
  tpOut := platPts.Mean();
end;

function TPestControl.AtKnight(): Boolean;
var
  platMean: TPoint;
begin
  if not Self.PlatformCenter(platMean) then Exit;
  Result := Distance(Minimap.Center, platMean)
          < 13 + 3 * bhM.U + Random(-1, 1);
end;

function TPestControl.AtBoatPlank(pos: TPoint): Boolean;
begin
  Result := Distance(pos, Self.AtPlank) < 5+5*bhM.U;
end;

procedure TPestControl.UpdateAttkDelay();
var
  candidate: Double;
begin
  candidate := ExpoGaussRT(Self.Tempo.LowMean, Self.RT[0].U, Self.RT[1].U);
  if Self.NextAttkDelay > 0 then
  begin
    if Random() < (0.10 + 0.05 * Self.RT[2].U) then
      Self.NextAttkDelay := candidate
    else
      Self.NextAttkDelay := Self.Tempo.LowStick * Self.NextAttkDelay + (1.0 - Self.Tempo.LowStick) * candidate;
  end else
    Self.NextAttkDelay := candidate;
  Logger.Info('UpdateAttkDelay: %.4f', [Self.NextAttkDelay]);
end;

procedure TPestControl.UpdateXPAttkDelay();
var
  candidate: Double;
begin
  candidate := ExpoGaussRT(Self.Tempo.XPMean, Self.RT[0].U, Self.RT[1].U);

  if Self.XPAttkDelay > 0 then
  begin
    if Random() < (0.10 + 0.05 * Self.RT[2].U) then
      Self.XPAttkDelay := candidate
    else
      Self.XPAttkDelay := Self.Tempo.XPStick * Self.XPAttkDelay + (1.0 - Self.Tempo.XPStick) * candidate;
  end else
    Self.XPAttkDelay := candidate;
  Logger.Info('New XP AttackDelay: %.4f', [Self.XPAttkDelay]);
end;

procedure TPestControl.UpdateActiveThresh();
begin
  Self.ActivityThresh := Self.UserActiveThreshold;
  Self.ActivityThresh := EnsureRange(Self.ActivityThresh, 50, 100);
end;

procedure TPestControl.UpdateXP();
var
  nXP: UInt64;
begin
  nXP := XPBar.Read;
  if nXP > Self.LastXP then
  begin
    if (Time-Self.LastXPTime) > Self.XPAttkDelay then
      Self.UpdateXPAttkDelay();
    Self.LastXP := nXP;
    Self.LastXPTime := Time;
  end;
end;

procedure TFatigue.Update();
var
  dt, dtMin, sessionMin: Double;
  noise, driftFactor, effectiveRate, onsetFactor: Double;
  exp2theta, ouStdDev: Double;
begin
  if PestControl.UserDisableFatigue then Exit;
  if PestControl.State in [EPestState.BREAK, EPestState.SLEEP] then Exit;

  dt := Time - Self.Last;
  dtMin := dt / 60000.0;
  sessionMin := (Time - Self.Start) / 60000.0;

  // Sigmoid ramp with per-session steepness
  onsetFactor := 1.0 / (1.0 + Exp(-Self.OnsetSteep * (sessionMin - Self.OnsetTime)));

  // Exact discrete OU process
  exp2theta := Exp(-2.0 * Self.Revert * dtMin);
  ouStdDev := Self.Drift * Sqrt((1.0 - exp2theta) / (2.0 * Self.Revert));
  noise := GaussRand(0, ouStdDev);
  Self.DriftCur := Self.DriftCur * Exp(-Self.Revert * dtMin) + noise;

  // Prevent drift from making rate negative
  driftFactor := Min(Max(0.3, 1.0 + Self.DriftCur), 1.7);

  // Apply onset ramp to effective rate
  effectiveRate := Self.Rate * driftFactor * onsetFactor;

  // Exact exponential approach to saturation
  Self.Lvl := 1.0 - (1.0 - Self.Lvl) * Exp(-effectiveRate * dtMin);

  Self.Last := Time;
end;

function TAntiban.TaskDue(): Boolean;
var
  i: Int32;
  activeTasks: PAntibanTaskArray;
begin
  if Self.DoingAntiban then
    Exit(False);

  activeTasks := Self.GetActiveTasks();
  for i := 0 to High(activeTasks) do
    if activeTasks[i]^.Countdown.Remaining = 0 then
      Exit(True);

  Result := False;
end;


function TAntiban.BreakDue(): Boolean;
var
  i: Int32;
  t: UInt64;
begin
  if Self.DoingAntiban then
    Exit(False);

  t := GetTimeRunning();
  for i := 0 to High(Self.Breaks) do
    if t > Self.Breaks[i].Next then
      Exit(True);

  Result := False;
end;


function TAntiban.SleepDue(): Boolean;
var
  i: Int32;
  t: UInt64;
begin
  if Self.DoingAntiban then
    Exit(False);

  t := GetTimeRunning();
  for i := 0 to High(Self.Sleeps) do
    if t > Self.Sleeps[i].Next then
      Exit(True);

  Result := False;
end;


function TPestControl.GetState(): EPestState;
var
  tmpP: TPoint;
begin
  if Activity.IsFinished then
    Exit(EPestState.NO_ACTIVITY);

  if (Self.MaxActions > 0) and (Self.Actions >= Self.MaxActions) then
    Exit(EPestState.MAX_ACTIONS);

  if (Self.MaxTime > 0) and (GetTimeRunning() >= Self.MaxTime) then
    Exit(EPestState.MAX_TIME);

  if not RSClient.IsLoggedIn() then
    Exit(EPestState.LOGIN);

  if Self.CombatLevel < 40 then
    Exit(EPestState.CMBT_LVL);

  if Antiban.TaskDue() then
    Exit(EPestState.ANTIBAN);

  if Antiban.BreakDue() then
    if not Self.InGame() then
      Exit(EPestState.BREAK);

  if Antiban.SleepDue() then
    if not Self.InGame() then
      Exit(EPestState.SLEEP);

  if Self.InBoat() then Exit(EPestState.IN_BOAT);

  if Self.InGame() then
  begin
    if not Self.UserDisableLeaveGame and not Self.Flag.NoLeave and (Self.ReadPortalHP >= 50+199*bhM.U)
      and (Self.ReadActivityBar() < 1) then
        Exit(EPestState.EXIT_GAME);
    if Self.AtKnight() then Exit(EPestState.DEFEND);
    Exit(EPestState.WALK_MID);
  end;
  tmpP := Map.Position();
  if Self.AtBoatPlank(tmpP) then
    Exit(EPestState.AT_PLANK);

  result := EPestState.UNKNOWN;
end;

function TPestControl.PrayerSample(): Double;
var
  shape, scale: Double;
begin
  // Shape: How decision probability builds over time
  shape := Random(1.4, 1.5) + 1 * Self.P[1].U;

  // Scale: Typical timing
  scale := 5500 + GaussRand(400,125) + 6000 * Self.P[0].U;

  // Session variance: This game's randomness
  scale := scale * (0.8 + (0.4 + Self.P[2].U/5) * Random());

  // Sample from Weibull
  Result := WeibullEx(shape, scale);

  Logger.Info('PrayerSample: %.2fs (k=%.2f, λ=%.0fms)',
    [Result / 1000, shape, scale]);
end;

procedure TPestControl.UpdateCmbtLvl();
const
  cbBox: TBox = [661, 229, 682, 244];
begin
  if InRange(Self.UserCombatLevel, 40, 126) then
    Self.CombatLevel := Self.UserCombatLevel
  else
    if GameTabs.Open(ERSGameTab.COMBAT) then
    begin
      Sleep(ExGaussInt(Self.bRT));
      Self.CombatLevel := OCR.RecognizeNumber(cbBox.Expand(3), RSFonts.PLAIN_11, [2070783], 0);
    end;
  Logger.Info('Combat Level: %d', [Self.CombatLevel]);
  XPBar.Read;
  if Self.CombatLevel >= 100 then
  begin
    Self.BoatBox := PCData.Vet.BoatBox;
    Self.AtPlank := PCData.Vet.AtPlank;
    Self.CrossPlank := PCData.Vet.PlankObj;

    Self.Shifter.Finder.ColorClusters += [[
      [$33C1E7, 4.010, EColorSpace.HSL, [1.562, 0.510, 0.930]],
      [$223B53, 0.882, EColorSpace.HSL, [1.421, 1.254, 0.326]],
      3
    ]];
    Self.Shifter.Finder.ColorClusters += [[
      [$B0BBB7, 1.153, EColorSpace.HSL, [0.506, 1.932, 0.563]],
      [$8E848A, 0.757, EColorSpace.HSL, [0.911, 1.517, 0.574]],
      3
    ]];
  end
  else if Self.CombatLevel >= 70 then
  begin
    Self.BoatBox := PCData.Inter.BoatBox;
    Self.AtPlank := PCData.Inter.AtPlank;
    Self.CrossPlank := PCData.Inter.PlankObj;

    //gold and brown shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$243E56, 1.203, EColorSpace.HSL, [1.022, 1.336, 0.644]],
      [$23BEE5, 4.008, EColorSpace.HSL, [1.359, 0.417, 1.226]],
      3
    ]];

    //red and black shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$505061, 1.477, EColorSpace.HSV, [0.737, 1.700, 0.564]],
      [$2133BF, 0.717, EColorSpace.HSL, [1.267, 1.196, 0.539]],
      3
    ]];

    //green shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$137C71, 1.936, EColorSpace.RGB, [0.534, 0.511, 1.957]],
      [$3C5624, 0.965, EColorSpace.HSL, [1.251, 1.181, 0.570]],
      3
    ]];
  end
  else if Self.CombatLevel >= 40 then
  begin
    Self.BoatBox := PCData.Nov.BoatBox;
    Self.AtPlank := PCData.Nov.AtPlank;
    Self.CrossPlank := PCData.Nov.PlankObj;

    //red shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$2234C2, 0.738, EColorSpace.HSL, [1.289, 1.289, 0.424]],
      [$242B76, 0.689, EColorSpace.HSL, [1.510, 0.899, 0.593]],
      3
    ]];
    //green shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$137C71, 1.936, EColorSpace.RGB, [0.534, 0.511, 1.957]],
      [$3C5624, 0.965, EColorSpace.HSL, [1.251, 1.181, 0.570]],
      3
    ]];
  end
  else
    TerminateScript('[INIT] Combat level too low: ' + ToStr(Self.CombatLevel));

  Self.Gangplank := TRSObject.Create(@Map.Walker, [1, 1, 1], [Self.CrossPlank], ['Cross Gang']);
end;

procedure TPestControl.MoveInBoat();
const
  BOAT_BEHAV_SOUTH     = 0.53;
  BOAT_BEHAV_OPPOSITE  = 0.70;
  BOAT_BEHAV_AWAYPLANK = 0.85;
var
  boatArea: TBox;
  current, target, mean: TPoint;
  destMS: TQuad;
  weight, bias: Single;
  primary, behavior: Int32;
begin
  if Self.Flag.NoBoatMove then Exit;
  if Time < (Self.LastBoatMove + Self.BoatMoveDelay) then Exit;
  if not Self.InBoat() then Exit;

  boatArea := Self.BoatBox.Expand(Random(-4, 6 - Round(4 * bhM.U)));
  current := Map.Position();

  if bhM.U < BOAT_BEHAV_SOUTH then primary := 0
  else if bhM.U < BOAT_BEHAV_OPPOSITE then primary := 1
  else if bhM.U < BOAT_BEHAV_AWAYPLANK then primary := 2
  else primary := 3;

  if Random() < 0.60 + 0.35 * bhM.U then
    behavior := primary
  else
    behavior := Biometrics.RandomModeInteger(primary, 0, 3);

  case behavior of
    0: mean := [boatArea.Center.X, boatArea.Y2 - boatArea.Height div 4];
    1: mean := [boatArea.X2 - (current.X - boatArea.X1), boatArea.Y2 - (current.Y - boatArea.Y1)];
    2: begin
         mean.X := EnsureRange(boatArea.X2 - (Self.AtPlank.X - boatArea.X1), boatArea.X1, boatArea.X2);
         mean.Y := EnsureRange(boatArea.Y2 - (Self.AtPlank.Y - boatArea.Y1), boatArea.Y1, boatArea.Y2);
       end;
    else mean := boatArea.RandomPoint();
  end;

  weight := 2 + 8 * bhM.U;      // 2-10
  bias := 0.5 + 1.0 * _bhM.U;   // 0.5-1.5

  target := boatArea.RandomWeightedPoint(mean, weight, bias);
  if current.DistanceTo(target) < 4 + 3 * bhM.U then
    target := boatArea.RandomWeightedPoint(
      [boatArea.X1 + boatArea.X2 - mean.X, boatArea.Y1 + boatArea.Y2 - mean.Y],
      weight * 0.5, bias * 1.5);

  destMS := Map.Walker.GetQuadMS(current, target, [1], Minimap.CompassRadians);
  if not Mainscreen.Bounds.ContainsQuad(destMS) then
    Exit;
  if randomBoolean(0.1+0.8*bhm.U) and RandomBoolean(0.03348) then
    Mouse.Move(Mainscreen.Bounds, True, EMouseDistribution.GAUSS)
  else
    Mouse.Move(destMS, True, EMouseDistribution.GAUSS);

  Sleep(ExGaussInt(Self.bRT * 0.8));
  if not Self.InBoat() then Exit;

  if MainScreen.IsUpText('Walk here') then
    Mouse.Click(EMouseButton.LEFT)
  else if ChooseOption.Open() then
    ChooseOption.Select('Walk here');

  Self.LastBoatMove := Time;
  Self.BoatMoveDelay := LogNormal(Self.bRT * 100 + Random(75, 100) * bhM.U, 0.27 + 0.1 * bhM.U);
  Logger.Info('BoatMoveDelay: %.4f', [Self.BoatMoveDelay]);
end;

procedure TPestControl.WhileInBoat();
begin
  if not Self.UserDisableMoveInBoat then Self.MoveInBoat();
  Sleep(ExGaussInt(Self.bRT));
end;

//function from include, I am not author
function TRSChat.ReadPointsOption(): String;
var
  option: TRSChatOption;
begin
  for option in Self.GetOptions([$000080]) do
  begin
    if Result <> '' then Result += LINE_SEP;
    Result += option.Text;
  end;
  result := ToStr(result.ExtractInteger());
end;

procedure TPestControl.SetPerGame();
begin
  Self.Flag.NoPray := RandomBoolean(0.001347 + 0.026438 * Self.Flag.Choices[0].U);
  Self.Flag.NoLeave := RandomBoolean(0.00173 + 0.09573 * Self.Flag.Choices[1].U);
  Self.Flag.NoBoatMove := (Self.Flag.Choices[2].U > 0.873) and (Random() < 0.05 + 0.05* Self.Flag.Choices[3].U);
  Self.Flag.DelayBoatMove := (Self.Flag.Choices[2].U < 0.973) and (Random() < 0.15 + 0.55* Self.Flag.Choices[4].U);

  Logger.Info('Self.Flag.NoPray: %s', [toStr(Self.Flag.NoPray)]);
  Logger.Info('Self.Flag.NoLeave: %s', [toStr(Self.Flag.NoLeave)]);
  Logger.Info('Self.Flag.NoBoatMove: %s', [toStr(Self.Flag.NoBoatMove)]);
  Logger.Info('Self.Flag.DelayBoatMove: %s', [toStr(Self.Flag.DelayBoatMove)]);

  Self.PrayerEnableTime := Self.PrayerSample();
  Logger.Info('Self.PrayerEnableTime: %.4f', [Self.PrayerEnableTime]);
  if Self.Flag.DelayBoatMove then
  begin
    Self.LastBoatMove := Time;
    Self.BoatMoveDelay := ExGaussInt(Self.bRT*Random(0.537, 5+5*bhM.U));
    Logger.Info('BoatMoveDelay: %.4f', [Self.BoatMoveDelay]);
  end;
  Self.ReadPoints();
  Activity.Restart();
  Self.Actions+=1;
  Self.ActivityThresh := EnsureRange(Self.UserActiveThreshold + Round(GaussRand(0, 2.5)), 50, 100);
end;

procedure TPestControl.EnterBoatFailsafe();
begin

end;

procedure TPestControl.EnterBoat();
begin
  Sleep(ExGaussInt(Self.bRT * 2.9));
  if Chat.IsTitle('~ Warning ~') then
    TerminateScript('Too many points '+Chat.ReadPointsOption());
  try
    if Self.Gangplank.Click(True, 1 + Round(3*bhM.U)) then
      if SleepUntil(Self.InBoat, 50, Round(GaussRand(3000, 200))) then
      begin
        Self.SetPerGame();
        Sleep(ExGaussInt(Self.bRT * 3.9));
        if not InRange(Options.GetZoomLevel(True), 30, 50) then
          if Options.SetZoomLevel(RandomMode(35+Round(10*bhM.U), 30, 50)) then
            WriteLn GetDebugLn('Options', 'Zoom adjusted level: ' + ToString(Options.ZoomLevel), ELogLevel.SUCCESS);
        Exit;
      end;
  except Logger.Error('Exception in EnterBoat: %s', [GetExceptionMessage]); end;
end;

procedure TPestControl.EnablePrayerCheck();
begin
  if not (Self.Flag.NoPray) and Self.UserQuickPrayer and Self.GameStarted
    and Self.InGame() and (Time > (Self.GameStart + Self.PrayerEnableTime)) then
    if not Minimap.PrayerEnabled then
      if Minimap.EnablePrayer() then
      begin
        if Biometrics.RandomBoolean() then
          Sleep(ExGaussInt(Self.bRT*(1.1+random(0.0, 2.1))));
        if Biometrics.RandomBoolean(0.23) then
          Mouse.Move(Mainscreen.Bounds, True);
      end;
end;

procedure TPestControl.WalkToDefend();
var
  uniqueMiddle, midP, msP: TPoint;
begin
  Sleep(ExGaussInt(Self.bRT * 1.7));
  if not Self.InGame() then Exit;
  if not Self.GameStarted then
  begin
    Self.GameStarted := True;
    Self.GameStart := Time;
  end;
  Self.EnablePrayerCheck();
  if Self.PlatformCenter(midP) then
  begin
    uniqueMiddle := midP;
    uniqueMiddle.X += Biometrics.RandomModeInteger(9, -9, 9);
    uniqueMiddle.Y += Biometrics.RandomModeInteger(9, -9, 9);
    msP := Minimap.Point2MS(uniqueMiddle, Minimap.CompassRadians);
    if Mainscreen.Bounds.Contains(msP) then
    begin
      msP := [EnsureRange(msP.X + Random(-10, 10), MainScreen.Bounds.X1,
         MainScreen.Bounds.X2), EnsureRange(msP.Y + Random(-10, 10),
         MainScreen.Bounds.Y1, MainScreen.Bounds.Y2)];
      if Mainscreen.Bounds.Contains(msP) then
      begin
        Mouse.Click(msP, EMouseButton.LEFT);
        if RandomBoolean(0.63+30*bhM.U) and (_bhM.U < 0.933) then
        begin
          Minimap.WaitMoving(Round(Self.bRT*Random(50, 100)));
          Sleep(ExGaussInt(Self.bRT*RandomLeft(0.7, 3.1)));
        end else
          Sleep(ExGaussInt(Self.bRT*GaussRand(10, 2.5)));
        Exit;
      end;
    end;
  end;
  uniqueMiddle := PCData.Knight;
  uniqueMiddle.X += Biometrics.RandomModeInteger(5, -5, 5);
  uniqueMiddle.Y += Biometrics.RandomModeInteger(5, -5, 5);
  try
    Logger.Info('Walk to middle: ' + ToStr(Map.Walker.WebWalk(uniqueMiddle, 7+Round(5*bhM.U), 0.2+0.4*_bhM.U)));
  except Logger.Error('WalkToDefend exception: %s', [GetExceptionMessage]); end;
end;

procedure DebugShifterClusters(constref Shifter: TRSEntity);
var
  img: TImage;
  atpa: T2DPointArray;
  coordinates: TPointArray;
  i, totalPixels: Integer;
  avgSize, minSize, maxSize: Integer;
begin
  img := Target.GetImage();

  // Try to find shifters
  if Shifter.Find(coordinates, atpa) then
  begin
    WriteLn('=== SHIFTER DETECTION DEBUG ===');
    WriteLn('Found ', Length(atpa), ' potential shifter(s)');
    WriteLn();

    minSize := High(Integer);
    maxSize := 0;
    totalPixels := 0;

    // Analyze each detected cluster
    for i := 0 to High(atpa) do
    begin
      WriteLn('Cluster #', i + 1, ':');
      WriteLn('  Coordinate: ', coordinates[i]);
      WriteLn('  Pixel count: ', Length(atpa[i]));
      WriteLn('  Bounds: ', atpa[i].Bounds());
      WriteLn();

      totalPixels += Length(atpa[i]);
      if Length(atpa[i]) < minSize then minSize := Length(atpa[i]);
      if Length(atpa[i]) > maxSize then maxSize := Length(atpa[i]);

      // Draw on image
      img.DrawColor := $00FF00;
      img.DrawTPA(atpa[i]);
      img.DrawBox(atpa[i].Bounds());
      img.DrawText('Cluster ' + ToStr(i+1) + ': ' + ToStr(Length(atpa[i])) + 'px',
                   atpa[i].Bounds().TopLeft);
    end;

    if Length(atpa) > 0 then
    begin
      avgSize := totalPixels div Length(atpa);
      WriteLn('=== STATISTICS ===');
      WriteLn('Average cluster size: ', avgSize, ' pixels');
      WriteLn('Min cluster size: ', minSize, ' pixels');
      WriteLn('Max cluster size: ', maxSize, ' pixels');
      WriteLn();
      WriteLn('RECOMMENDATION:');
      if minSize > 50 then
        WriteLn('  Current ColorCluster "3" parameter might be too low.')
      else if maxSize < 20 then
        WriteLn('  Detection might be too sensitive. Consider stricter tolerances.')
      else
        WriteLn('  Cluster sizes look reasonable (', minSize, '-', maxSize, ' pixels)');
    end;
  end else
  begin
    WriteLn('NO SHIFTERS DETECTED');
    WriteLn('Check:');
    WriteLn('  1. Are you near shifters?');
    WriteLn('  2. Are colors correct for this boat tier?');
    WriteLn('  3. Try uncommenting Transformer settings');
  end;

  // Draw entity info
  img.DrawColor := $00FFFF;
  img.DrawText('ColorClusters: ' + ToStr(Length(Shifter.Finder.ColorClusters)), [10, 30]);
  img.DrawText('Transformer.Distance: ' + ToStr(Shifter.Finder.Transformer.Distance), [10, 50]);
  img.DrawText('Transformer.ShortSide.Min: ' + ToStr(Shifter.Finder.Transformer.ShortSide.Min), [10, 70]);

  img.Show();
end;

function TPestControl.MapPos: TPoint;
var
  radians: Single;
  platMM: TPoint;
begin
  if not Self.PlatformCenter(platMM) then
    Exit(Map.Position());
  radians := Minimap.CompassRadians;
  Result := Self.Center + Minimap.Center - platMM.Rotate(-radians, Minimap.Center);
end;

function TPestControl.FindShifters(out atpa: T2DPointArray): Boolean;
var
  coords: TPointArray;
  bounds: TPolygonArray;
begin
  Result := Self.Shifter.FindEx(Self.MapPos, bounds, coords, atpa);
end;

function TPestControl.ChooseStrategy(): EAttackChoice;
var
  r: Double;
begin
  if (Random() < Self.AttackStick) then
    Exit(Self.AttackChoice);

  r := Random();
  if r < Self.AttackWeights[0] then
    Result := EAttackChoice.Self
  else if r < (Self.AttackWeights[0] + Self.AttackWeights[1]) then
    Result := EAttackChoice.Knight
  else
    Result := EAttackChoice.Rand;
end;

procedure TPestControl.SortByStrategy(strategy: EAttackChoice; var atpa: T2DPointArray);
var
  platMM, knightMS: TPoint;
begin
  case strategy of
    EAttackChoice.Self:
      atpa := atpa.SortFrom(MainScreen.PlayerBox.Center);

    EAttackChoice.Knight:
      begin
        if Self.PlatformCenter(platMM) then
          knightMS := Minimap.Point2MS(platMM, Minimap.CompassRadians)
        else
          knightMS := MainScreen.Bounds.Center;
        atpa := atpa.SortFrom(knightMS);
      end;

    EAttackChoice.Rand:
      ; // No sorting needed
  end;
end;

function TPestControl.PickIndex(len: Int32; strategy: EAttackChoice): Int32;
var
  lambda, alpha, cumulative, r: Double;
  probs: TDoubleArray;
  i: Int32;
begin
  if len = 1 then Exit(0);
  if strategy = EAttackChoice.Rand then Exit(Random(len));

  SetLength(probs, len);

  // Calculate raw probabilities
  if Self.attkC[5].U < 0.5 then
  begin
    lambda := 0.3 + 1.7 * Self.attkC[6].U;
    for i := 0 to len - 1 do
      probs[i] := Exp(-lambda * i);
  end
  else
  begin
    alpha := 0.5 + 1.5 * Self.attkC[6].U;
    for i := 0 to len - 1 do
      probs[i] := 1.0 / Power(i + 1, alpha);
  end;

  // Normalize
  cumulative := 0;
  for i := 0 to len - 1 do
    cumulative += probs[i];
  for i := 0 to len - 1 do
    probs[i] := probs[i] / cumulative;

  // Sample using cumulative distribution
  r := Random();
  cumulative := 0;
  for i := 0 to len - 1 do
  begin
    cumulative += probs[i];
    if r < cumulative then
      Exit(i);
  end;

  Result := len - 1;
end;

function TPestControl.AttackShifter(debug: Boolean = False): Boolean;
var
  atpa: T2DPointArray;
  strategy: EAttackChoice;
  idx: Int32;
begin
  if debug then DebugShifterClusters(Self.Shifter);

  try
    if not Self.FindShifters(atpa) then Exit(False);

    strategy := Self.ChooseStrategy();
    Self.SortByStrategy(strategy, atpa);
    idx := Self.PickIndex(Length(atpa), strategy);

    Mouse.Move(atpa[idx].RandomMean());

    if MainScreen.IsUpText(Self.Shifter.UpText) then
      Result := Biometrics.RedClick(EMouseButton.LEFT);

    if Result then
    begin
      Self.AttackChoice := strategy;
      Self.AttackIndex := idx;
    end;

  except
    Logger.Error('AttackShifter exception: %s', [GetExceptionMessage]);
  end;
end;

//function TPestControl.AttackShifter(debug: Boolean = False): Boolean;
//begin
//  if debug then DebugShifterClusters(Self.Shifter);
//  try
//    Result := Self.Shifter.Click(True, 1+Round(2*bhM.U));
//  except Logger.Error('AttackShifter exception: %s', [GetExceptionMessage]); end;
//end;

procedure TPestControl.DefendKnight();
begin
  Sleep(ExGaussInt(Self.bRT*0.8));
  Self.UpdateXP();
  if (Time - Self.LastXPTime) < Self.XPAttkDelay then Exit;
  if (Time - Self.LastAttack) < Self.NextAttkDelay then Exit;
  if not Self.InGame() then Exit;
  Self.EnablePrayerCheck();

  if Self.AttackShifter({true}) then
  begin
    Activity.Restart();
    Self.LastAttack := Time;
    Self.UpdateAttkDelay();
    Sleep(ExGaussInt(Self.bRT*2.2));
  end;
end;

procedure TPestControl.LeaveTheGame();
begin
  if not Self.InGame() then Exit;
  Sleep(ExGaussInt(Self.bRT * 3.3));
  if not Self.InGame() then Exit;
  try
    Writeln('Distance to Squire: ', Self.Squire.DistanceTo(Map.Position()));
    if not Self.InGame() then Exit;
    if Self.Squire.DistanceTo(Map.Position()) > (8+Random(4)+Round(5*bhM.U)) then
      if Map.Walker.WebWalk(Self.Squire.Coordinates[0].Offset(Random(-5, 5),
        Random(5, 10)), 3+Round(3*(bhM.U)), 0.2+0.5*bhM.U) then
          Writeln('Walked towards Squire');
    if not Self.InGame() then Exit;
    if Self.Squire.Interact(['Leave Squire', 'eave Squire'], 1+Round(3*bhM.U)) then
    begin
      Self.LeaveGameCount+=1;
      WriteLn('Left game at ', FormatMilliseconds(GetTimeRunning, TIME_SHORT));
      SleepUntil(not Self.InGame(), Round(200+random(200)), Round(17000+9000*bhM.U));
    end else
      Writeln('Failed to leave game');
  except Writeln('TPestControl.LeaveTheGame - ', GetExceptionMessage); end;
end;

procedure TPestControl.OnWalkerEvent(walker: PRSWalker; position, destination: TPoint);
begin
  if not Self.InGame() then
  begin
    walker^.Walking := False;
    Exit;
  end;
  if (Self.State = EPestState.WALK_MID) then
    Self.EnablePrayerCheck();
  Self.UpdateAndDrawHUD();
end;

procedure TPestControl.SetAttackTempo();
var
  bhInt: Int32;
  xpVar, lowVar: Double;
begin
  bhInt := Trunc(bhM.U * 1000);

  // Session variance (±8%)
  xpVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);
  lowVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);

  Self.Tempo.XPMean := (2573 + 990 * bhM.U) * xpVar;
  Self.Tempo.XPStick := 0.20 + 0.18 * ((bhInt shr 5) mod 1000 / 1000.0);
  Self.XPAttkDelay := ExpoGaussRT(Self.Tempo.XPMean, Self.RT[0].U, Self.RT[1].U);

  Self.Tempo.LowMean := (750 + 350 * _bhM.U) * lowVar;
  Self.Tempo.LowStick := 0.20 + 0.18 * (((bhInt shr 5) xor 913) mod 1000 / 1000.0);
  Self.NextAttkDelay := ExpoGaussRT(Self.Tempo.LowMean, Self.RT[0].U, Self.RT[1].U);

  Logger.Info('Tempo - XP:%.0fms(x%.2f) Low:%.0fms(x%.2f)',
    [Self.Tempo.XPMean, xpVar, Self.Tempo.LowMean, lowVar]);
end;

procedure TStateTimer.Add(State: EPestState; Ms: Int64);
begin
  Self.Times[State] := Self.Times[State] + Ms;
end;

procedure TStateTimer.LogAll();
var
  State: EPestState;
begin
  WriteLn('=== State Time Report ===');
  for State := Low(EPestState) to High(EPestState) do
    if Self.Times[State] > 0 then
      WriteLn(PadR(ToStr(State), 15), ' : ', FmtTime(Self.Times[State]));
end;

procedure TPestControl.OnBreakStart(task: PBreakTask);
begin
  Logger.Info('Break starting - Fatigue: %.1f%%', [Self.F.GetLvl * 100]);
end;

procedure TPestControl.OnSleepStart(task: PSleepTask);
begin
  Logger.Info('Sleep starting - Fatigue: %.1f%%', [Self.F.GetLvl * 100]);
end;

procedure TPestControl.OnBreakEnd(task: PBreakTask);
var before: Double;
begin
  before := Self.F.Lvl;
  Self.F.Recover(Self.F.BrkRecov, Round(task^.Length));
  Logger.Info('Break ended - Fatigue: %.1f%% → %.1f%% (recovered %.1f%%)',
    [before * 100, Self.F.Lvl * 100, (before - Self.F.Lvl) * 100]);
end;

procedure TPestControl.OnSleepEnd(task: PSleepTask);
var before: Double;
begin
  before := Self.F.Lvl;
  Self.F.Recover(Self.F.SlpRecov, Round(task^.Length));
  Logger.Info('Sleep ended - Fatigue: %.1f%% → %.1f%% (recovered %.1f%%)',
    [before * 100, Self.F.Lvl * 100, (before - Self.F.Lvl) * 100]);
end;

procedure TPestControl.OnBreakingHud(task: PBreakTask; var countdown: TCountdown);
begin
  Self.UpdateAndDrawHUD(True, False, countdown.Remaining, True);
end;

procedure TPestControl.OnSleepingHud(task: PSleepTask; var countdown: TCountdown);
begin
  Self.UpdateAndDrawHUD(False, True, countdown.Remaining, True);
end;

procedure TPestControl._OnPause();
begin
  WriteLn ProgressReport.Generate(ProgressReport.ValueProvider());
  RSClient.EnableRealInput();
  RSClient.Canvas.Clear();
end;

procedure TPestControl._OnResume();
begin
  RSClient.DisableRealInput();
end;


procedure TPestControl._OnTermination();
begin
  WriteLn ProgressReport.Generate(ProgressReport.ValueProvider());
  Self.StateTimer.LogAll();
  Writeln('STATE ON TERMINATION: '+ToStr(Self.State));
  RSClient.Canvas.Clear;
  RSClient.EnableRealInput();
end;

procedure _InitPCData();
begin
  PCData.GameIsland := [10498, 39938, 10749, 40189];
  PCData.OutpostIsland := [10501, 39700, 10736, 39916];


  PCData.Nov.AtPlank := [10630, 39874];
  PCData.Nov.PlankObj := [10633, 39874];
  PCData.Nov.BoatBox := [10640, 39856, 10655, 39879];

  PCData.Inter.AtPlank := [10578, 39854];
  PCData.Inter.PlankObj := [10572, 39854];
  PCData.Inter.BoatBox := [10552, 39840, 10567, 39863];

  PCData.Vet.AtPlank := [10554, 39818];
  PCData.Vet.PlankObj := [10548, 39818];
  PCData.Vet.BoatBox := [10524, 39810, 10544, 39838];

  PCData.Portals.W := [];
  PCData.Portals.SW := [];
  PCData.Portals.SE := [];
  PCData.Portals.E := [];

  PCData.Knight := [10626, 40061];
  PCData.Spawn := [10632, 39994];
  PCData.LeaveNPC := [10620, 40002];

  PCData.OCR.ActivBox := [365, 121, 511, 131];
  PCData.OCR.PointsBox := [72, 64, 123, 81];
  PCData.OCR.ActivGreen := 40704;
  PCData.OCR.ActivRed := 255;

  PCData.OCR.W := [370, 53, 396, 68];
  PCData.OCR.E := [406, 53, 434, 68];
  PCData.OCR.SE := [445, 53, 470, 68];
  PCData.OCR.SW := [484, 53, 507, 68];

  PCData.OCR.Shield_W := [];
  PCData.OCR.Shield_E := [];
  PCData.OCR.Shield_SE := [];
  PCData.OCR.Shield_SW := [];

  PCData.OCR.KnightHP := [34, 39, 61, 54];
end;

procedure TPestControl.InitAttackProfile();
var
  baseWeights: array[0..2] of Double;
  i: Int32;
  total: Double;
begin
  //0..7
  Self.attkC.Create(['profileU', 'selfU', 'knightU', 'randU', 'stickU', 'decayType', 'decayParam']);

  if Self.attkC[0].U < 0.5 then
    baseWeights := [55.0, 40.0, 5.0]  // Self-primary
  else
    baseWeights := [40.0, 55.0, 5.0]; // Knight-primary

  total := 0;
  for i := 0 to 2 do
  begin
    Self.AttackWeights[i] := baseWeights[i] * (0.67 + 0.66 * Self.attkC[i+1].U);
    Self.AttackWeights[i] *= EnsureRange(GaussRand(1.0, 0.04), 0.84, 1.16);
    total += Self.AttackWeights[i];
  end;

  for i := 0 to 2 do
    Self.AttackWeights[i] := Self.AttackWeights[i] / total;

  Self.AttackStick := 0.15 + 0.25 * Self.attkC[4].U;
  Self.AttackStick *= EnsureRange(GaussRand(1.0, 0.025), 0.925, 1.075);

  if Self.AttackWeights[0] > Self.AttackWeights[1] then
    Self.AttackChoice := EAttackChoice.Self
  else
    Self.AttackChoice := EAttackChoice.Knight;

  Logger.Info('Attack Profile - Self:%.1f%% Knight:%.1f%% Rand:%.1f%% Stick:%.1f%%',
    [Self.AttackWeights[0]*100, Self.AttackWeights[1]*100, Self.AttackWeights[2]*100, Self.AttackStick*100]);
end;

procedure TFatigue.Init();
var
  rateVar, onsetVar, brkVar, slpVar: Double;
  rtVar, errVar, driftVar, revertVar, steepVar: Double;
begin
  Self.U.Create(['rate', 'drift', 'revert', 'rtMult', 'errRate', 'brkRecov', 'slpRecov', 'onsetTime']);

  // Major session variance (±20%, ±15%, ±10%)
  rateVar := EnsureRange(GaussRand(1.0, 0.10), 0.7, 1.3);
  onsetVar := EnsureRange(GaussRand(1.0, 0.10), 0.7, 1.3);
  brkVar := EnsureRange(GaussRand(1.0, 0.075), 0.775, 1.225);
  slpVar := EnsureRange(GaussRand(1.0, 0.05), 0.85, 1.15);

  // Minor personality variance (±5-10%)
  rtVar := EnsureRange(GaussRand(1.0, 0.025), 0.925, 1.075);
  errVar := EnsureRange(GaussRand(1.0, 0.05), 0.85, 1.15);
  driftVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);
  revertVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);
  steepVar := EnsureRange(GaussRand(1.0, 0.10), 0.7, 1.3);  // ±20% for steepness

  // Apply all variance
  Self.Rate := (0.015 + 0.030 * Self.U[0].U) * rateVar;
  Self.OnsetTime := (15.0 + 20.0 * Self.U[7].U) * onsetVar;
  Self.OnsetSteep := (0.30) * steepVar;  // Base 0.3, vary to 0.21-0.39
  Self.BrkRecov := (0.20 + 0.20 * Self.U[5].U) * brkVar;
  Self.SlpRecov := (0.70 + 0.30 * Self.U[6].U) * slpVar;

  Self.Drift := (0.05 + 0.10 * Self.U[1].U) * driftVar;
  Self.Revert := (0.03 + 0.07 * Self.U[2].U) * revertVar;
  Self.RTMult := (1.15 + 0.45 * Self.U[3].U) * rtVar;
  Self.ErrRate := (0.02 + 0.10 * Self.U[4].U) * errVar;

  Self.Lvl := 0.0;
  Self.DriftCur := 0.0;
  Self.Start := Time;
  Self.Last := Time;

  Logger.Info('Fatigue - Rate:%.3f Onset:%.1fmin(k=%.2f) RT:%.2fx Err:%.1f%%',
    [Self.Rate, Self.OnsetTime, Self.OnsetSteep, Self.RTMult, Self.ErrRate*100]);
end;

procedure TPestControl.SetupMouse();
var
  speedBase, gravBase, windBase: Double;
  clickMinBase, clickMaxBase: Int32;
  speedVar, gravVar, windVar, clickVar: Double;
begin
  Self.M.Create(['speed', 'gravity', 'wind', 'click min', 'click max', 'miss chance']);

  // Base values
  speedBase := 10.0 + 4.0 * Self.M[0].U;
  gravBase := 7.0 + 4.0 * Self.M[1].U;
  windBase := 3.0 + 4.0 * Self.M[2].U;
  clickMinBase := 50 + Round(30.0 * Self.M[3].U);
  clickMaxBase := 120 + Round(80.0 * Self.M[4].U);

  // Session variance (±8%)
  speedVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);
  gravVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);
  windVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);
  clickVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);

  // Apply variance
  Mouse.Speed := speedBase * speedVar;
  Mouse.Gravity := gravBase * gravVar;
  Mouse.Wind := windBase * windVar;
  Mouse.PressMin := Round(clickMinBase * clickVar);
  Mouse.PressMax := Round(clickMaxBase * clickVar);

  Mouse.MissChance := 0.01 + 0.03 * Self.M[5].U;

  Logger.Info('Mouse - Speed:%.1f Grav:%.1f Wind:%.1f Click:%d-%dms Miss:%.1f%%',
    [Mouse.Speed, Mouse.Gravity, Mouse.Wind, Mouse.PressMin, Mouse.PressMax, Mouse.MissChance*100]);
end;

procedure TPestControl.Init();
begin
  WriteLn('[INIT] Pest Control - SIMBA2000');
  Logger.Setup('Pest Control JDS');
  Logger.RepeatedMessages := True;
  ProgressReport.Setup(
    'Pest Control JDS',
    [
      'Total   runtime:', 'Active  runtime:', 'Antiban runtime:',
      'Next sleep:', 'Games Won:', 'Wins/Hour:', 'Points Earned:',
      'Points/Hour:', 'Actions:'
    ],
    @Self.GetReportValues,
    Round(ONE_MINUTE*2.5)
  );
  Antiban.OnBreaking := @Self.OnBreakingHud;
  Antiban.OnSleeping := @Self.OnSleepingHud;
  Antiban.OnStartBreak := @Self.OnBreakStart;
  Antiban.OnStartSleep := @Self.OnSleepStart;
  Antiban.OnFinishBreak := @Self.OnBreakEnd;
  Antiban.OnFinishSleep := @Self.OnSleepEnd;
  AddOnTerminate(@Self._OnTermination);
  AddOnPause(@Self._OnPause);
  AddOnResume(@Self._OnResume);
  _InitPCData();

  Self.SetupMouse();

  bhM.Create('bhM');
  Self.Flag.Choices.Create(['NoPray', 'NoLeave', 'NoBoatMove1', 'NoBoatMove2', 'DelayBoatMove']);
  _bhM.Create('_bhM');
  Self.P.Create(['U_Prayer1', 'U_Prayer2', 'U_Prayer3']);
  Self.RT.Create(['RT_U1', 'RT_U2', 'RTC_U']);

  // Result: 153-345ms with Gaussian distribution around personality baseline
  self.bRT := (180 + 120*bhM.U) * EnsureRange(GaussRand(1.0, 0.05), 0.85, 1.15);

  Self.F.Init();
  Self.InitAttackProfile();
  Self.SetAttackTempo();
  Self.ActivityThresh := EnsureRange(Self.UserActiveThreshold+Random(-7, 7), 50, 100);
  Self.PrayerEnableTime := Self.PrayerSample();
  // Map setup
  Map.Setup([Chunk(Box(40,41,41,41), 0)]); //pc boat area
  Map.Add([Chunk(Box(41,40,41,40), 0)]); //pc game area
  Map.Walker.OnWaitMovingEvent := @Self.OnWalkerEvent;
  Map.Walker.OnWalkEvent := @Self.OnWalkerEvent;
  Map.Walker.TargetUpText := ['tack Shifter', 'Attack Shifter'];
  Self.Center := PCData.Knight.Offset(2, 0);
  Self.Squire := TRSEntity.Create(@Map.Walker, [1, 1, 4], 5, [PCData.LeaveNPC], ['to Squire', 'Talk-to'], [ERSMinimapDot.NPC]);
  Self.Shifter := TRSEntity.Create(
    @Map.Walker,
    [1, 1, 1],
    14 + Round(3*bhM.U),
    [PCData.Knight],
    ['tack Shifter', 'Attack Shifter'],
    [ERSMinimapDot.NPC]
  );

  // Initialize stats
  Self.Start := Time;
  Self.GameStart := Time;
  Self.GamesWon := -1;
  Self.PtsTotal := -1;
  Self.PtsStart := -1;
  Self.CombatLevel := -1;
  
  // Antiban setup
  Antiban.Zoom.Min := 30;
  Antiban.Zoom.Max := 50;
  Antiban.Skills := [ERSSkill.RANGED, ERSSkill.MAGIC, ERSSkill.PRAYER, ERSSkill.ATTACK, ERSSkill.STRENGTH, ERSSkill.DEFENCE, ERSSkill.TOTAL];
  
  Activity.Restart();
  
  WriteLn('[INIT] Initialization complete');
end;

procedure TPestControl.Run();
var
  nState: EPestState;
  tRand: Int32;
  breakOrSleep: Boolean;
begin
  Self.Init();
  tRand := Round(Random(0, 80+100*bhM.U));
  Profiles[ProfileIndex].Worlds := [344];

  Self.State := EPestState.INIT;

  repeat
    nState := Self.GetState();

    if nState <> self.State then
    begin
      if Self.State <> EPestState.INIT then  // skip initial
        Self.StateTimer.Add(Self.State, Time - Self.StateT);
      Self.StateT := Time;
      Self.State := nState;
      Self.UpdateAndDrawHUD(False, False, 0, True);
      Logger.Info('[STATE] ' + ToStr(Self.State));
    end else
    begin
      Self.State := nState;
      Self.UpdateAndDrawHUD();
    end;

    ProgressReport.Print();

    case Self.State of
      EPestState.UNKNOWN:begin
                          Sleep(LogNormalInt(500, 0.35));
                          Writeln('[UNKNOWN STATE]', FormatMilliseconds(Logger.TimeRunning.Elapsed, TIME_SHORT));
                         end;

      EPestState.LOGIN: Login.DoLogin();

      EPestState.CMBT_LVL: Self.UpdateCmbtLvl();

      EPestState.ANTIBAN: Antiban.DoTask();
      EPestState.BREAK: Antiban.DoBreak();
      EPestState.SLEEP: Antiban.DoSleep();

      EPestState.IN_BOAT: Self.WhileInBoat();
      
      EPestState.WALK_MID: Self.WalkToDefend();
      
      EPestState.DEFEND: Self.DefendKnight();

      EPestState.EXIT_GAME: Self.LeaveTheGame();

      EPestState.AT_PLANK: Self.EnterBoat();
      
      EPestState.NO_ACTIVITY, EPestState.MAX_ACTIONS,
      EPestState.MAX_TIME, EPestState.END_SCRIPT: Exit;
    end;
  until self.PtsTotal > (3800 + tRand);

  Writeln('Total Points: ', Self.PtsTotal, ' is more than: ', 3800 + tRand);
  WriteLn('[COMPLETE] Thank you for using Pest Control JDS');
  Self.StateTimer.LogAll();
end;

var
  Form: TScriptForm;
  PCConfig: TConfigJSON;
  AutoStartTimer: TLazTimer;
  CountdownLabel: TLazLabel;
  TimerStartTime: UInt64;
  DisplayTimer: TLazTimer;

  ChkQuickPrayer, ChkChillIfActive, ChkDisableFatigue: TLazCheckBox;
  ChkDisableHUD, ChkDisableMoveInBoat, ChkDisablePace, ChkDisableLeaveGame: TLazCheckBox;
  EditCombatLevel: TLazEdit;
  EditActiveThreshold: TLazEdit;
  TLTrackActiveThresh: TLazTrackBar;
  EditPointsPerWin: TLazComboBox;

procedure OnAnyInteraction(sender: TLazObject);
begin
  if AutoStartTimer <> nil then
  begin
    AutoStartTimer.Enabled := False;
    AutoStartTimer.Free();
    AutoStartTimer := nil;
  end;
  if DisplayTimer <> nil then
  begin
    DisplayTimer.Enabled := False;
    DisplayTimer.Free();
    DisplayTimer := nil;
  end;
  if CountdownLabel <> nil then
  begin
    CountdownLabel.Free();
    CountdownLabel := nil;
  end;
end;

procedure OnSliderChanged(sender: TLazObject);
begin
  EditActiveThreshold.text := IntToStr(EnsureRange(TLTrackActiveThresh.Position, 50, 100));
end;

procedure OnTimerTick(sender: TLazObject);
begin
  AutoStartTimer.Enabled := False;
  WriteLn('[AUTO-START] Starting script');
  Form.Start.Click();
end;

procedure UpdateCountdown(sender: TLazObject);
var
  elapsed, remaining: Int32;
begin
  elapsed := (Time - TimerStartTime) div 1000;
  remaining := AUTO_START_DELAY - elapsed;

  if remaining > 0 then
    CountdownLabel.Caption := 'Auto-start in ' + ToStr(remaining) + 's'
  else
    CountdownLabel.Caption := 'Starting...';
end;

procedure TScriptForm.StartAutoTimer(sender: TLazObject);
var
  bottomPanel: TLazPanel;
begin
  TimerStartTime := Time;

  AutoStartTimer := TLazTimer.Create(Self.Form);
  AutoStartTimer.Interval := AUTO_START_DELAY*ONE_SECOND;
  AutoStartTimer.OnTimer := @OnTimerTick;
  AutoStartTimer.Enabled := True;

  DisplayTimer := TLazTimer.Create(Self.Form);
  DisplayTimer.Interval := 1000;
  DisplayTimer.OnTimer := @UpdateCountdown;
  DisplayTimer.Enabled := True;

  // Find bottom panel (Start button's parent)
  bottomPanel := TLazPanel(Self.Start.Parent);

  CountdownLabel := TLazLabel.CreateEx(bottomPanel);
  CountdownLabel.Caption := 'Auto-start in ' + ToStr(AUTO_START_DELAY) + 's';
  CountdownLabel.Font.Size := 9;
  CountdownLabel.Font.Color := $0000FF;  // Red
  CountdownLabel.Transparent := True;
  CountdownLabel.Left := Self.Start.Left - 100;  // Left of Start button
  CountdownLabel.Top := (bottomPanel.Height - 16) div 2;  // Centered vertically
  CountdownLabel.Width := 100;
  CountdownLabel.Height := 16;
end;

procedure TScriptForm.OnStart(sender: TLazObject); override;
var
  GoalT, GoalA: UInt64;
begin
  inherited;
  RSClient.DisableRealInput();
  GoalA := Self.Goals.Actions.Value;
  GoalA := GoalA + Round(Random(GoalA*-0.13, GoalA*0.23));
  PestControl.MaxActions := GoalA;
  GoalT := Self.Goals.Time.Value * ONE_MINUTE;
  GoalT := GoalT + Round(Random(GoalT*-0.13, GoalT*0.23));
  PestControl.MaxTime := GoalT;

  PestControl.UserQuickPrayer := ChkQuickPrayer.IsChecked();
  PestControl.UserChillIfActive := ChkChillIfActive.IsChecked();
  PestControl.UserActiveThreshold := EnsureRange(StrToInt(EditActiveThreshold.Text, 50), 50, 100);
  PestControl.PtsPerGame := StrToInt(EditPointsPerWin.text, 7);
  PestControl.UserDisableHUD := ChkDisableHUD.IsChecked();
  PestControl.UserDisableMoveInBoat := ChkDisableMoveInBoat.IsChecked();
  PestControl.UserDisablePace := ChkDisablePace.IsChecked();
  PestControl.UserDisableLeaveGame := ChkDisableLeaveGame.IsChecked();
  PestControl.UserCombatLevel := StrToInt(EditCombatLevel.Text, 100);
  PestControl.UserDisableFatigue := ChkDisableFatigue.IsChecked();

  if PCConfig.Data.Has('goal_actions') then
    PCConfig.Data.Item['goal_actions'].AsInt := Self.Goals.Actions.Value
  else
    PCConfig.Data.AddInt('goal_actions', Self.Goals.Actions.Value);

  if PCConfig.Data.Has('goal_time') then
    PCConfig.Data.Item['goal_time'].AsInt := Self.Goals.Time.Value
  else
    PCConfig.Data.AddInt('goal_time', Self.Goals.Time.Value);

  if PCConfig.Data.Has('quick_prayer') then
    PCConfig.Data.Item['quick_prayer'].AsBool := PestControl.UserQuickPrayer
  else
    PCConfig.Data.AddBool('quick_prayer', PestControl.UserQuickPrayer);

  if PCConfig.Data.Has('chill_if_active') then
    PCConfig.Data.Item['chill_if_active'].AsBool := PestControl.UserChillIfActive
  else
    PCConfig.Data.AddBool('chill_if_active', PestControl.UserChillIfActive);

  if PCConfig.Data.Has('active_threshold') then
    PCConfig.Data.Item['active_threshold'].AsInt := PestControl.UserActiveThreshold
  else
    PCConfig.Data.AddInt('active_threshold', PestControl.UserActiveThreshold);

  if PCConfig.Data.Has('points_per_win') then
    PCConfig.Data.Item['points_per_win'].AsInt := PestControl.PtsPerGame
  else
    PCConfig.Data.AddInt('points_per_win', PestControl.PtsPerGame);

  if PCConfig.Data.Has('disable_hud') then
    PCConfig.Data.Item['disable_hud'].AsBool := PestControl.UserDisableHUD
  else
    PCConfig.Data.AddBool('disable_hud', PestControl.UserDisableHUD);

  if PCConfig.Data.Has('disable_move_in_boat') then
    PCConfig.Data.Item['disable_move_in_boat'].AsBool := PestControl.UserDisableMoveInBoat
  else
    PCConfig.Data.AddBool('disable_move_in_boat', PestControl.UserDisableMoveInBoat);

  if PCConfig.Data.Has('disable_pace') then
    PCConfig.Data.Item['disable_pace'].AsBool := PestControl.UserDisablePace
  else
    PCConfig.Data.AddBool('disable_pace', PestControl.UserDisablePace);

  if PCConfig.Data.Has('disable_leave_game') then
    PCConfig.Data.Item['disable_leave_game'].AsBool := PestControl.UserDisableLeaveGame
  else
    PCConfig.Data.AddBool('disable_leave_game', PestControl.UserDisableLeaveGame);

  if PCConfig.Data.Has('disable_fatigue') then
    PCConfig.Data.Item['disable_fatigue'].AsBool := PestControl.UserDisableFatigue
  else
    PCConfig.Data.AddBool('disable_fatigue', PestControl.UserDisableFatigue);

  if PCConfig.Data.Has('combat_level') then
    PCConfig.Data.Item['combat_level'].AsInt := PestControl.UserCombatLevel
  else
    PCConfig.Data.AddInt('combat_level', PestControl.UserCombatLevel);

  //SAVE!!!!
  PCConfig.Save();
end;

procedure TScriptForm.Init();
var
  tab: TLazTabSheet;
  goalsPanel: TLazPanel;
  lblQuickPrayer, lblCombatLevel, lblChillActive, lblActiveThresh, lblPointsPerWin, titleLabel, authorLabel: TLazLabel;
  bgImage: TLazImage;
  y: Int32;
begin
  PCConfig.Setup('jds-pestcontrol');
  Self.Setup('Pest Control LITE', PCConfig.Data);

  if USE_AUTO_START then
    Self.Form.OnShow := @Self.StartAutoTimer;

  // ===== Settings Tab =====
  tab := Self.CreateTab('Settings');
  tab.Color := $1A1A1A;

  if not FileExists(SimbaEnv.DataPath+'jdsBackground.png') then
    URLFetchToFile('https://i.imgur.com/xN2rmA4.png', SimbaEnv.DataPath+'jdsBackground.png');

  // Background image
  bgImage := TLazImage.CreateEx(tab);
  bgImage.Align := ELazAlign.Client;
  bgImage.Picture.LoadFromFile(SimbaEnv.DataPath + 'jdsBackground.png');
  bgImage.Stretch := True;
  bgImage.Proportional := False;
  bgImage.SendToBack();

  y := 20;

  // Quick Prayer
  lblQuickPrayer := TLazLabel.CreateEx(tab, 'Quick Prayer:', '', 20, y, 140, 30);
  lblQuickPrayer.Font.Size := 14;
  lblQuickPrayer.Font.Color := $F0F0F0;
  lblQuickPrayer.Color := $2A2A2A;
  lblQuickPrayer.Transparent := False;
  lblQuickPrayer.Alignment := ELazAlignment.Center;
  lblQuickPrayer.Layout := ELazTextLayout.Center;

  ChkQuickPrayer := TLazCheckBox.CreateEx(tab);
  ChkQuickPrayer.SetBounds(170, y, 560, 30);
  ChkQuickPrayer.Caption := 'Enable quick prayers during combat';
  ChkQuickPrayer.Font.Size := 14;
  ChkQuickPrayer.Font.Color := $F0F0F0;
  ChkQuickPrayer.SetChecked(True);
  Inc(y, 40);

  // Chill if Active
  lblChillActive := TLazLabel.CreateEx(tab, 'Chill Mode:', '', 20, y, 140, 30);
  lblChillActive.Font.Size := 14;
  lblChillActive.Font.Color := $F0F0F0;
  lblChillActive.Color := $2A2A2A;
  lblChillActive.Transparent := False;
  lblChillActive.Alignment := ELazAlignment.Center;
  lblChillActive.Layout := ELazTextLayout.Center;

  ChkChillIfActive := TLazCheckBox.CreateEx(tab);
  ChkChillIfActive.SetBounds(170, y, 560, 30);
  ChkChillIfActive.Caption := 'Reduce activity if above threshold';
  ChkChillIfActive.Font.Size := 14;
  ChkChillIfActive.Font.Color := $F0F0F0;
  ChkChillIfActive.SetChecked(False);
  Inc(y, 40);

  // Activity Threshold
  lblActiveThresh := TLazLabel.CreateEx(tab, 'Activity Threshold:', '', 20, y, 180, 30);
  lblActiveThresh.Font.Size := 14;
  lblActiveThresh.Font.Color := $F0F0F0;
  lblActiveThresh.Color := $2A2A2A;
  lblActiveThresh.Transparent := False;
  lblActiveThresh.Alignment := ELazAlignment.Center;
  lblActiveThresh.Layout := ELazTextLayout.Center;

  EditActiveThreshold := TLazEdit.CreateEx(tab);
  EditActiveThreshold.SetBounds(210, y, 60, 30);
  EditActiveThreshold.Text := '75';
  EditActiveThreshold.Font.Size := 14;
  EditActiveThreshold.Font.Color := $F0F0F0;
  EditActiveThreshold.Color := $2A2A2A;

  TLTrackActiveThresh := TLazTrackBar.CreateEx(tab);
  TLTrackActiveThresh.Frequency := 1;
  TLTrackActiveThresh.SelStart := 50;
  TLTrackActiveThresh.SelEnd := 100;
  TLTrackActiveThresh.Min := 50;
  TLTrackActiveThresh.Max := 100;
  TLTrackActiveThresh.TickStyle := ELazStickStyle.None;
  TLTrackActiveThresh.SetBounds(280, y, 300, 30);
  TLTrackActiveThresh.ShowSelRange := True;
  TLTrackActiveThresh.OnChange := @OnSliderChanged;
  Inc(y, 45);

  // Points Per Win
  lblPointsPerWin := TLazLabel.CreateEx(tab, 'Points/Win:', '', 20, y, 140, 30);
  lblPointsPerWin.Font.Size := 14;
  lblPointsPerWin.Font.Color := $F0F0F0;
  lblPointsPerWin.Color := $2A2A2A;
  lblPointsPerWin.Transparent := False;
  lblPointsPerWin.Alignment := ELazAlignment.Center;
  lblPointsPerWin.Layout := ELazTextLayout.Center;

  EditPointsPerWin := TLazComboBox.CreateEx(tab);
  EditPointsPerWin.SetBounds(170, y, 100, 30);
  EditPointsPerWin.Items.AddStrings(['3', '4', '5', '6', '7', '8']);
  EditPointsPerWin.Text := '7';
  EditPointsPerWin.Font.Size := 14;
  EditPointsPerWin.Font.Color := $F0F0F0;
  EditPointsPerWin.Color := $2A2A2A;
  Inc(y, 50);

  // Combat Level
  lblCombatLevel := TLazLabel.CreateEx(tab, 'Combat Level:', '', 20, y, 140, 30);
  lblCombatLevel.Font.Size := 14;
  lblCombatLevel.Font.Color := $F0F0F0;
  lblCombatLevel.Color := $2A2A2A;
  lblCombatLevel.Transparent := False;
  lblCombatLevel.Alignment := ELazAlignment.Center;
  lblCombatLevel.Layout := ELazTextLayout.Center;

  EditCombatLevel := TLazEdit.CreateEx(tab);
  EditCombatLevel.SetBounds(170, y, 100, 30);
  EditCombatLevel.Text := '-1';
  EditCombatLevel.Font.Size := 14;
  EditCombatLevel.Font.Color := $F0F0F0;
  EditCombatLevel.Color := $2A2A2A;
  Inc(y, 50);

  // === Advanced Options Header ===
  lblQuickPrayer := TLazLabel.CreateEx(tab, 'Advanced Options', '', 20, y, 220, 30);
  lblQuickPrayer.Font.Size := 14;
  lblQuickPrayer.Font.Color := $3B9FFF;
  lblQuickPrayer.Font.Style := [ELazFontStyles.Bold];
  lblQuickPrayer.Color := $2A2A2A;
  lblQuickPrayer.Transparent := False;
  lblQuickPrayer.Alignment := ELazAlignment.Center;
  lblQuickPrayer.Layout := ELazTextLayout.Center;
  Inc(y, 40);

  // Disable HUD
  ChkDisableHUD := TLazCheckBox.CreateEx(tab);
  ChkDisableHUD.SetBounds(20, y, 300, 30);
  ChkDisableHUD.Caption := 'Disable HUD';
  ChkDisableHUD.Hint := 'Turn off in-game overlay';
  ChkDisableHUD.ShowHint := True;
  ChkDisableHUD.Font.Size := 14;
  ChkDisableHUD.Font.Color := $F0F0F0;
  ChkDisableHUD.SetChecked(False);

  // Disable Boat Movement
  ChkDisableMoveInBoat := TLazCheckBox.CreateEx(tab);
  ChkDisableMoveInBoat.SetBounds(390, y, 330, 30);
  ChkDisableMoveInBoat.Caption := 'Disable Boat Move';
  ChkDisableMoveInBoat.Hint := 'Disable boat movement entirely';
  ChkDisableMoveInBoat.ShowHint := True;
  ChkDisableMoveInBoat.Font.Size := 14;
  ChkDisableMoveInBoat.Font.Color := $F0F0F0;
  ChkDisableMoveInBoat.SetChecked(False);
  Inc(y, 35);

  // Disable Pacing
  ChkDisablePace := TLazCheckBox.CreateEx(tab);
  ChkDisablePace.SetBounds(20, y, 300, 30);
  ChkDisablePace.Caption := 'Disable Pacing';
  ChkDisablePace.Hint := 'Disable game movement entirely';
  ChkDisablePace.ShowHint := True;
  ChkDisablePace.Font.Size := 14;
  ChkDisablePace.Font.Color := $F0F0F0;
  ChkDisablePace.SetChecked(False);

  // Disable Leave Game
  ChkDisableLeaveGame := TLazCheckBox.CreateEx(tab);
  ChkDisableLeaveGame.SetBounds(390, y, 330, 30);
  ChkDisableLeaveGame.Caption := 'Disable Auto-Leave';
  ChkDisableLeaveGame.Hint := 'Never leave a game, even if activity drops';
  ChkDisableLeaveGame.ShowHint := True;
  ChkDisableLeaveGame.Font.Size := 14;
  ChkDisableLeaveGame.Font.Color := $F0F0F0;
  ChkDisableLeaveGame.SetChecked(False);
  Inc(y, 35);

  // Disable Fatigue
  ChkDisableFatigue := TLazCheckBox.CreateEx(tab);
  ChkDisableFatigue.SetBounds(20, y, 300, 30);
  ChkDisableFatigue.Caption := 'Disable Fatigue';
  ChkDisableFatigue.Hint := 'Disable fatigue system';
  ChkDisableFatigue.ShowHint := True;
  ChkDisableFatigue.Font.Size := 14;
  ChkDisableFatigue.Font.Color := $F0F0F0;
  ChkDisableFatigue.SetChecked(False);

  // Title and Author in bottom right
  titleLabel := TLazLabel.CreateEx(tab, 'Pest Control LITE', '', 520, 420, 250, 35);
  titleLabel.Font.Size := 24;
  titleLabel.Font.Color := $3B9FFF;
  titleLabel.Font.Style := [ELazFontStyles.Bold];
  titleLabel.Transparent := True;
  titleLabel.Alignment := ELazAlignment.RightJustify;

  authorLabel := TLazLabel.CreateEx(tab, 'by footballjds', '', 580, 455, 190, 20);
  authorLabel.Font.Size := 12;
  authorLabel.Font.Color := $3B9FFF;
  authorLabel.Transparent := True;
  authorLabel.Alignment := ELazAlignment.RightJustify;

  // Load saved config
  if PCConfig.Data.Has('quick_prayer') then
    ChkQuickPrayer.SetChecked(PCConfig.Data.Item['quick_prayer'].AsBool);
  if PCConfig.Data.Has('chill_if_active') then
    ChkChillIfActive.SetChecked(PCConfig.Data.Item['chill_if_active'].AsBool);
  if PCConfig.Data.Has('active_threshold') then
  begin
    EditActiveThreshold.Text := ToStr(PCConfig.Data.Item['active_threshold'].AsInt);
    TLTrackActiveThresh.Position := PCConfig.Data.Item['active_threshold'].AsInt;
  end;
  if PCConfig.Data.Has('points_per_win') then
    EditPointsPerWin.Text := ToStr(PCConfig.Data.Item['points_per_win'].AsInt);

  if PCConfig.Data.Has('disable_hud') then
    ChkDisableHUD.SetChecked(PCConfig.Data.Item['disable_hud'].AsBool);
  if PCConfig.Data.Has('disable_move_in_boat') then
    ChkDisableMoveInBoat.SetChecked(PCConfig.Data.Item['disable_move_in_boat'].AsBool);
  if PCConfig.Data.Has('disable_pace') then
    ChkDisablePace.SetChecked(PCConfig.Data.Item['disable_pace'].AsBool);
  if PCConfig.Data.Has('disable_leave_game') then
    ChkDisableLeaveGame.SetChecked(PCConfig.Data.Item['disable_leave_game'].AsBool);
  if PCConfig.Data.Has('disable_fatigue') then
    ChkDisableFatigue.SetChecked(PCConfig.Data.Item['disable_fatigue'].AsBool);
  if PCConfig.Data.Has('combat_level') then
  EditCombatLevel.Text := ToStr(PCConfig.Data.Item['combat_level'].AsInt);
  // Goals panel at bottom
  goalsPanel := Self.CreateGoals(tab, True, True, False, EOrientation.HORIZONTAL);
  goalsPanel.Align := ELazAlign.Bottom;
  goalsPanel.Color := $3B9FFF;
  goalsPanel.Font.Style := [ELazFontStyles.Bold];
  goalsPanel.Font.Color := $000000;

  if PCConfig.Data.Has('goal_actions') then
    Self.Goals.Actions.Value := PCConfig.Data.Item['goal_actions'].AsInt;
  if PCConfig.Data.Has('goal_time') then
    Self.Goals.Time.Value := PCConfig.Data.Item['goal_time'].AsInt;

  // ===== Antiban Tab =====
  Self.CreateAntibanTab();

  // Hook interactions
  ChkQuickPrayer.OnChange := @OnAnyInteraction;
  ChkChillIfActive.OnChange := @OnAnyInteraction;
  EditActiveThreshold.OnChange := @OnAnyInteraction;
  EditPointsPerWin.OnChange := @OnAnyInteraction;
  ChkDisableHUD.OnChange := @OnAnyInteraction;
  ChkDisableMoveInBoat.OnChange := @OnAnyInteraction;
  ChkDisablePace.OnChange := @OnAnyInteraction;
  ChkDisableLeaveGame.OnChange := @OnAnyInteraction;
  EditCombatLevel.OnChange := @OnAnyInteraction;
  Self.Goals.Actions.OnChange := @OnAnyInteraction;
  Self.Goals.Time.OnChange := @OnAnyInteraction;

  Form.Run();
end;

begin
  ClearSimbaOutput();
  Form.Init();
  PestControl.Run();
end.
