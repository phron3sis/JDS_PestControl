{$DEFINE SCRIPT_ID := 'pest_control_jds'}
{$DEFINE SCRIPT_REVISION := '2'}
{$DEFINE SCRIPT_GUI}
{$I WaspLib/osrs.simba}
const
  USE_AUTO_START    = TRUE; //auto-start
  AUTO_START_DELAY  = 30;   //delay(in seconds) before auto-starting
type
  TPestControlGameData = record
    Nov, Inter, Vet: record
      AtPlank, PlankObj: TPoint;
      BoatBox: TBox;
    end;

    Portals: record
      W, SW, SE, E: TPoint;
    end;

    Knight, Spawn, LeaveNPC: TPoint;

    OCR: record
      KnightHP: TBox;
      ActivBox, PointsBox, W, E, SE, SW: TBox;
      Shield_W, Shield_E, Shield_SE, Shield_SW: TBox;
      ActivGreen, ActivRed: Int32;
    end;

    GameIsland, OutpostIsland: TBox;
  end;

var
  PCData: TPestControlGameData;

type
  EPestState = enum(
    INIT,
    LOGIN,
    CMBT_LVL,

    IN_BOAT,
    WALK_MID,
    DEFEND,
    AT_PLANK,
    WALK_PLANK,
    EXIT_GAME,
    SPEND_PTS,
    ANTIBAN,
    BREAK,
    SLEEP,

    NO_ACTIVITY, UNKNOWN, MAX_ACTIONS, MAX_TIME, END_SCRIPT
  );
  EAttackChoice = enum(Self, Knight, Rand);

type
  TDeseqState = record
    // Deseq traits
    U: TDoubleArray;

    // Per-game
    WinThreshGame: Double;
    InactiveThreshGame: Double;
    KnightHPLvl: Integer;

    // Per-interval noise (rerolled every few seconds)
    WinNoise: Double;
    InactiveNoise: Double;
    LastNoiseReroll: UInt64;
    NoiseInterval: UInt64;
  end;

type
  TAttackTempo = record
    XPMean, LowMean, XPMeanGame, LowMeanGame: UInt64;
    XPStick, LowStick: Double;
  end;
  TStateTimer = record
    Times: array[EPestState] of UInt64;  // milliseconds per state
  end;
type
  TPestControl = record

    // Account unique decisions
    Flag: record
      NoPray, NoLeave, NoPace, NoBoatMove, DelayBoatMove: Boolean;
      Choices: TDoubleArray;
      GameKnightOffset: TPoint;
    end;

    State: EPestState;
    StateT: UInt64;
    StateTimer: TStateTimer;
    
    // Map coordinates, rename for clarity or wait for refactor
    // Your script looks like toilet paper used by Donald Trump
    // Seperate your concerns instead of monolithic type declaration
    Center, AtPlank, CrossPlank: TPoint;
    BoatBox: TBox;

    // U's and Choices
    P: TDoubleArray; // Prayer
    M: TDoubleArray; // Mouse
    B: TDoubleArray; // Boat
    LocU: TDoubleArray; // Location U's
    SampleRTUs: TDoubleArray; // Random RT selection U's
    Deseq: TDeseqState; // Desequence
    attkC: TDoubleArray; // Attack choices
    AttackChoice: EAttackChoice;
    AttackIndex: Int32;
    AttackWeights: array[0..2] of Double;
    AttackStick: Double;
    KnightDistThresh: Double; // Per-session drift to avoid patterns
    LambdaSession, AlphaSession: Double;

    // Objects & Entities  
    Gangplank: TRSObject;
    Squire, Shifter, VoidKnight: TRSEntity;

    // Timing
    bRT: UInt64;
    RT: TDoubleArray;// ResponseTime traits
    Tempo: TAttackTempo;
    XPAttkDelay: UInt64;
    NextAttkDelay, LastAttack: UInt64;
    LastXP,
    LastXPTime,
    HUDLastUpdate,
    GameStart: UInt64;
    GameStarted: Boolean;
    LastEmoteMS: UInt64;
    EmoteDelayMS: Int64;
    PostAttack: Double;// chance 0..1 to skip waiting after attack

    // Prayer
    PrayerEnableTime: UInt64;
    
    // Boat movement
    LastBoatMove: UInt64;
    BoatMoveDelay: UInt64;
    
    // Activity
    ActivityThresh: Int32;

    // Stats
    Start, LastWin, CombatLevel: UInt64;
    KnightHP, wHP, eHP, seHP, swHP, portalsHP: Int32;
    WShielded, EShielded, SEShielded, SWShielded: Boolean;
    GamesWon, PtsPerGame, LeaveGameCount: UInt32;
    PtsStart, PtsEarned, PtsTotal, SkillInterfacesClosed: Int32;

    UserDisableHUD, UserDisableMoveInBoat, UserDisablePace, UserDisableLeaveGame: Boolean;
    UserDisableFatigue, UserDisableInactive: Boolean;
    Actions, MaxActions, MaxTime: UInt64;
    UserActiveThreshold, UserCombatLevel, UserSpendPointsAt, UserEmoteAmount, UserRewardAmount: Int32;
    UserReward: String;
    UserEmoteListI, UserEmoteListC, UserEmoteListW: TIntegerArray;
    UserEmoteInactive, UserEmoteChilling, UserEmoteWinning: Boolean;
    UserQuickPrayer, UserChillIfActive, UserSpendPoints, UserRestAfterGame: Boolean;
  end;

var
  PestControl: TPestControl;
  bhM, _bhM: Double;

// Helper functions/distribution math
function SoftRandBool(U: Double; _power: Double = 2.0; scale: Double = 1.0): Boolean;
begin
  Result := RandomBoolean(Power(U, _power) * scale);
end;

function FmtTime(ms: UInt64): String;
begin
  if ms < ONE_MINUTE then
    Result := FormatFloat('0.0', ms / ONE_SECOND) + 's'
  else if ms < ONE_HOUR then
    Result := FormatMilliseconds(ms, 'm\m s\s')
  else
    Result := FormatMilliseconds(ms, 'h\h m\m');
end;

// Truncated Gaussian with re-sample instead of clamp
function TruncGauss(mu, sigma, lo, hi: Double): Double;
begin
  if lo > hi then
    TerminateScript(Format('TruncGauss lo=%.2f is above hi=%.2f', [lo, hi]));
  repeat
    Result := GaussRand(mu, sigma);
  until (Result >= lo) and (Result <= hi);
end;

// 0 < Random < 1
function NZRandom: Double;
begin
  repeat
    Result := Random;
  until (Result > 0) and (Result < 1);

end;

// John D. Cook approximation ported to Simba 2.0
// Domain: x > 0
// Exposes: Gamma(x), LogGamma(x)
function LogGamma(x: Double): Double; forward;

function Gamma(x: Double): Double;
const
  EULER_GAMMA = 0.577215664901532860606512090;

  p: array[0..7] of Double = [
    -1.71618513886549492533811E+0,
     2.47656508055759199108314E+1,
    -3.79804256470945635097577E+2,
     6.29331155312818442661052E+2,
     8.66966202790413211295064E+2,
    -3.14512729688483675254357E+4,
    -3.61444134186911729807069E+4,
     6.64561438202405440627855E+4
  ];

  q: array[0..7] of Double = [
    -3.08402300119738975254353E+1,
     3.15350626979604161529144E+2,
    -1.01515636749021914166146E+3,
    -3.10777167157231109440444E+3,
     2.25381184209801510330112E+4,
     4.75584627752788110767815E+3,
    -1.34659959864969306392456E+5,
    -1.15132259675553483497211E+5
  ];

var
  DBL_MAX: Double = 1.7976931348623157E+308;
  y, z, num, den, res: Double;
  n, i: Int32;
  argLT1: Boolean;
begin
  if x <= 0 then
    raise 'Gamma domain error: x must be > 0';

  // (0, 0.001)
  if x < 0.001 then
    Exit(1.0 / (x * (1.0 + EULER_GAMMA * x)));

  // [0.001, 12)
  if x < 12.0 then
  begin
    y := x;
    n := 0;
    argLT1 := (y < 1.0);

    if argLT1 then
      y := y + 1.0
    else
    begin
      // y >= 1 here, so Trunc(y) == Floor(y)
      n := Int32(Trunc(y)) - 1;
      y := y - n;
    end;

    num := 0.0;
    den := 1.0;

    z := y - 1.0;
    for i := 0 to 7 do
    begin
      num := (num + p[i]) * z;
      den := den * z + q[i];
    end;

    res := num / den + 1.0;

    if argLT1 then
      // gamma(z) = gamma(z+1)/z ; here z = y-1 (original x)
      res := res / (y - 1.0)
    else
      // gamma(z+n) = z*(z+1)*...*(z+n-1)*gamma(z)
      for i := 1 to n do
      begin
        res := res * y;
        y := y + 1.0;
      end;

    Exit(res);
  end;

  // [12, inf)
  if x > 171.624 then
    Exit(DBL_MAX);

  Result := Exp(LogGamma(x));
end;

function LogGamma(x: Double): Double;
const
  c: array[0..7] of Double = [
     1.0/12.0,
    -1.0/360.0,
     1.0/1260.0,
    -1.0/1680.0,
     1.0/1188.0,
    -691.0/360360.0,
     1.0/156.0,
    -3617.0/122400.0
  ];

  HALF_LOG_TWO_PI = 0.91893853320467274178032973640562;

var
  z, sum, series: Double;
  i: Int32;
begin
  if x <= 0 then
    raise 'LogGamma domain error: x must be > 0';

  if x < 12.0 then
    Exit(Ln(Abs(Gamma(x))));

  // Abramowitz & Stegun 6.1.41
  z := 1.0 / (x * x);

  sum := c[7];
  for i := 6 downto 0 do
    sum := sum * z + c[i];

  series := sum / x;

  Result := (x - 0.5) * Ln(x) - x + HALF_LOG_TWO_PI + series;
end;

// Gamma sampler (Marsaglia-Tsang method)
function SampleGamma(shape: Double): Double;
var
  d, c, x, v, u: Double;
begin
  if shape < 1.0 then
  begin
    Result := SampleGamma(shape + 1.0) * Power(Random(), 1.0 / shape);
    Exit;
  end;

  d := shape - 1.0/3.0;
  c := 1.0 / Sqrt(9.0 * d);

  repeat
    repeat
      x := GaussRand(0.0, 1.0);
      v := 1.0 + c * x;
    until v > 0;

    v := v * v * v;
    u := Random();
  until (u < 1.0 - 0.0331*x*x*x*x) or (Ln(u) < 0.5*x*x + d*(1.0 - v + Ln(v)));

  Result := d * v;
end;

// Beta distribution via Gamma ratio
function SampleBeta(alpha, beta: Double): Double;
var
  x, y: Double;
begin
  x := SampleGamma(alpha);
  y := SampleGamma(beta);
  Result := x / (x + y);
end;

// LOGNORMAL (math form):
//   If Z ~ N(muLog, sigmaLog), then X = exp(Z) is lognormal.
//   Use when you want strictly positive, right-skewed reaction times.
function LogNormalEx(muLog, sigmaLog: Double): Double;
begin
  // Lognormal transform
  Result := Exp(muLog + sigmaLog * GaussRand(0.0, 1.0));
end;

// LOGNORMAL (human form):
//                 mean = typical delay (mean-ish RT)
function LogNormal(mean, sigma: Double): Double;
begin
  Result := LogNormalEx(Ln(mean) - 0.5 * sigma * sigma, sigma);
end;

function LogNormalInt(mean, sigma:Double): UInt64;
begin
  Result := Max(0, Round(LogNormal(mean, sigma)));
end;

// LogNormal with response time traits baked in
function LogNormalRT(mean: Double = PestControl.bRT): UInt64;
var
  sigma: Double;
begin
  if mean < 1 then mean := 1;

  // Per-account sigma preference (0.3-0.7 range)
  sigma := 0.3 + 0.4 * PestControl.RT[3];

  {$IFDEF WL_FATIGUE_INCLUDED}
  // Fatigue: slower + heavier tail
  mean := mean * Fatigue.RTMuMultiplier;
  sigma := sigma * Fatigue.RTSigmaMultiplier;
  {$ENDIF}

  Result := Round(LogNormal(mean, sigma));
end;

// EX-GAUSSIAN (math form):
//   X = Gaussian(mu, sigma) + Exponential(tau)
//   This is the classic RT model: Gaussian core + exponential tail.
function ExpoGaussEx(mu, sigma, tau: Double): Double;
begin
  // Gaussian core + Exponential tail (rate = 1/tau)
  Result := GaussRand(mu, sigma) + (-tau * Ln(NZRandom));

  if Result < 0 then
    Result := 0;
end;

// ExpoGauss with response time traits baked in
function ExpoGaussRT(mean: Double = PestControl.bRT; shouldLog: Boolean = False): UInt64;
var
  mu, sigma, tau: Double;
begin
  if mean < 1 then mean := 1;
  mu := mean;
  sigma := mu * (0.10 + 0.08*PestControl.RT[0]);
  tau   := mu * (0.22 + 0.15*PestControl.RT[1]);
  {$IFDEF WL_FATIGUE_INCLUDED}
  if shouldLog then
    Logger.Warn('mu=%.2f | simga=%.2f | tau=%.2f', [mu, sigma, tau]);
  Fatigue.AdjRTParams(mu, sigma, tau);
  if shouldLog then
  begin
    Logger.Warn('mu=%.2f | simga=%.2f | tau=%.2f', [mu, sigma, tau]);
    Logger.Warn('Multipliers: mu=%.2f | simga=%.2f | tau=%.2f', [Fatigue.RTMuMultiplier, Fatigue.RTSigmaMultiplier, Fatigue.RTTauMultiplier]);
  end;
  {$ENDIF}
  Result := Round(ExpoGaussEx(mu, sigma, tau));
end;

// WEIBULL (math form):
//   CDF: 1 - exp(-(x/scale)^shape)
//   shape_k > 0, scale_lambda > 0
//   Useful for fatigue / hazard-rate modeling.
function WeibullEx(shape_k, scale_lambda: Double): Double;
var
  u: Double;
begin
  if shape_k <= 0 then
    shape_k := 0.000001;
  if scale_lambda <= 0 then
    scale_lambda := 0.000001;

  u := NZRandom; // uniform [0,1)

  // Inverse CDF
  Result := scale_lambda * Power(-Ln(u), 1.0 / shape_k);

  if Result < 0 then
    Result := 0;
end;

// Weibull with response time traits baked in
function WeibullRT(mean: Double = PestControl.bRT): UInt64;
var
  shape, scale: Double;
begin
  if mean < 1 then mean := 1;

  // Per-account shape preference (1.2-2.2 range, higher = less tail)
  shape := 1.2 + 1.0 * PestControl.RT[4];
  scale := mean / Gamma(1.0 + 1.0/shape);

  {$IFDEF WL_FATIGUE_INCLUDED}
  // Fatigue: slower (scale up) + more variable (shape down)
  scale := scale * Fatigue.RTMuMultiplier;
  shape := shape / (1.0 + 0.3 * Fatigue.FatigueNormalized);
  {$ENDIF}

  Result := Round(WeibullEx(shape, scale));
end;

// Decide what math to use based on response time traits
function SampleRT(mean: Double = PestControl.bRT): UInt64;
begin
  if SoftRandBool(PestControl.RT[5], 2.0, 0.55) then
    Result := ExpoGaussRT(mean)
  else if SoftRandBool(PestControl.RT[6], 2.0, 0.65) then
    Result := WeibullRT(mean)
  else
    Result := LogNormalRT(mean);
end;

// Uses account, username and salt to create deterministic U (0..1)
function HashToU(const salt: String): Double;
const
  INV_POW2_53 = 1.1102230246251565e-16;
var
  ident, msg, hex: String;
  v, k: UInt64;
begin
  ident := Profiles[ProfileIndex].Name + ':' +
    Profiles[ProfileIndex].Username;

  msg := 'HashToU:v1:' + ident + ':' + salt;
  hex := HashString(EHashAlgo.SHA256, msg);
  v := StrToUInt64('$' + Copy(hex, 1, 16));
  k := (v shr 11);
  Result := (k * INV_POW2_53) + (0.5 * INV_POW2_53);
end;

// Turns double into 0 < U < 1.0
procedure Double.CreateU(const salt: String = '');
begin
  Self := HashToU(salt);
  WriteLn(PadR(Salt, 16), Self);
end;

// Turns TDoubleArray into array of 0 < U < 1.0
procedure TDoubleArray.CreateU(const salts: TStringArray = ['']);
var
  i : Integer;
begin
  SetLength(Self, salts.Length);
  for i := 0 to salts.High do
    Self[i].CreateU(salts[i]);
end;

// Checks mainscreen for text color in skill interface and closes
// Honestly nothing should open this interface, but i've seen it happen
procedure TPestControl.CloseSkillInterface();
begin
  if Target.CountColor([$0A3146, 0.375, EColorSpace.HSV, [1.000, 1.000, 1.000]],
    MainScreen.Bounds) < 100 then Exit();
  Sleep(Self.bRT, 8000);
  Target.KeyPress(EKeyCode.ESCAPE);
  Sleep(Self.bRT, 1800);
  Writeln(GetDebugLn('SKILL INTERFACE CLOSED - why was it open? lol, Message footballjds!', ELogLevel.ERROR));
  Inc(Self.SkillInterfacesClosed);
  if Self.SkillInterfacesClosed > (5 + 10 * _bhM) then
    TerminateScript('TOO MANY INTERFACES CLOSED, failsafe. Message footballjds!!!');
end;

procedure TConfigJSON.SetConfig(const key: String; value: UInt64); overload;
begin
  if not Self.Data.Has(key) then Self.Data.AddInt(key, value) else
    Self.Data.Item[key].AsInt := value;
end;

procedure TConfigJSON.SetConfig(const key: String; value: Double); overload;
begin
  if not Self.Data.Has(key) then Self.Data.AddFloat(key, value) else
    Self.Data.Item[key].AsFloat := value;
end;

procedure TConfigJSON.SetConfig(const key: String; value: Boolean); overload;
begin
  if not Self.Data.Has(key) then Self.Data.AddBool(key, value) else
    Self.Data.Item[key].AsBool := value;
end;

procedure TConfigJSON.SetConfig(const key: String; value: String); overload;
begin
  if not Self.Data.Has(key) then Self.Data.AddString(key, value) else
    Self.Data.Item[key].AsString := value;
end;

type
  TRSPestShop = record
    Title: TRSInterfaceTitle;
    SpendablePoints: Integer;
    Bounds, PointsOCR: TBox;
    ConfirmButton: TRSButton;
    RewardStrings: TStringArray;
    ItemBoxes: TBoxArray;
    Costs: TIntegerArray;
    Scroll: TRSScrollBar;
    NPC: TRSEntity;
  end;

var
  PestShop: TRSPestShop;

procedure TRSPestShop.Setup();
var
  x1, y1, x2, slotW, slotW2, slotH, gapX, gapY: Int32;
  boxes: TBoxArray;
begin
  Self.RewardStrings := ['Attack', 'Defence', 'Magic', 'Prayer', 'Strength', 'Ranged', 'Hitpoints'];
  Self.RewardStrings += ['Herb Pack', 'Mineral Pack', 'Seed Pack'];
  Self.RewardStrings += ['Void Knight Mace', 'Void Knight Top', 'Void Knight Robes', 'Void Knight Gloves'];
  Self.RewardStrings += ['Void Mage Helm', 'Void Ranger Helm', 'Void Melee Helm', 'Void Knight Seal'];

  case RSClient.Mode of
    ERSMode.FIXED:
      Self.Bounds := MSInterface.CreateBounds([0, 0, 0, 0], 489, 319);
    ERSMode.RESIZABLE, ERSMode.MODERN_COMPACT, ERSMode.MODERN_WIDE:
      Self.Bounds := MSInterface.CreateBounds([0, 0, 0, 0], 489, 319);
  end;


  Self.PointsOCR.X1 := Self.Bounds.X1 + 83;
  Self.PointsOCR.Y1 := Self.Bounds.Y2 - 37;
  Self.PointsOCR.X2 := Self.Bounds.X1 + 133;
  Self.PointsOCR.Y2 := Self.Bounds.Y2 - 18;

  Self.Scroll.Area.X1 := Self.Bounds.X1 + 10;
  Self.Scroll.Area.Y1 := Self.Bounds.Y1 + 42;
  Self.Scroll.Area.X2 := Self.Bounds.X2 - 27;
  Self.Scroll.Area.Y2 := Self.Bounds.Y2 - 51;

  Self.Scroll.Setup(True);
  Self.Title.Setup(Self.Bounds);

  x1 := Self.Scroll.Area.X1 + 42;
  x2 := Self.Scroll.Area.X1+2;
  slotW2 := Self.Scroll.Area.Width div 2 - 2;
  y1 := Self.Scroll.Area.Y1 + 4;
  slotW := 61;
  slotH := 29;
  gapX := 0;
  gapY := 6;

  // Top section: 6 columns x 3.5 rows
  boxes := TBoxArray.Create([x1, y1], 3, 4, slotW, slotH, [gapX, gapY]);
  x1 := Self.Scroll.Area.X1 + 84 + slotW*3;
  boxes += TBoxArray.Create([x1, y1], 3, 3, slotW, slotH, [gapX, gapY]);

  // Middle section after divider: 2 columns x 1.5 rows
  y1 := Self.Scroll.Area.Y1+157; // after divider
  boxes += TBoxArray.Create([x2, y1], 2, 1, slotW2, slotH, [gapX, gapY]);
  Inc(y1, slotH+gapY);
  boxes += TBoxArray.Create([x2, y1], 1, 1, slotW2, slotH, [gapX, gapY]);

  // Bottom section: 2 columns x 4 rows
  y1 := Self.Scroll.Area.Y1+85;
  boxes += TBoxArray.Create([x2, y1], 2, 4, slotW2, slotH, [gapX, gapY]);
  Self.ItemBoxes := boxes;

  Self.Costs := [1, 10, 100, 1, 10, 100, 1, 10, 100,
    1, 10, 100, 1, 10, 100, 1, 10, 100, 1, 10, 100];
  Self.Costs += [30, 15, 15];
  Self.Costs += [250, 250, 250, 150, 200, 200, 200, 10];

  if (self.Costs.Length <> Self.ItemBoxes.Length) or
    (Self.ItemBoxes.Length <> Self.RewardStrings.Length + 14) then
    RaiseException('!FATAL! TRSPestShop.Setup(); Reward strings don''t match boxes!');

  Self.ConfirmButton.Bounds := Box(
    Self.Bounds.Center.X - 73,
    Self.Bounds.Y2 - 42,
    Self.Bounds.Center.X + 74,
    Self.Bounds.Y2 - 10
  );
  self.ConfirmButton.EnabledColors := [[$1F98FF, 0]];

  Self.NPC := TRSEntity.Create(
    Map.Walker,
    [1, 1, 1],
    20,
    [[10648, 39826], [10640, 39826]],
    ['Talk-to Void', 'Void Knight', 'to Void K', 'oid Knight'],
    [ERSMinimapDot.NPC]
  );
  Self.NPC.Finder.ColorClusters += [[
    [$7192B6, 0.519, EColorSpace.HSV, [1.444, 1.444, 0.114]],
    [$321B1B, 0.759, EColorSpace.HSV, [2.300, 0.168, 0.533]],
    5
  ]];
  Self.NPC.Finder.ColorClusters += [[
    [$351D1D, 0.827, EColorSpace.HSV, [2.405, 0.158, 0.439]],
    [$27657E, 0.625, EColorSpace.HSV, [1.410, 1.314, 0.277]],
    5
  ]];

end;

function TRSPestShop.IsOpen(): Boolean;
begin
  result := Target.CountColor(2070783, 0, [163, 21, 359, 39]) = 638;
end;

function TRSPestShop.isClosed(): Boolean;
begin
  result := not Self.IsOpen();
end;

function TRSPestShop.WaitOpen(): Boolean;
begin
  result := SleepUntil(Self.IsOpen(), 50, random(2000, 4000));
end;

function TRSPestShop.DidPurchase(): Boolean;
begin
  Result := Chat.HasContinue and not Chat.LeveledUp();
end;

function TRSPestShop.WaitPurchased(openAgain: Boolean = False): Boolean;
var
 t: Int64;
begin
  t := Time + Random(1500, 4000);
  repeat
    if Self.DidPurchase then
      if openAgain and Chat.Continue() then
        Exit(Self.WaitOpen())
      else
        Exit(True);
  until (Time > t);
end;

function TRSPestShop.Close(escape: Boolean): Boolean;
begin
  Result := Self.Title.Close(escape);
end;

function TRSPestShop.Close(escapeProbability: Single = -1): Boolean; overload;
begin
  Result := Self.Title.Close(escapeProbability);
end;

function TRSPestShop.Open(attempts: Integer = 3): Boolean;
var
  i: Integer;
begin
  if Chat.HasContinue() then
  begin
    Target.KeyPress(EKeyCode.SPACE);
    result := Self.WaitOpen();
    if result then Exit;
  end;
  if attempts <= 3 then attempts := random(3,5);
  for i := 0 to attempts do
  begin
    if Self.IsOpen() then Exit(true);
    if ChooseOption.IsOpen() then
    begin
      if ChooseOption.Select(['Exchange Void Knight', 'Exchange Void'], True, True) then
        if Self.WaitOpen() then
          Exit(True);
      ChooseOption.Close();
      Sleep(60, 200);
    end;
    if self.NPC.DistanceTo(Map.Position()) > RandomMode(4, 4, 7) then
      Map.Walker.WalkBlind(Self.NPC.Coordinates[Random(0, Self.NPC.Coordinates.High)], 5);
    if Self.NPC.Interact(['Exchange Void Knight', 'Exchange Void'], 1) then
      if Self.WaitOpen() then
        Exit(True);
  end;
end;

function TRSPestShop.ReadPoints: Integer;
begin
  Result := 0;
  if not Self.IsOpen() then Exit;
  result := OCR.RecognizeNumber(Self.PointsOCR, RSFonts.BOLD_SHADOW, [RSFonts.WHITE], 0);
  Self.SpendablePoints := Result;
end;


function TRSPestShop.BuyReward(reward:String; pts: Integer): Boolean;
var
  xpBefore: UInt64;
  idx, invCt: Integer;// TBoxArray index of reward string
begin
  if not Self.IsOpen() then Exit;
  if not Self.RewardStrings.Contains(reward) then
    RaiseException('!FATAL! TRSPestShop.BuyReward(); Reward INVALID!');
  xpBefore := XPBar.Read;
  invCt := Inventory.Slots.Count();
  if reward.Contains('Void', True) then
    Self.Scroll.SetLevel(100)
  else
    Self.Scroll.SetLevel(0);
  Sleep(60, 400);
  idx := (Self.RewardStrings.IndexOf(reward)+1)*3 - 1;
  if reward in ['Attack', 'Defence', 'Magic', 'Prayer', 'Strength', 'Ranged', 'Hitpoints'] then
    if pts = 1 then idx-=2
    else if pts = 10 then
      idx-=1;
  Self.SpendablePoints := Self.ReadPoints;
  if pts > Self.SpendablePoints then
  begin
    Writeln(GetTimeRunning,' ','Not enough points to purchase...');
    Exit;
  end;
  Mouse.Click(Self.ItemBoxes[idx].Expand(-1), EMouseButton.LEFT);
  Sleep(220, 480);

  if self.ConfirmButton.WaitEnabled() then
  begin
    Self.ConfirmButton.Click();
    if SleepUntil(Self.isClosed(), RandomLeft(111, 321), RandomLeft(1800, 5300)) then
      Result := (Inventory.Slots.Count() <> invCt) or (XPBar.Read <> xpBefore);
    if Result then Self.SpendablePoints-=pts;
    writeln(GetTimeRunning,' ','did buy ', result);
  end;
end;

function TRSPestShop.PurchaseExp(expString: String; stopAt: Integer): Boolean;
var
  spend, remaining, before, fails, attempts: Integer;
  tEnd: UInt64;
begin
  tEnd := Time + Random(ONE_MINUTE*5, ONE_MINUTE*8);
  attempts := Random(10, 20);
  fails := 0;
  repeat
    writeln('in PurchaseExp GetTimeRunning=',GetTimeRunning);
    if not Self.Open() then
      Exit;
    Sleep(120, 500);
    Self.SpendablePoints := Self.ReadPoints;
    remaining := Self.SpendablePoints - stopAt;
    if remaining <= 0 then Break;

    writeln(GetTimeRunning,' ','TRSPestShop.PurchaseExp() remaining points=', remaining);
    spend := 1 + 9*(Ord(remaining >= 10) and 1) + 90*(Ord(remaining >= 100) and 1);

    writeln(GetTimeRunning,' ','TRSPestShop.PurchaseExp() spendable points', spend);
    before := Self.SpendablePoints;
    if not Self.BuyReward(expString, spend) then
      Inc(fails);

    if Self.SpendablePoints >= before then
      Inc(fails);
    Sleep(120, 500);
  until (Self.SpendablePoints <= stopAt) or (Time >= tEnd) or (fails >= attempts);
  Result := (Self.SpendablePoints <= stopAt) and (Time < tEnd) and (fails < attempts);
end;

function TPestControl.SpendPestPoints(): Boolean;
var
  stopAt: Integer;
begin
  if (Self.UserRewardAmount = -1) then
    stopAt := 0
  else
    stopAt := Self.PtsTotal-Self.UserRewardAmount;
  Sleep(ExpoGaussRT(Self.bRT));
  Result := PestShop.PurchaseExp(Self.UserReward, stopAt);
  Sleep(ExpoGaussRT(Self.bRT));
  Writeln(GetDebugLn('Reward purchase', 'Sucuessfuly purchased='+ToStr(Result), ELogLevel.WARN));
end;

// Override include to set zoom if it is wrong
function TRSOptions.GetZoomLevel(useCache: Boolean = True): Integer; override;
begin
  if useCache and (Self.ZoomLevel > -1) then
    Exit(Self.ZoomLevel);

  WriteLn GetDebugLn('Options', 'Unknown zoom level, reading from the gametab...');
  if Self.OpenTab(ERSOptionsTab.DISPLAY) then
    Self.ZoomLevel := Self.Sliders[ERSOptionsSlider.ZOOM].GetLevel();
  if Self.ZoomLevel = -1 then
    WriteLn GetDebugLn('Options', 'Failed to read zoom!', ELogLevel.ERROR)
  else
    WriteLn GetDebugLn('Options', 'Current zoom level: ' + ToString(Self.ZoomLevel), ELogLevel.SUCCESS);

  Result := Self.ZoomLevel;
  if InRange(Result, 30, 50) then exit;
  if Self.SetZoomLevel(RandomMode(35+Round(10*bhM), 30, 50)) then
  begin
    Result := Self.ZoomLevel;
    WriteLn GetDebugLn('Options', 'Zoom adjusted level: ' + ToString(Self.ZoomLevel), ELogLevel.SUCCESS);
  end;
end;

// Override include to not rotate compass when attacking shifters
function TRSEntity._HoverHelper(action: TStringArray; attempts: Integer): Boolean; override;
var
  shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
  coordinates, tpa: TPointArray;
begin
  Result := Self._UpTextCheck(shouldExit, action);
  if shouldExit then Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(coordinates, atpa) then
    begin
      if Length(coordinates) <> Length(atpa) then
        raise 'SOMETHING WENT WRONG CACHING COORDINATES.';

      if attempt < 2 then i := 0
      else if Length(atpa) > (attempt - 2) then i := attempt - 2
      else i := Random(Low(atpa), High(atpa));

      tpa := atpa[i];
      Self.LastCoordinate := coordinates[i];

      Mouse.Move(tpa.RandomMean());

      if Self.UpText = [] then Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText) then Exit(True);

    if attempt <> (attempts - 1) then
      Continue;
    if not self.UpText.Contains('tack Shifter') then
      Minimap.CompassRadians := Minimap.CompassRadians + PI/3.6 * Random(-1,1);
  end;
end;

// =============================================================================
// PEST CONTROL METHODS
// =============================================================================

function TPestControl.GetReportValues(): TStringArray;
var
  playTime: UInt64;
  winsPerHour, ptsPerHour: Double;
  actionsStr, sleepInfo: String;
begin
  actionsStr := ToStr(Self.Actions);
  if Self.MaxActions <> 0 then
    actionsStr += '/' + ToStr(Self.MaxActions);

  if Antiban.Sleeps = [] then
    sleepInfo := 'No sleep'
  else
    sleepInfo := Antiban.TimeUntilSleep(Antiban.Sleeps.First, TIME_SHORT);

  playTime := Logger.TimeRunning.Elapsed;
  Self.GamesWon := Round(Self.PtsEarned/Self.PtsPerGame);
  winsPerHour := (Self.GamesWon / Max(1, playTime)) * ONE_HOUR;
  ptsPerHour := (Self.PtsEarned / Max(1, playTime)) * ONE_HOUR;


  Result := [
    GetTimeStamp(TIME_SHORT),
    Logger.TimeRunning.ElapsedFmt(TIME_SHORT),
    Antiban.TimeRunning.ElapsedFmt(TIME_SHORT),
    sleepInfo,
    ToStr(Self.GamesWon),
    FormatNumber(winsPerHour, 2),
    ToStr(Self.PtsEarned),
    FormatNumber(ptsPerHour, 2),
    actionsStr
  ];
end;

// Uses the 20 minute timer to see if we're in game
function TPestControl.InGame(): Boolean;
const
  sBox: Tbox = [11, 94, 49, 108];
begin
  result := Target.CountColor($CCCCCC, 0, sBox) > 35;
  if not result then Self.GameStarted := False;
end;

// Returns activity in percent 0..100
function TPestControl.ReadActivityBar(): Int32;
var
  greenCount: Int32;
  activBox: TBox = [368, 126, 508, 126];
begin
  result := -1;
  if not Self.InGame() then Exit;
  greenCount := Target.CountColor(PCData.OCR.ActivGreen, 0, activBox);
  Result := Round((greenCount / 141) * 100);
end;

function TPestControl.ReadKnightHP(): Int32;
begin
  Self.KnightHP := OCR.RecognizeNumber(PCData.OCR.KnightHP, RSFonts.PLAIN_11, [$00F800, $0000F8], 0);
  result := Self.KnightHP;
end;

function TPestControl.ReadPortalHP(): Int32;
begin
  Self.wHP := OCR.RecognizeNumber(PCData.OCR.W, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.eHP := OCR.RecognizeNumber(PCData.OCR.E, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.seHP := OCR.RecognizeNumber(PCData.OCR.SE, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.swHP := OCR.RecognizeNumber(PCData.OCR.SW, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.swHP := Max(0, Self.swHP);
  Self.portalsHP := Max(0, Self.wHP + Self.eHP + Self.seHP + Self.swHP);
  result := Self.portalsHP;
end;

procedure TPestControl.UpdatePortalShields();
const
  SHIELD_COLOR = $73737A;
  TOL = 1;
begin
  Self.ReadPortalHP();
  Self.WShielded := Target.HasColor(SHIELD_COLOR, TOL, 1, PCData.OCR.Shield_W);
  Self.EShielded := Target.HasColor(SHIELD_COLOR, TOL, 1, PCData.OCR.Shield_E);
  Self.SEShielded := Target.HasColor(SHIELD_COLOR, TOL, 1, PCData.OCR.Shield_SE);
  Self.SWShielded := Target.HasColor(SHIELD_COLOR, TOL, 1, PCData.OCR.Shield_SW);
  //writeln('W: ', Self.WShielded, '| E: ', Self.EShielded, '| SE: ', Self.SEShielded, '| SW: ', Self.SWShielded);
end;

procedure TPestControl.UpdateAndDrawHUD(onBreak: Boolean = False; onSleep: Boolean = False; remaining: UInt64 = 0; Force: Boolean = False);
const
  REFRESH_RATE_MS = 500;
  HUD_BG_COLOR = $181818;
  HUD_BORDER_COLOR = $404040;
  HUD_HEADER_TEXT = $3B9FFF;
  HUD_TEXT_COLOR = $F0F0F0;
  HUD_TEXT_MUTED = $A5A5A5;
  HUD_SEP_COLOR = $404040;
  HUD_ACTIVITY_RED = $0000F8;
  HUD_ACTIVITY_WARN = $57C8FF;
  HUD_ACTIVITY_GREEN = $47FF47;
  THRESHOLD_COLOR = $F0F0F0;
  TRACK_COLOR = $202020;
  PAD = 8;
  ROW_GAP = 11;
  SEP_MARGIN = 3;
  SEP_HEIGHT = 2;
var
  elapsed: UInt64;
  winsPerHour, ptsPerHour, xpPerHour: Double;
  abox, aboxBorder, headerBox, footerBox, barBox, barBorder, fillBox: TBox;
  xLabel, xVal, xRate, y, fullWidth, filledWidth, thrX, totalWidth: Int32;
  activityValue, runtimeStr, stateStr, winsStr, winsHrStr, ptsStr, ptsHrStr, portalStr: String;
  xpStr, xpHrStr, prayerStr, atkDelayStr, breakStr, sleepStr, maxActStr, maxTimeStr: String;
  breakRemain, sleepRemain: String;
  barColor, valueColor, actPercent, currentMinutes, xPos: Int32;

  function DrawSep(cy: Int32): Int32;
  begin
    Inc(cy, SEP_MARGIN);
    RSClient.Canvas.DrawColor := HUD_SEP_COLOR;
    RSClient.Canvas.DrawBoxFilled(Box(abox.X1 + 6, cy -1, abox.X2 - 6, cy + 1));
    Result := cy + SEP_HEIGHT + SEP_MARGIN;
  end;

  function DrawRow(const lbl, val: String; cy: Int32; const rate: String = ''): Int32;
  begin
    RSClient.Canvas.DrawColor := HUD_TEXT_MUTED;
    RSClient.Canvas.DrawText(lbl, Point(xLabel, cy));
    RSClient.Canvas.DrawColor := HUD_TEXT_COLOR;
    RSClient.Canvas.DrawText(val, Point(xVal, cy));
    if rate <> '' then
      RSClient.Canvas.DrawText(rate, Point(xRate, cy));
    Result := cy + ROW_GAP;
  end;

begin
  if Self.UserDisableHUD then Exit;
  if ((Time - Self.HUDLastUpdate) < REFRESH_RATE_MS) and
    not Force then Exit;
  Self.HUDLastUpdate := Time;

  Self.PtsEarned := Self.PtsTotal - Self.PtsStart;
  Self.GamesWon := Round(Self.PtsEarned / Self.PtsPerGame);
  elapsed := Logger.TimeRunning.Elapsed;
  winsPerHour := (Self.GamesWon / Max(1, elapsed)) * ONE_HOUR;
  ptsPerHour := (Self.PtsEarned / Max(1, elapsed)) * ONE_HOUR;
  xpPerHour := (XPBar.TotalEarnedXP() / Max(1, elapsed)) * ONE_HOUR;

  runtimeStr := FormatMilliseconds(GetTimeRunning, True);
  runtimeStr := runtimeStr.CopyRange(0, runtimeStr.LastIndexOf(':')-2);
  stateStr := ToStr(Self.State).After('EPestState.');

  breakRemain := '';
  sleepRemain := '';
  if onBreak then
  begin
    breakStr := FormatMilliseconds(remaining, TIME_SHORT);
    stateStr := 'ON_BREAK';
    breakRemain := 'time left';
  end else
  begin
    breakStr := 'None';
    if Length(Antiban.Breaks) > 0 then
      breakStr := Antiban.TimeUntilBreak(Antiban.Breaks[0], TIME_SHORT);
  end;
  if onSleep then
  begin
    sleepStr := FormatMilliseconds(remaining, TIME_SHORT);
    stateStr := 'ON_SLEEP';
    sleepRemain := 'time left';
  end else
  begin
    sleepStr := 'None';
    if Length(Antiban.Sleeps) > 0 then
      sleepStr := Antiban.TimeUntilSleep(Antiban.Sleeps[0], TIME_SHORT);
  end;

  winsStr := ToStr(Self.GamesWon);
  winsHrStr := FormatNumber(winsPerHour, 1);
  ptsStr := ToStr(Self.PtsEarned);
  ptsHrStr := FormatNumber(ptsPerHour, 0);
  xpStr := FormatNumber(XPBar.TotalEarnedXP(), 1);
  xpHrStr := FormatNumber(xpPerHour, 0);

  if (Self.LastXPTime + Self.XPAttkDelay) > Time() then
    atkDelayStr := FormatFloat('#,##0', Round(Self.XPAttkDelay)) + 'ms'
  else
    atkDelayStr := FormatFloat('#,##0', Round(Self.NextAttkDelay)) + 'ms';

  prayerStr := 'N/A';
  if Self.UserQuickPrayer then
    prayerStr := FormatFloat('#,##0', Round(Self.PrayerEnableTime)) + 'ms';

  maxActStr := '';
  if Self.MaxActions > 0 then
    maxActStr := ToStr(Self.Actions) + '/' + ToStr(Self.MaxActions);

  maxTimeStr := '';
  if Self.MaxTime > 0 then
  begin
    currentMinutes := GetTimeRunning div 60000;
    maxTimeStr := ToStr(currentMinutes) + '/' + ToStr(Self.MaxTime div 60000);
  end;

  actPercent := Self.ReadActivityBar();
  if actPercent <= 0 then
  begin
    activityValue := 'N/A';
    valueColor := HUD_TEXT_MUTED;
    barColor := HUD_ACTIVITY_WARN;
  end
  else
  begin
    activityValue := ToStr(actPercent)+'%';
    if actPercent <= 30 then
    begin
      valueColor := HUD_ACTIVITY_RED;
      barColor := HUD_ACTIVITY_RED;
    end
    else if actPercent < Self.ActivityThresh then
    begin
      valueColor := HUD_ACTIVITY_WARN;
      barColor := HUD_ACTIVITY_WARN;
    end
    else
    begin
      valueColor := HUD_ACTIVITY_GREEN;
      barColor := HUD_ACTIVITY_GREEN;
    end;
  end;

  abox := Box(552, 206, 731, 463);
  aboxBorder := abox.Expand(2);
  headerBox := Box(abox.X1, abox.Y1, abox.X2, abox.Y1 + 24);
  footerBox := Box(abox.X1, abox.Y2 - 18, abox.X2, abox.Y2);
  xLabel := abox.X1 + PAD;
  xVal := abox.X1 + 55;
  xRate := abox.X2 - 55;

  with RSClient.Canvas do
  begin
    BeginUpdate();

    DrawColor := HUD_BORDER_COLOR;
    DrawBoxFilled(aboxBorder);
    DrawColor := HUD_BG_COLOR;
    DrawBoxFilled(abox);
    DrawBoxFilled(headerBox);
    DrawBoxFilled(footerBox);

    FontName := 'Segoe UI';
    FontAntialiasing := True;
    FontSize := 16;
    DrawColor := HUD_HEADER_TEXT;
    DrawText('Pest Control LITE', Point(headerBox.X1 + PAD, headerBox.Y1 + 4));

    barBox := Box(abox.X1 + PAD, headerBox.Y2, abox.X1 + PAD +
      TextWidth('Pest Control LITE'), headerBox.Y2 + 8);
    barBorder := barBox.Expand(2);

    DrawColor := TRACK_COLOR;
    DrawBoxFilled(barBox);
    fullWidth := barBox.X2 - barBox.X1;
    filledWidth := (fullWidth * EnsureRange(actPercent, 0, 100)) div 100;
    if filledWidth > 0 then
    begin
      fillBox := barBox;
      fillBox.X2 := fillBox.X1 + filledWidth;
      DrawColor := barColor;
      DrawBoxFilled(fillBox);
      DrawBox(barBorder);
    end;
    thrX := barBox.X1 + (fullWidth * EnsureRange(Self.ActivityThresh, 0, 100)) div 100;
    DrawColor := THRESHOLD_COLOR;
    DrawBoxFilled(Box(thrX, barBox.Y1, thrX + 1, barBox.Y2));

    FontSize := 16;
    DrawColor := valueColor;
    DrawText(activityValue, Point(barBox.X2 + 4, barBox.Y1-2));

    y := barBox.Y2 +4;
    y := DrawSep(y);
    FontSize := 12;
    {$IFDEF WL_FATIGUE_INCLUDED}
    y := DrawRow('Runtime', runtimeStr, y, 'F '+ FormatFloat('##0.0', Fatigue.FatigueNormalized*100)+'%');
    {$ELSE}
    y := DrawRow('Runtime', runtimeStr, y);
    {$ENDIF}

    if stateStr.Contains('DEFEND') then
      y := DrawRow('State', stateStr, y, FmtTime(Time-Self.GameStart))
    else
      y := DrawRow('State', stateStr, y, FmtTime(Time-Self.StateT));
    y := DrawRow('Break', breakStr, y, breakRemain);
    y := DrawRow('Sleep', sleepStr, y, sleepRemain);
    y := DrawSep(y);
    y := DrawRow('Wins', winsStr, y, winsHrStr + '/hr');
    y := DrawRow('Points', ptsStr, y, ptsHrStr + '/hr');
    y := DrawRow('XP', xpStr, y, xpHrStr + '/hr');
    y := DrawSep(y);
    y := DrawRow('Prayer', prayerStr, y);
    DrawColor := HUD_TEXT_COLOR;
    if not onSleep and not onBreak then
      DrawText('Z: ' + ToStr(Options.ZoomLevel), Point(xRate, y - ROW_GAP));
    y := DrawRow('Attack', atkDelayStr, y);
    if Self.LeaveGameCount > 0 then
      DrawText('L''s: ' + ToStr(Self.LeaveGameCount), Point(xRate, y - ROW_GAP));
    y := DrawSep(y);
    y := DrawRow('Total', ToStr(Self.State).After('.'), y, FmtTime(Self.StateTimer.Times[Self.State]+ (Time - Self.StateT)));
    y := DrawRow('Total', 'Points', y, FormatFloat('#,##0', Self.PtsTotal));
    if Self.InGame() then
      y := DrawRow('Sort/idx', ToStr(Self.AttackChoice).After('.'), y, IntToStr(Self.AttackIndex));
    if maxActStr <> '' then y := DrawRow('Max', 'Actions', y, maxActStr);
    if maxTimeStr <> '' then y := DrawRow('Max', 'Time', y, maxTimeStr);

    if Self.InGame() then
    begin
      Self.UpdatePortalShields();

      totalWidth := TextWidth('(W) 999|') + TextWidth('(E) 999|') +
                    TextWidth('(SE)999|') + TextWidth('(SW)999');
      xPos := (abox.X1 + abox.X2) div 2 - totalWidth div 2;

      // W portal
      DrawColor := 16711935;
      if Self.WShielded then DrawText('(W)', Point(xPos, y+1))
      else DrawText('W:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(W) '));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.wHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 16711935;
      DrawText('|', Point(xPos, y+1));
      Inc(xPos, TextWidth('|'));

      // E portal
      DrawColor := 16737894;
      if Self.EShielded then DrawText('(E)', Point(xPos, y+1))
      else DrawText('E:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(E) '));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.eHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 16737894;
      DrawText('|', Point(xPos, y+1));
      Inc(xPos, TextWidth('|'));

      // SE portal
      DrawColor := 65535;
      if Self.SEShielded then DrawText('(SE)', Point(xPos, y+1))
      else DrawText('SE:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(SE)'));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.seHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 65535;
      DrawText('|', Point(xPos, y+1));
      Inc(xPos, TextWidth('|'));

      // SW portal
      DrawColor := 3355647;
      if Self.SWShielded then DrawText('(SW)', Point(xPos, y+1))
      else DrawText('SW:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(SW)'));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.swHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 3355647;
      DrawText('|', Point(xPos, y+1));

      FontSize := 12;
      y += ROW_GAP+2;
    end;

    DrawColor := HUD_SEP_COLOR;
    DrawBoxFilled(Box(abox.X1 + 6, footerBox.Y1, abox.X2 - 6, footerBox.Y1 + SEP_HEIGHT - 1));
    FontSize := 12;
    DrawColor := HUD_HEADER_TEXT;
    DrawText('By footballjds', Point(abox.X1 + PAD, footerBox.Y1 + 5));

    EndUpdate();
  end;
end;

// Uses static color count of text
function TPestControl.InBoat(): Boolean;
const
  ptsBox: TBox = [7, 62, 77, 80];
begin
  result := (target.CountColor(16777113, 0, ptsBox) = 140);
end;

procedure TPestControl.ReadPoints();
var
  blueNumber: Int32;
begin
  if not Self.InBoat() then Exit;
  blueNumber := OCR.RecognizeNumber(PCData.OCR.PointsBox, RSFonts.PLAIN_12, [16777113], 0);
  if self.PtsStart < 0 then
    self.PtsStart := blueNumber;
  self.PtsTotal := blueNumber;
  self.PtsEarned := self.PtsTotal-self.PtsStart;
end;

// Use static color instead of Map.Position()
function TPestControl.PlatformCenter(var tpOut: TPoint): Boolean;
var
  platPts: TPointArray;
begin
  platPts := Target.FindColor(2782859, 0, Minimap.Bounds);
  if platPts.Length < (1200 + Biometrics.RandomInteger(100)) then Exit;
  Result := true;
  tpOut := platPts.Mean();
end;

// Decides if we're at the Void Knight, ready to defend
function TPestControl.AtKnight(): Boolean;
var
  platMean, _offSet: TPoint;
begin
  _offSet := Self.Flag.GameKnightOffset.Rotate(Minimap.CompassRadians, [0,0]);
  if not Self.PlatformCenter(platMean) then Exit;
  Result := Distance(Minimap.Center, platMean.Offset(_offSet)) < Self.KnightDistThresh +
    (Time - Self.GameStart) / ONE_MINUTE * (0.5 + Self.LocU[1]);
end;

function TPestControl.AtBoatPlank(pos: TPoint): Boolean;
begin
  Result := Distance(pos, Self.AtPlank) < 7 + 5 * Self.LocU[2];
end;

procedure TPestControl.UpdateAttkDelay();
var
  candidate: UInt64;
begin
  candidate := ExpoGaussRT(Self.Tempo.LowMeanGame);
  if Self.NextAttkDelay > 0 then
  begin
    if Random() < (0.05 + 0.10 * Self.RT[2]) then
      Self.NextAttkDelay := candidate
    else
      Self.NextAttkDelay := Round(Self.Tempo.LowStick * Self.NextAttkDelay
        + (1.0 - Self.Tempo.LowStick) * candidate);
  end else
    Self.NextAttkDelay := candidate;
  if Self.UserDisableHUD then
    Logger.Info('UpdateAttkDelay: %d', [Self.NextAttkDelay]);
end;

procedure TPestControl.UpdateXPAttkDelay();
var
  candidate: UInt64;
begin
  candidate := ExpoGaussRT(Self.Tempo.XPMeanGame);

  if Self.XPAttkDelay > 0 then
  begin
    if Random() < (0.05 + 0.10 * Self.RT[2]) then
      Self.XPAttkDelay := candidate
    else
      Self.XPAttkDelay := Round(Self.Tempo.XPStick * Self.XPAttkDelay
        + (1.0 - Self.Tempo.XPStick) * candidate);
  end else
    Self.XPAttkDelay := candidate;
  if Self.UserDisableHUD then
    Logger.Info('New XP AttackDelay: %d', [Self.XPAttkDelay]);
end;

// Updates last XP time and refreshes XP Attack Delay if needed
procedure TPestControl.UpdateXP();
var
  nXP: UInt64;
begin
  nXP := XPBar.Read;
  if nXP > Self.LastXP then
  begin
    if (Time-Self.LastXPTime) > Self.XPAttkDelay then
      Self.UpdateXPAttkDelay();
    Self.LastXP := nXP;
    Self.LastXPTime := Time;
  end;
end;

// Returns true if Antiban task is due
function TAntiban.TaskDue(): Boolean;
var
  i: Int32;
  activeTasks: PAntibanTaskArray;
begin
  if Self.DoingAntiban then
    Exit(False);

  activeTasks := Self.GetActiveTasks();
  for i := 0 to High(activeTasks) do
    if activeTasks[i]^.Countdown.Remaining = 0 then
      Exit(True);

  Result := False;
end;

// Returns true if a Antiban break is due
function TAntiban.BreakDue(): Boolean;
var
  i: Int32;
  t: UInt64;
begin
  if Self.DoingAntiban then
    Exit(False);

  t := GetTimeRunning();
  for i := 0 to High(Self.Breaks) do
    if t > Self.Breaks[i].Next then
      Exit(True);

  Result := False;
end;

// Returns true if a TAntiban sleep is due
function TAntiban.SleepDue(): Boolean;
var
  i: Int32;
  t: UInt64;
begin
  if Self.DoingAntiban then
    Exit(False);

  t := GetTimeRunning();
  for i := 0 to High(Self.Sleeps) do
    if t > Self.Sleeps[i].Next then
      Exit(True);

  Result := False;
end;


function TPestControl.GetState(): EPestState;
var
  tmpP: TPoint;
begin
  if Activity.IsFinished then
    Exit(EPestState.NO_ACTIVITY);

  if (Self.MaxActions > 0) and (Self.Actions >= Self.MaxActions) then
    Exit(EPestState.MAX_ACTIONS);

  if (Self.MaxTime > 0) and (GetTimeRunning() >= Self.MaxTime) then
    Exit(EPestState.MAX_TIME);

  if not RSClient.IsLoggedIn() then
    Exit(EPestState.LOGIN);

  if Self.CombatLevel < 40 then
    Exit(EPestState.CMBT_LVL);

  if Antiban.TaskDue() then
    Exit(EPestState.ANTIBAN);

  if Antiban.BreakDue() then
    if not Self.InGame() then
      Exit(EPestState.BREAK);

  if Antiban.SleepDue() then
    if not Self.InGame() then
      Exit(EPestState.SLEEP);

  if Self.InBoat() then Exit(EPestState.IN_BOAT);

  if Self.InGame() then
  begin
    if not Self.UserDisableLeaveGame and not Self.Flag.NoLeave and (Self.ReadPortalHP >= 50+199*bhM)
      and (Self.ReadActivityBar() < 1) then
        Exit(EPestState.EXIT_GAME);
    if Self.AtKnight() then Exit(EPestState.DEFEND);
    Exit(EPestState.WALK_MID);
  end;
  tmpP := Map.Position();
  if Self.AtBoatPlank(tmpP) then
  begin
    if Self.UserSpendPoints and (Self.PtsTotal > Self.UserSpendPointsAt) and
      (Self.PtsTotal > Self.PtsPerGame) then
      Exit(EPestState.SPEND_PTS);
    Exit(EPestState.AT_PLANK);
  end;

  if PCData.OutpostIsland.Contains(tmpP) then
    Exit(EPestState.WALK_PLANK);

  result := EPestState.UNKNOWN;
end;

// Decides when we will enable prayer
function TPestControl.PrayerSample(): UInt64;
var
  shape, scale: Double;
begin
  shape := Random(1.4, 1.5) + 1 * Self.P[1];

  scale := 5500 + GaussRand(400,125) + 6000 * Self.P[0];
  scale := scale * (0.8 + (0.4 + Self.P[2]/5) * Random());

  Result := Round(WeibullEx(shape, scale));

  if Self.UserDisableHUD then
    Logger.Info('PrayerSample: %.2fs (k=%.2f, Î»=%.0fms)',
      [Result / 1000.0, shape, scale]);
end;

// Use combat level to setup per game objects/entities
procedure TPestControl.UpdateCmbtLvl();
const
  cbBox: TBox = [661, 229, 682, 244];
begin
  if InRange(Self.UserCombatLevel, 40, 126) then
    Self.CombatLevel := Self.UserCombatLevel
  else if GameTabs.Open(ERSGameTab.COMBAT) then
  begin
    Sleep(ExpoGaussRT(Self.bRT));
    Self.CombatLevel := OCR.RecognizeNumber(cbBox.Expand(3), RSFonts.PLAIN_11, [2070783], 0);
  end;
  Logger.Info('Combat Level: %d', [Self.CombatLevel]);
  XPBar.Read;
  if Self.CombatLevel >= 100 then
  begin
    Self.BoatBox := PCData.Vet.BoatBox;
    Self.AtPlank := PCData.Vet.AtPlank;
    Self.CrossPlank := PCData.Vet.PlankObj;

    Self.Shifter.Finder.ColorClusters += [[
      [$33C1E7, 4.010, EColorSpace.HSL, [1.562, 0.510, 0.930]],
      [$223B53, 0.882, EColorSpace.HSL, [1.421, 1.254, 0.326]],
      3
    ]];
    Self.Shifter.Finder.ColorClusters += [[
      [$B0BBB7, 1.153, EColorSpace.HSL, [0.506, 1.932, 0.563]],
      [$8E848A, 0.757, EColorSpace.HSL, [0.911, 1.517, 0.574]],
      3
    ]];
  end
  else if Self.CombatLevel >= 70 then
  begin
    Self.BoatBox := PCData.Inter.BoatBox;
    Self.AtPlank := PCData.Inter.AtPlank;
    Self.CrossPlank := PCData.Inter.PlankObj;

    //gold and brown shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$243E56, 1.203, EColorSpace.HSL, [1.022, 1.336, 0.644]],
      [$23BEE5, 4.008, EColorSpace.HSL, [1.359, 0.417, 1.226]],
      3
    ]];

    //red and black shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$505061, 1.477, EColorSpace.HSV, [0.737, 1.700, 0.564]],
      [$2133BF, 0.717, EColorSpace.HSL, [1.267, 1.196, 0.539]],
      3
    ]];

    //green shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$137C71, 1.936, EColorSpace.RGB, [0.534, 0.511, 1.957]],
      [$3C5624, 0.965, EColorSpace.HSL, [1.251, 1.181, 0.570]],
      3
    ]];
  end
  else if Self.CombatLevel >= 40 then
  begin
    Self.BoatBox := PCData.Nov.BoatBox;
    Self.AtPlank := PCData.Nov.AtPlank;
    Self.CrossPlank := PCData.Nov.PlankObj;

    //red shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$2234C2, 0.738, EColorSpace.HSL, [1.289, 1.289, 0.424]],
      [$242B76, 0.689, EColorSpace.HSL, [1.510, 0.899, 0.593]],
      3
    ]];
    //green shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$137C71, 1.936, EColorSpace.RGB, [0.534, 0.511, 1.957]],
      [$3C5624, 0.965, EColorSpace.HSL, [1.251, 1.181, 0.570]],
      3
    ]];
  end
  else
    TerminateScript('[INIT] Combat level too low: ' + ToStr(Self.CombatLevel));

  Self.Gangplank := TRSObject.Create(Map.Walker, [1, 1, 1], [Self.CrossPlank], ['Cross Gang']);
end;

procedure TPestControl.MoveInBoat();
var
  boatArea: TBox;
  current, target, mean: TPoint;
  destMS: TQuad;
  r: Double;
  distIdx: Integer;
begin
  Self.CloseSkillInterface();
  if Self.Flag.NoBoatMove then Exit;
  if Time < (Self.LastBoatMove + Self.BoatMoveDelay) then Exit;
  if not Self.InBoat() then Exit;

  boatArea := Self.BoatBox.Expand(Round(-4 + 16 * SampleBeta(2 + 3*Self.B[0], 2 + 3*Self.B[1])));
  current := Map.Position();

  // Sample new position until far enough from self
  repeat
    if not Self.InBoat() then Exit;
    r := SampleBeta(1 + 4*Self.B[2], 1 + 4*(1-Self.B[2]));

    if r < 0.30 then
      mean := [boatArea.Center.X, boatArea.Y2 - boatArea.Height div 4]
    else if r < 0.55 then
      mean := [boatArea.X2 - (current.X - boatArea.X1), boatArea.Y2 - (current.Y - boatArea.Y1)]
    else if r < 0.80 then
    begin
      mean.X := EnsureRange(boatArea.X2 - (Self.AtPlank.X - boatArea.X1), boatArea.X1, boatArea.X2);
      mean.Y := EnsureRange(boatArea.Y2 - (Self.AtPlank.Y - boatArea.Y1), boatArea.Y1, boatArea.Y2);
    end else
      mean := boatArea.RandomPoint();

    target := boatArea.RandomWeightedPoint(mean, 2 + 8*Self.B[3], 0.5 + 1.0*Self.B[4]);

  until (current.DistanceTo(target) > (5 + (Random(3, 5) * Self.B[5])));

  destMS := Map.Walker.GetQuadMS(current, target, [1], Minimap.CompassRadians);
  if not Mainscreen.Bounds.ContainsQuad(destMS) then Exit;

  // Using EMouseDistribution to move to different point in QuadMS
  distIdx := Floor(4 * SampleBeta(1 + 3*Self.B[6], 1 + 3*(1-Self.B[6]))) + 1;
  Mouse.Move(destMS, True, EMouseDistribution(distIdx));
  Sleep(ExpoGaussRT(Self.bRT * RandomLeft(0.5, 3.1)));

  if not Self.InBoat() then Exit;
  if MainScreen.IsUpText('Walk here') then Mouse.Click(EMouseButton.LEFT)
  else if ChooseOption.Open() then ChooseOption.Select('Walk here');

  Sleep(ExpoGaussRT());

  Self.LastBoatMove := Time;
  Self.BoatMoveDelay := Round(WeibullEx(1.3 + 1.2*Self.B[7],
    (8000 + 20000*Self.B[8]) * TruncGauss(1.0, 0.15, 0.7, 1.3)));
end;

procedure TPestControl.WhileInBoat();
begin
  if not Self.UserDisableMoveInBoat then Self.MoveInBoat();
  Sleep(ExpoGaussRT(Self.bRT * RandomLeft(0.5, 4.2)));
end;

// Function copied from WaspLib TRSChat
function TRSChat.ReadPointsOption(): String;
var
  option: TRSChatOption;
begin
  for option in Self.GetOptions([$000080]) do
  begin
    if Result <> '' then Result += LINE_SEP;
    Result += option.Text;
  end;
  result := ToStr(result.ExtractInteger());
end;

// Attempts to decorrelate player decisions made every game
// Should not override user choices
procedure TPestControl.SetPerGame();
var
  driftX, driftY: Int32;
  errRate: Double = 0.0;
begin
  {$IFDEF WL_FATIGUE_INCLUDED}
    errRate := Fatigue.ErrorRate;
  {$ENDIF}
  Self.Flag.NoPray := RandomBoolean(errRate + 0.001347 + 0.026438 * Self.Flag.Choices[0]);
  Self.Flag.NoLeave := RandomBoolean(errRate + 0.00173 + 0.09573 * Self.Flag.Choices[1]);
  Self.Flag.NoBoatMove := RandomBoolean(Power(Self.Flag.Choices[2], 3) * 0.10 * (1 + Self.Flag.Choices[3]));
  Self.Flag.DelayBoatMove := RandomBoolean(0.15 + 0.55 * Power(Self.Flag.Choices[4], 0.7));

  Logger.Info('Self.Flag errRate %.2f', [errRate]);
  Logger.Info('Self.Flag.NoPray: %s', [toStr(Self.Flag.NoPray)]);
  Logger.Info('Self.Flag.NoLeave: %s', [toStr(Self.Flag.NoLeave)]);
  Logger.Info('Self.Flag.NoBoatMove: %s', [toStr(Self.Flag.NoBoatMove)]);
  Logger.Info('Self.Flag.DelayBoatMove: %s', [toStr(Self.Flag.DelayBoatMove)]);

  Self.Deseq.WinThreshGame := TruncGauss(1.0, 0.08, 0.85, 1.15);
  Self.Deseq.InactiveThreshGame := TruncGauss(1.0, 0.08, 0.85, 1.15);
  Self.Deseq.WinNoise := 1.0;
  Self.Deseq.InactiveNoise := 1.0;
  Self.Deseq.LastNoiseReroll := 0;
  Self.Deseq.KnightHPLvl := Random(80, 100);

  driftX := Round(GaussRand(0, 2 + 3 * bhM));
  driftY := Round(GaussRand(0, 2 + 3 * _bhM));
  Self.Flag.GameKnightOffset := Point(driftX, driftY);
  Self.KnightDistThresh := (12 + 4 * Self.locU[0]) * TruncGauss(1.0, 0.10, 0.85, 1.15);
  Self.Shifter.Filter[0].Circle.Radius := Round(Self.KnightDistThresh);
  Self.shifter.Coordinates[0] := PCData.Knight.Offset(Self.Flag.GameKnightOffset);

  Self.Tempo.XPMeanGame := Round(Self.Tempo.XPMean *
    TruncGauss(1.05, 0.07, 0.95, 1.10));
  Self.Tempo.LowMeanGame := Round(Self.Tempo.LowMean *
    TruncGauss(1.05, 0.07, 0.95, 1.10));

  Logger.Info('Self.Tempo.XPMeanGame %d', [Self.Tempo.XPMeanGame]);
  Logger.Info('Self.Tempo.LowMeanGame %d', [Self.Tempo.LowMeanGame]);

  Self.PrayerEnableTime := Self.PrayerSample();
  if Self.Flag.DelayBoatMove then
  begin
    Self.LastBoatMove := Time;
    Self.BoatMoveDelay := Round(WeibullEx(1.3 + 1.2*Self.B[7],
      (8000 + 20000*Self.B[8]) * TruncGauss(1.0, 0.15, 0.7, 1.3)));
    Logger.Info('BoatMoveDelay: %d', [Self.BoatMoveDelay]);
  end;
  Self.ReadPoints();
  Activity.Restart();
  Self.Actions+=1;
  Self.ActivityThresh := EnsureRange(Self.UserActiveThreshold + Round(GaussRand(0, 2.5)), 50, 100);
end;

// Sometimes wait after a game, respects user choice
procedure TPestControl.WaitAfterGame();
var
  baseMult, restPace: Double;
  restTime, restUntil: UInt64;
  checkTask, checkBreak, checkSleep: Boolean;
begin
  if not Self.UserRestAfterGame or SoftRandBool(HashToU('restskip'), 1.5, 0.25) then
  begin
    Sleep(ExpoGaussRT(Self.bRT *  biometrics.RandomModeDouble(2.7,1.5, 4.1)));
    Exit;
  end;

  baseMult := 8.0 + 40.0 * Power(HashToU('restbase'), 0.7 + HashToU('restpow'));
  restTime := EnsureRange(
    SampleRT(Self.bRT * baseMult * TruncGauss(1.0, 0.15, 0.7, 1.4)),
    Self.bRT * 3,
    Self.bRT * 120
  );
  restUntil := Time() + restTime;

  checkTask := not SoftRandBool(HashToU('checkTaskRest'), 2.0, 0.15);
  checkBreak := not SoftRandBool(HashToU('checkBreakRest'), 2.0, 0.25);
  checkSleep := not SoftRandBool(HashToU('checkSleepRest'), 2.0, 0.90);

  Logger.Info('WaitAfterGame: %.2fs (Checking: T=%s|B=%s|S=%s)',
    [restTime / 1000.0, ToStr(checkTask), ToStr(checkBreak), ToStr(checkSleep)]);
  restPace := HashToU('restpace');
  while Time() < restUntil do
  begin
    Antiban.DoAntiban(checkTask, checkBreak, checkSleep);
    Sleep(LogNormalRT(Self.bRT * (3.0 + 7.0 * restPace) * TruncGauss(1.0, 0.1, 0.8, 1.2)));
  end;
end;

procedure TPestControl.EnterBoat();
begin
  Self.CloseSkillInterface();
  Self.WaitAfterGame();

  // Failsafe if script is started with max points
  if Chat.IsTitle('~ Warning ~') then
    TerminateScript('Too many points '+Chat.ReadPointsOption());

  try
    if Self.Gangplank.Click(True, 1 + Round(4*bhM)) then
      if SleepUntil(Self.InBoat, 50, ExpoGaussRT(4000)) then
      begin
        Self.SetPerGame();
        Sleep(ExpoGaussRT(Self.bRT * RandomLeft(1.9, 5.5)));
        if not InRange(Options.GetZoomLevel(True), 30, 50) then
          if Options.SetZoomLevel(RandomMode(35+Round(10*bhM), 30, 50)) then
            WriteLn GetDebugLn('Options', 'Zoom adjusted level: ' + ToString(Options.ZoomLevel), ELogLevel.SUCCESS);
        Exit();
      end;
  except Logger.Error('Exception in EnterBoat: %s', [GetExceptionMessage]); end;
end;

procedure TPestControl.EnablePrayerCheck();
begin
  if (not Self.Flag.NoPray) and Self.UserQuickPrayer and Self.GameStarted and
    (not Minimap.PrayerEnabled) and Self.InGame() and
    (Time > (Self.GameStart + Self.PrayerEnableTime)) and
    (Self.ReadPortalHP > Round(50 + 150*bhM)) then
      if Minimap.EnablePrayer() then
        if Biometrics.RandomBoolean() then
          Sleep(ExpoGaussRT(Self.bRT*(0.3+Biometrics.RandomModeDouble(0.7, 0.01, 4.1))));
end;

procedure TPestControl.WalkToDefend();
var
  uniqueMiddle, midP: TPoint;
  quadMS: TQuad;
  distIdx: Integer;
begin
  Sleep(ExpoGaussRT(Self.bRT * (1.2 + 3.9 *
    SampleBeta(1 + 3*Self.LocU[3], 1 + 3*(1-Self.LocU[3])))));

  {$IFDEF WL_FATIGUE_INCLUDED}
  if Fatigue.ShouldLapse then
    Sleep(LogNormalInt(Self.bRT, 0.35 + 0.1 * Self.RT[0]));
  {$ENDIF}

  if not Self.InGame() then Exit;
  if not Self.GameStarted then
  begin
    Self.GameStarted := True;
    Self.GameStart := Time();
  end;

  Self.EnablePrayerCheck();

  if Self.PlatformCenter(midP) then
  begin
    uniqueMiddle := midP;
    uniqueMiddle.X += Round(-9 + 18 * SampleBeta(1 + 3*Self.LocU[4], 1 + 3*(1-Self.LocU[4])));
    uniqueMiddle.Y += Round(-9 + 18 * SampleBeta(1 + 3*Self.LocU[5], 1 + 3*(1-Self.LocU[5])));
    quadMS := Minimap.Point2MSQuad(uniqueMiddle, [1], Minimap.CompassRadians);
    if Mainscreen.Bounds.ContainsQuad(quadMS) then
    begin
      distIdx := Floor(4 * SampleBeta(1 + 3*Self.LocU[6], 1 + 3*(1-Self.LocU[6]))) + 1;
      Mouse.Click(quadMS, EMouseButton.LEFT, True, EMouseDistribution(distIdx));
      Sleep(ExpoGaussRT(Self.bRT * RandomLeft(0.5, 3.1)));
      if RandomBoolean(0.63+0.30*Self.LocU[7]) and SoftRandBool(Self.LocU[8], 2, 0.95) then
      begin
        Minimap.WaitMoving(Round(Self.bRT*Random(100, 200)));
        Sleep(ExpoGaussRT(Self.bRT*RandomLeft(0.7, 3.1)));
      end else
        Sleep(ExpoGaussRT(Self.bRT*GaussRand(10, 2.5)));
      Exit;
    end;
  end;
  uniqueMiddle := PCData.Knight.Offset(Self.Flag.GameKnightOffset);
  uniqueMiddle.X += Round(-6 + 12 * SampleBeta(1 + 3*Self.LocU[9], 1 + 3*(1-Self.LocU[9])));
  uniqueMiddle.Y += Round(-6 + 12 * SampleBeta(1 + 3*Self.LocU[10], 1 + 3*(1-Self.LocU[10])));
  try
    Logger.Info('Walk to middle: ' + ToStr(Map.Walker.WebWalk(uniqueMiddle, 7+Round(5*Self.LocU[11]), 0.2+0.4*Self.LocU[12])));
  except Logger.Error('WalkToDefend exception: %s', [GetExceptionMessage]); end;
end;

procedure DebugShifterClusters(constref Shifter: TRSEntity);
var
  img: TImage;
  atpa: T2DPointArray;
  coordinates: TPointArray;
  i, totalPixels: Integer;
  avgSize, minSize, maxSize: Integer;
begin
  img := Target.GetImage();

  if Shifter.Find(coordinates, atpa) then
  begin
    WriteLn('=== SHIFTER DETECTION DEBUG ===');
    WriteLn('Found ', Length(atpa), ' potential shifter(s)');
    WriteLn();

    minSize := High(Integer);
    maxSize := 0;
    totalPixels := 0;
    for i := 0 to High(atpa) do
    begin
      WriteLn('Cluster #', i + 1, ':');
      WriteLn('  Coordinate: ', coordinates[i]);
      WriteLn('  Pixel count: ', Length(atpa[i]));
      WriteLn('  Bounds: ', atpa[i].Bounds());
      WriteLn();

      totalPixels += Length(atpa[i]);
      if Length(atpa[i]) < minSize then minSize := Length(atpa[i]);
      if Length(atpa[i]) > maxSize then maxSize := Length(atpa[i]);

      img.DrawColor := $00FF00;
      img.DrawTPA(atpa[i]);
      img.DrawBox(atpa[i].Bounds());
      img.DrawText('Cluster ' + ToStr(i+1) + ': ' + ToStr(Length(atpa[i])) + 'px',
                   atpa[i].Bounds().TopLeft);
    end;

    if Length(atpa) > 0 then
    begin
      avgSize := totalPixels div Length(atpa);
      WriteLn('=== STATISTICS ===');
      WriteLn('Average cluster size: ', avgSize, ' pixels');
      WriteLn('Min cluster size: ', minSize, ' pixels');
      WriteLn('Max cluster size: ', maxSize, ' pixels');
    end;
  end else
    WriteLn('NO SHIFTERS DETECTED');

  img.DrawColor := $00FFFF;
  img.DrawText('ColorClusters: ' + ToStr(Length(Shifter.Finder.ColorClusters)), [10, 30]);
  img.DrawText('Transformer.Distance: ' + ToStr(Shifter.Finder.Transformer.Distance), [10, 50]);
  img.DrawText('Transformer.ShortSide.Min: ' + ToStr(Shifter.Finder.Transformer.ShortSide.Min), [10, 70]);

  img.Show();
end;

// Attempts to use static color of platform
// Map.Position() is used as a backup
function TPestControl.MapPos: TPoint;
var
  radians: Single;
  platMM: TPoint;
begin
  if not Self.PlatformCenter(platMM) then
    Exit(Map.Position());
  radians := Minimap.CompassRadians;
  Result := Self.Center + Minimap.Center - platMM.Rotate(-radians, Minimap.Center);
end;

function TPestControl.FindShifters(out atpa: T2DPointArray): Boolean;
var
  coords: TPointArray;
  bounds: TPolygonArray;
begin
  Result := Self.Shifter.FindEx(Self.MapPos, bounds, coords, atpa);
end;

// Choose sorting strategy
function TPestControl.ChooseStrategy(): EAttackChoice;
var
  r: Double;
begin
  if (Random() < Self.AttackStick) then
    Exit(Self.AttackChoice);
  r := Random();
  if r < Self.AttackWeights[0] then
    Result := EAttackChoice.Self
  else if r < (Self.AttackWeights[0] + Self.AttackWeights[1]) then
    Result := EAttackChoice.Knight
  else
    Result := EAttackChoice.Rand;
end;

// Sort shifters froom Self, Knight or random (no sort needed)
procedure TPestControl.SortByStrategy(strategy: EAttackChoice; var atpa: T2DPointArray);
var
  platMM, knightMS: TPoint;
begin
  if strategy = EAttackChoice.Self then
    atpa := atpa.SortFrom(MainScreen.PlayerBox.Center)
  else if strategy = EAttackChoice.Knight then
  begin
    if Self.PlatformCenter(platMM) then
      knightMS := Minimap.Point2MS(platMM, Minimap.CompassRadians)
    else
      knightMS := MainScreen.Bounds.Center;
    atpa := atpa.SortFrom(knightMS);
  end;
end;

// Choose shifter index wtih personality traits
// Every account should have different patterns
function TPestControl.PickIndex(len: Int32; strategy: EAttackChoice): Int32;
var
  cumulative, r: Double;
  probs: TDoubleArray;
  i: Int32;
begin
  if len = 1 then Exit(0);
  if strategy = EAttackChoice.Rand then Exit(Random(len));

  SetLength(probs, len);

  // Decide to use Exp or Power math for this account
  if Self.attkC[5] > 0.5 then
    for i := 0 to len - 1 do probs[i] := Exp(-Self.LambdaSession * i)
  else
    for i := 0 to len - 1 do probs[i] := 1.0 / Power(i + 1, Self.AlphaSession);

  // Normalize
  cumulative := 0;
  for i := 0 to len - 1 do cumulative += probs[i];
  for i := 0 to len - 1 do probs[i] := probs[i] / cumulative;

  // Sample using cumulative distribution
  r := Random();
  cumulative := 0;
  for i := 0 to len - 1 do
  begin
    cumulative += probs[i];
    if r < cumulative then
      Exit(i);
  end;

  Result := len - 1;
end;

function TPestControl.AttackShifter(): Boolean;
var
  atpa: T2DPointArray;
  strategy: EAttackChoice;
  idx: Int32;
begin
  try
    if not Self.FindShifters(atpa) then Exit(False);
    Sleep(ExpoGaussRT(Self.bRT*0.7));

    {$IFDEF WL_FATIGUE_INCLUDED}
    if Fatigue.ShouldLapse() then
    begin
      Sleep(ExpoGaussRT(Self.bRT*1.8));
      GetDebugLn('Fatigue lapse', ELogLevel.WARN, False);
      if Biometrics.RandomBoolean then
        Exit();
    end;
    {$ENDIF}

    strategy := Self.ChooseStrategy();
    Self.SortByStrategy(strategy, atpa);
    idx := Self.PickIndex(Length(atpa), strategy);

    Mouse.Move(atpa[idx].RandomMean());

    if MainScreen.IsUpText(Self.Shifter.UpText) then
      Result := Biometrics.RedClick(EMouseButton.LEFT);

    if Result then
    begin
      Self.AttackChoice := strategy;
      Self.AttackIndex := idx;
    end;

  except
    Logger.Error('AttackShifter exception: %s', [GetExceptionMessage]);
  end;
end;

// Per-account unique interval to re-roll noise modifiers
// Used to decorrelate when accounts believe they're winning or inactive
procedure TPestControl.RerollDeseqNoise();
begin
  if Time < Self.Deseq.LastNoiseReroll + Self.Deseq.NoiseInterval then Exit;
  Self.Deseq.WinNoise := TruncGauss(1.0, 0.05, 0.9, 1.1);
  Self.Deseq.InactiveNoise := TruncGauss(1.0, 0.07, 0.85, 1.15);
  Self.Deseq.NoiseInterval := Round((3000 + 5000 * Power(Self.Deseq.U[0], 0.5 +
    Self.Deseq.U[1])) * TruncGauss(1.0, 0.15, 0.7, 1.3));
  Self.Deseq.LastNoiseReroll := Time;
end;

// Decides if a palyer believes they're winning
function TPestControl.UserIsWinning(): Boolean;
var
  portalThresh, timeThresh: Double;
  gameTime: UInt64;
  useTime: Boolean;
begin
  Result := False;
  Self.RerollDeseqNoise();

  // Per-account portal threshold: 200-500, power-transformed
  portalThresh := (200 + 300 * Power(Self.Deseq.U[0], 0.5 + 1.5 * Self.Deseq.U[1]))
                * Self.Deseq.WinThreshGame * Self.Deseq.WinNoise;

  // Some accounts factor in game time
  useTime := Self.Deseq.U[2] > 0.6;
  gameTime := Time - Self.GameStart;

  if useTime then
  begin
    // Time-based: game > 80-100s AND portals below threshold
    timeThresh := 80000 + 20000 * Self.Deseq.U[2];
    Result := (gameTime > timeThresh) and (Self.ReadPortalHP < portalThresh);
  end
  else
    Result := Self.ReadPortalHP < portalThresh;

  // Knight safety factor: some accounts also check knight HP
  if Result and (Self.Deseq.U[3] > 0.5) then
    Result := Self.ReadKnightHP > 50 + Round(Self.Deseq.KnightHPLvl * Self.Deseq.U[3]);
end;

// Decides if a palyer believes they're inactive
function TPestControl.UserIsInactive(): Boolean;
var
  source: UInt64;
  thresh: Double;
begin
  Result := False;
  Self.RerollDeseqNoise();

  // Per-account source: LastAttack vs LastXPTime
  if Self.Deseq.U[4] < 0.5 then
    source := Time - Self.LastAttack
  else
    source := Time - Self.LastXPTime;

  // Per-account threshold: 4-15s, power-transformed
  thresh := (4000 + 11000 * Power(Self.Deseq.U[5], 0.5 + 1.5 * Self.Deseq.U[6]))
          * Self.Deseq.InactiveThreshGame * Self.Deseq.InactiveNoise;

  Result := source > thresh;
end;

// Emote help
// Use: Self.eHelper();
procedure TPestControl.eHelper(emoteList: TIntegerArray);
var
  i, limit: Integer;
begin
  if Time() < (Self.LastEmoteMS + Self.EmoteDelayMS) then
    Exit();
  limit := Self.UserEmoteAmount;
  for i := 0 to limit do
  begin
    Emotes.UseEmote(ERSEmote(emoteList.Random));
    // Different players mean sleep, 2s to 6s, expogaussianRT?
  end;
  // then do emote and set last emote time
  // for i := something down to 0 do
  // decay. powerlaw, idk what, every account has different max, every accounts min is 1, all have different means?
  // what is healthiest?
  // Self.UserEmoteAmount
  Self.LastEmoteMS := Time();
end;

// Screenwalking durring game
procedure TPestControl.PaceInGame();
begin
  if Self.UserDisablePace then Exit();
  Self.WalkToDefend();
  Sleep(ExpoGaussRT(Self.bRT*3*_bhM));
end;

// Activiies to do when chilling, User controls choice to relax or not
procedure TPestControl.ChillActivities();
var
  t: Int64 = 0;
begin
  if not Self.UserChillIfActive then Exit();
  if Self.ReadActivityBar > Self.ActivityThresh then
    t := Time() + ExpoGaussRT(Self.XPAttkDelay)
  else
    Exit();

  //t can be based off player's last XPAttackDelay so it is relatively
  //in tempo, but it can be further decorrelated if needed
  while (t > Time()) and Self.InGame() do
  begin
    Sleep(ExpoGaussRT(Self.bRT));
    //randomized order of chill activities
    //what antiban we check can decorrelate accounts
    //some dont even check at all
    //Antiban.DoAntiban(false, false, false);

    //maybe some/most/all/sometimes accounts should add more time
    //if still above threshold instead of exiting to defend
    if (Self.ReadActivityBar > Self.ActivityThresh) and
      ((t - Time()) < Self.bRT) then
        t := Time() + ExpoGaussRT(Self.NextAttkDelay);
  end;
  //maybe change activityThresh mid game, maybe a better way

  if Biometrics.RandomBoolean() then
    Self.ActivityThresh := EnsureRange(Self.UserActiveThreshold +
      Round(GaussRand(0, 2.5)), 50, 100);
end;

// Activities to perform when inactive
procedure TPestControl.InactiveActivities();
begin
  // No user choice for inactive
  // Maybe add ability to disable inactive activies as user choice

  //if Self.FindShifters(atpa) then Exit();
end;

// Procedure to desequence in-game patterns
function TPestControl.Desequence(): Boolean;
begin
  Result := False;
  Self.ChillActivities();
  //respecting user choices, de-sequence accounts
end;

// The knight really sucks at defending himself... HELP!
procedure TPestControl.DefendKnight();
begin
  Sleep(ExpoGaussRT(Self.bRT*0.8));
  Self.UpdateXP();
  if (Time - Self.LastXPTime) < Self.XPAttkDelay then Exit;
  if (Time - Self.LastAttack) < Self.NextAttkDelay then Exit;
  if not Self.InGame() then Exit;
  if Biometrics.RandomBoolean() then
    Self.EnablePrayerCheck();

  if Self.Desequence() then
    if Biometrics.RandomBoolean() then
      Exit();

  if Self.AttackShifter() then
  begin
    Activity.Restart();
    Self.LastAttack := Time;
    Self.UpdateAttkDelay();
    Sleep(ExpoGaussRT(Self.bRT*2.2));
  end;
  Self.EnablePrayerCheck();
end;

procedure TPestControl.LeaveTheGame();
begin
  if not Self.InGame() then Exit;
  Sleep(ExpoGaussRT(Self.bRT * 3.3));
  if not Self.InGame() then Exit;
  try
    Writeln('Distance to Squire: ', Self.Squire.DistanceTo(Map.Position()));
    if not Self.InGame() then Exit;
    if Self.Squire.DistanceTo(Map.Position()) > (8+Random(4)+Round(5*bhM)) then
      if Map.Walker.WebWalk(Self.Squire.Coordinates[0].Offset(Random(-5, 5),
        Random(5, 10)), 3+Round(3*(bhM)), 0.2+0.5*bhM) then
          Writeln('Walked towards Squire');
    if not Self.InGame() then Exit;
    if Self.Squire.Interact(['Leave Squire', 'eave Squire'], 2+Round(3*bhM)) then
    begin
      Self.LeaveGameCount+=1;
      WriteLn('Left game at ', FormatMilliseconds(GetTimeRunning, TIME_SHORT));
      SleepUntil(not Self.InGame(), Round(Self.bRT+Random(400)), Round(Self.bRT * Random(75, 125)));
    end else
      Writeln('Failed to leave game');
  except Writeln('TPestControl.LeaveTheGame - ', GetExceptionMessage); end;
end;

// Enable prayer check and walking failsafes
procedure TPestControl.OnWalkerEvent(walker: PRSWalker; position, destination: TPoint);
begin
  if (PCData.GameIsland.Contains(position) and PCData.OutpostIsland.Contains(destination)) or
    (PCData.OutpostIsland.Contains(position) and PCData.GameIsland.Contains(destination)) then
      begin
        walker^.Walking := False;
        {$IFDEF WL_FATIGUE_INCLUDED}
        if Fatigue.ShouldLapse then
          Sleep(ExpoGaussRT(Self.bRT*RandomLeft(1.1, 6.7)));
        {$ELSE}
          Sleep(ExpoGaussRT());
        {$ENDIF}
        Exit;
      end;
  if (Self.State = EPestState.WALK_MID) then
    Self.EnablePrayerCheck();
  Self.UpdateAndDrawHUD();
end;

// Initiates player's attack tempo profile
// Two thresholds exit, in combat and out of combat
procedure TPestControl.SetAttackTempo();
var
  bhInt: Int32;
  xpVar, lowVar: Double;
begin
  bhInt := Trunc(bhM * 1000);

  // Session variance (Â±8%)
  xpVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);
  lowVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);

  Self.Tempo.XPMean := Round((2573 + 990 * bhM) * xpVar);
  Self.Tempo.XPStick := 0.20 + 0.18 * ((bhInt shr 5) mod 1000 / 1000.0);
  Self.XPAttkDelay := ExpoGaussRT(Self.Tempo.XPMean);

  Self.Tempo.LowMean := Round((750 + 350 * _bhM) * lowVar);
  Self.Tempo.LowStick := 0.20 + 0.18 * (((bhInt shr 5) xor 913) mod 1000 / 1000.0);
  Self.NextAttkDelay := ExpoGaussRT(Self.Tempo.LowMean);

  Self.Tempo.XPMeanGame := Round(Self.Tempo.XPMean *
    TruncGauss(1.0, 0.07, 0.85, 1.15));
  Self.Tempo.LowMeanGame := Round(Self.Tempo.LowMean *
    TruncGauss(1.0, 0.07, 0.85, 1.15));

  Logger.Info('Self.Tempo.XPMeanGame %d', [Self.Tempo.XPMeanGame]);
  Logger.Info('Self.Tempo.LowMeanGame %d', [Self.Tempo.LowMeanGame]);
  Logger.Info('SetAttackTempo() XP: %dms(x%.2f) Low: %dms(x%.2f)',
    [Self.Tempo.XPMean, xpVar, Self.Tempo.LowMean, lowVar]);
end;

procedure TStateTimer.Add(State: EPestState; Ms: UInt64);
begin
  Self.Times[State] := Self.Times[State] + Ms;
end;

procedure TStateTimer.LogAll();
var
  State: EPestState;
begin
  WriteLn('=== State Time Report ===');
  for State := Low(EPestState) to High(EPestState) do
    if Self.Times[State] > 0 then
      WriteLn(PadR(ToStr(State), 15), ' : ', FmtTime(Self.Times[State]));
end;

procedure TPestControl.OnBreakStart(task: PBreakTask);
begin
  {$IFDEF WL_FATIGUE_INCLUDED}
  if not Self.UserDisableFatigue then
    Logger.Info('Break starting - Fatigue: %.2f%%', [Fatigue.FatigueLevel * 100]);
  {$ENDIF}
  Logger.Info('Break starting: ' + FormatMilliseconds(Round(task^.Length), TIME_FORMAL));
end;

procedure TPestControl.OnSleepStart(task: PSleepTask);
begin
  {$IFDEF WL_FATIGUE_INCLUDED}
  if not Self.UserDisableFatigue then
    Logger.Info('Sleep starting - Fatigue: %.2f%%', [Fatigue.FatigueLevel * 100]);
  {$ENDIF}
  Logger.Info('Sleep starting: ' + FormatMilliseconds(Round(task^.Length), TIME_FORMAL));
end;

procedure TPestControl.OnBreakEnd(task: PBreakTask);
begin
  Activity.Restart();
  Logger.Info('Break of ' + FormatMilliseconds(Round(task^.Length), TIME_FORMAL) + ' ended');
end;

procedure TPestControl.OnSleepEnd(task: PSleepTask);
begin
  Activity.Restart();
  Logger.Info('Sleep of ' + FormatMilliseconds(Round(task^.Length), TIME_FORMAL) + ' ended');
end;

procedure TPestControl.OnBreakingHud(task: PBreakTask; var countdown: TCountdown);
begin
  Self.UpdateAndDrawHUD(True, False, countdown.Remaining, True);
end;

procedure TPestControl.OnSleepingHud(task: PSleepTask; var countdown: TCountdown);
begin
  Self.UpdateAndDrawHUD(False, True, countdown.Remaining, True);
end;

procedure TPestControl._OnPause();
begin
  WriteLn ProgressReport.Generate(ProgressReport.ValueProvider());
  RSClient.EnableRealInput();
  RSClient.Canvas.Clear();
end;

procedure TPestControl._OnResume();
begin
  RSClient.DisableRealInput();
end;


procedure TPestControl._OnTermination();
begin
  WriteLn ProgressReport.Generate(ProgressReport.ValueProvider());
  Self.StateTimer.Add(Self.State, Time - Self.StateT);
  Self.StateTimer.LogAll();
  Writeln('STATE ON TERMINATION: '+ToStr(Self.State));
  RSClient.Canvas.Clear;
  RSClient.EnableRealInput();
end;

// Populates record with PC game data
procedure TPestControlGameData.InitPCData();
begin
  Self.GameIsland := [10498, 39938, 10749, 40189];
  Self.OutpostIsland := [10501, 39700, 10736, 39916];


  Self.Nov.AtPlank := [10630, 39874];
  Self.Nov.PlankObj := [10633, 39874];
  Self.Nov.BoatBox := [10640, 39856, 10655, 39879];

  Self.Inter.AtPlank := [10578, 39854];
  Self.Inter.PlankObj := [10572, 39854];
  Self.Inter.BoatBox := [10552, 39840, 10567, 39863];

  Self.Vet.AtPlank := [10554, 39818];
  Self.Vet.PlankObj := [10548, 39818];
  Self.Vet.BoatBox := [10524, 39810, 10544, 39838];

  Self.Portals.W := [];
  Self.Portals.SW := [];
  Self.Portals.SE := [];
  Self.Portals.E := [];

  Self.Knight := [10626, 40061];
  Self.Spawn := [10632, 39994];
  Self.LeaveNPC := [10620, 40002];

  Self.OCR.ActivBox := [365, 121, 511, 131];
  Self.OCR.PointsBox := [72, 64, 123, 81];
  Self.OCR.ActivGreen := 40704;
  Self.OCR.ActivRed := 255;

  PCData.OCR.W := [370, 53, 396, 68];
  PCData.OCR.E := [406, 53, 434, 68];
  PCData.OCR.SE := [445, 53, 470, 68];
  PCData.OCR.SW := [484, 53, 507, 68];

  Self.OCR.Shield_W := [367, 91, 397, 91];
  Self.OCR.Shield_E := [403, 91, 434, 91];
  Self.OCR.Shield_SE := [441, 91, 472, 91];
  Self.OCR.Shield_SW := [479, 91, 510, 91];

  Self.OCR.KnightHP := [34, 39, 61, 54];
end;

// Initiates players attack choice profle
// Unrelated to attack tempo profile
procedure TPestControl.InitAttackProfile();
var
  baseWeights: array[0..2] of Double;
  i: Int32;
  total: Double;
begin
  Self.attkC.CreateU(['profileU', 'selfU', 'knightU', 'randU', 'stickU', 'decayType', 'decayParam', 'powerLaw']);

  Self.LambdaSession := (0.3 + 1.7 * Self.attkC[6]) * TruncGauss(1.0, 0.08, 0.85, 1.15);
  Self.AlphaSession := (0.5 + 1.5 * Self.attkC[7]) * TruncGauss(1.0, 0.08, 0.85, 1.15);
  if Self.attkC[0] < 0.5 then
    baseWeights := [55.0, 40.0, 5.0]  // Self-primary
  else
    baseWeights := [40.0, 55.0, 5.0]; // Knight-primary

  total := 0;
  for i := 0 to 2 do
  begin
    Self.AttackWeights[i] := baseWeights[i] * (0.67 + 0.66 * Self.attkC[i+1]);
    Self.AttackWeights[i] *= EnsureRange(GaussRand(1.0, 0.04), 0.84, 1.16);
    total += Self.AttackWeights[i];
  end;

  for i := 0 to 2 do
    Self.AttackWeights[i] := Self.AttackWeights[i] / total;

  Self.AttackStick := 0.15 + 0.25 * Self.attkC[4];
  Self.AttackStick *= EnsureRange(GaussRand(1.0, 0.025), 0.925, 1.075);

  if Self.AttackWeights[0] > Self.AttackWeights[1] then
    Self.AttackChoice := EAttackChoice.Self
  else
    Self.AttackChoice := EAttackChoice.Knight;

  Logger.Info('Attack Profile - Self:%.1f%% Knight:%.1f%% Rand:%.1f%% Stick:%.1f%%',
    [Self.AttackWeights[0]*100, Self.AttackWeights[1]*100, Self.AttackWeights[2]*100, Self.AttackStick*100]);
end;

// Set each player with different mouse settings
procedure TPestControl.SetupMouse();
var
  speedBase, gravBase, windBase: Double;
  clickMinBase, clickMaxBase: Int32;
  speedVar, gravVar, windVar, clickVar: Double;
begin
  Self.M.CreateU(['speed', 'gravity', 'wind', 'click min', 'click max', 'miss chance']);

  // Base values
  speedBase := 10.0 + 4.0 * Self.M[0];
  gravBase := 7.0 + 4.0 * Self.M[1];
  windBase := 3.0 + 4.0 * Self.M[2];
  clickMinBase := 50 + Round(30.0 * Self.M[3]);
  clickMaxBase := 120 + Round(80.0 * Self.M[4]);

  // Session variance (Â±8%)
  speedVar := TruncGauss(1.0, 0.04, 0.88, 1.12);
  gravVar := TruncGauss(1.0, 0.04, 0.88, 1.12);
  windVar := TruncGauss(1.0, 0.04, 0.88, 1.12);
  clickVar := TruncGauss(1.0, 0.04, 0.88, 1.12);

  Mouse.Speed := speedBase * speedVar;
  Mouse.Gravity := gravBase * gravVar;
  Mouse.Wind := windBase * windVar;
  Mouse.PressMin := Round(clickMinBase * clickVar);
  Mouse.PressMax := Round(clickMaxBase * clickVar);

  Mouse.MissChance := 0.01 + 0.03 * Self.M[5];

  Logger.Info('Mouse - Speed:%.2f Grav:%.2f Wind:%.2f Click:%d-%dms Miss:%.2f%%',
    [Mouse.Speed, Mouse.Gravity, Mouse.Wind, Mouse.PressMin, Mouse.PressMax, Mouse.MissChance*100]);
end;

// Monolithic init procedure. Im embarassed and need to clean this up
// Basically a trashcan, i just throw junk in...
procedure TPestControl.Init();
begin
  WriteLn('[INIT] Pest Control - SIMBA2000');
  Logger.Setup('Pest Control JDS');
  Logger.RepeatedMessages := True;
  if PestControl.UserSpendPoints then
    Logger.Success('We''ll spend our points at %d', [PestControl.UserSpendPointsAt]);
  PCData.InitPCData();
  bhM.CreateU('bhM');
  Self.Flag.Choices.CreateU(['NoPray', 'NoLeave', 'NoBoatMove1', 'NoBoatMove2',
    'DelayBoatMove', 'BoatBehavior']);
  _bhM.CreateU('_bhM');
  Self.B.CreateU(['boat111', 'boat222', 'boat333', 'boat444', 'boat555', 'boat666',
    'boat777', 'boat888', 'boat999']);
  Self.P.CreateU(['U_Prayer1', 'U_Prayer2', 'U_Prayer3']);
  Self.RT.CreateU(['RT_U1', 'RT_U2', 'RTC_U', 'LogNormal', 'Weibull', 'rtdist0', 'rtdist1']);
  Self.LocU.CreateU(['LocAtKnight1', 'LocAtKnight2', 'LocAtPlank', 'WalkToDefend111',
    'WalkToDefend222', 'WalkToDefend333', 'WalkToDefend444', 'WalkToDefend555',
    'WalkToDefend666', 'WalkToDefend777', 'WalkToDefend888', 'WalkToDefend999',
    'WalkToDefend101010']);
  Self.Deseq.U.CreateU(['win_portal_base', 'win_portal_curve', 'win_use_time', 'win_knight_factor',
                   'inactive_source', 'inactive_base', 'inactive_curve']);
  Self.Deseq.NoiseInterval := 3000 + Round(5000 * Power(Self.Deseq.U[0], 0.5 + Self.Deseq.U[1]));
  Self.Deseq.KnightHPLvl := Random(80, 100);

  self.bRT := Round(TruncGauss(200, 30, 173, 227) + 123
    * bhM * TruncGauss(1.0, 0.05, 0.85, 1.15));

  {$IFDEF WL_FATIGUE_INCLUDED}
  if not Self.UserDisableFatigue then
  begin
    Fatigue.Debugging := True;
    Fatigue.Setup();
  end;
  {$ENDIF}

  ProgressReport.Setup(
    'Pest Control JDS',
    [
      'Total   runtime:', 'Active  runtime:', 'Antiban runtime:',
      'Next sleep:', 'Games Won:', 'Wins/Hour:', 'Points Earned:',
      'Points/Hour:', 'Actions:'
    ],
    @Self.GetReportValues,
    Round(ONE_MINUTE*2.5)
  );

  // Hook all the things for all the actions
  Antiban.OnBreaking := @Self.OnBreakingHud;
  Antiban.OnSleeping := @Self.OnSleepingHud;
  Antiban.OnStartBreak := @Self.OnBreakStart;
  Antiban.OnStartSleep := @Self.OnSleepStart;
  Antiban.OnFinishBreak := @Self.OnBreakEnd;
  Antiban.OnFinishSleep := @Self.OnSleepEnd;
  AddOnTerminate(@Self._OnTermination);
  AddOnPause(@Self._OnPause);
  AddOnResume(@Self._OnResume);

  Self.SetupMouse();

  Self.InitAttackProfile();
  Self.SetAttackTempo();
  Self.KnightDistThresh := (12 + 4 * Self.locU[0]) * TruncGauss(1.0, 0.10, 0.85, 1.15);
  Self.ActivityThresh := EnsureRange(Self.UserActiveThreshold+Random(-7, 7), 50, 100);
  Self.PrayerEnableTime := Self.PrayerSample();

  Map.Setup([Chunk(Box(40,41,41,41), 0)]); // Outpost island with boats and rewards
  Map.Add([Chunk(Box(41,40,41,40), 0)]); // Game island
  Map.Walker.OnWaitMovingEvent := @Self.OnWalkerEvent;
  Map.Walker.OnWalkEvent := @Self.OnWalkerEvent;
  Map.Walker.TargetUpText := ['tack Shifter', 'Attack Shifter'];
  Self.Center := PCData.Knight.Offset(2, 0);
  Self.Squire := TRSEntity.Create(Map.Walker, [1, 1, 4], 5, [PCData.LeaveNPC], ['to Squire', 'Talk-to'], [ERSMinimapDot.NPC]);
  Self.Shifter := TRSEntity.Create(
    Map.Walker,
    [1, 1, 1],
    14 + Round(3*bhM),
    [PCData.Knight],
    ['tack Shifter', 'Attack Shifter'],
    [ERSMinimapDot.NPC]
  );

  // Initialize stats
  Self.Start := Time;
  Self.GameStart := Time;
  Self.GamesWon := -1;
  Self.PtsTotal := -1;
  Self.PtsStart := -1;
  Self.CombatLevel := -1;
  
  // Antiban setup
  Antiban.Zoom.Min := 30;
  Antiban.Zoom.Max := 50;
  Antiban.Skills := [ERSSkill.RANGED, ERSSkill.MAGIC, ERSSkill.PRAYER, ERSSkill.ATTACK, ERSSkill.STRENGTH, ERSSkill.DEFENCE, ERSSkill.TOTAL];

  Activity.Restart();

  PestShop.Setup();

  WriteLn('[INIT] Initialization complete');
end;

procedure TPestControl.Run();
var
  nState, sBeforeAntiban: EPestState;
  tRand: Int32;
  JustDidAntiban: Boolean;
begin
  Self.Init();
  tRand := Round(Random(0, 80+100*bhM));
  Profiles[ProfileIndex].Worlds := [344];

  Self.State := EPestState.INIT;
  sBeforeAntiban := EPestState.INIT;
  JustDidAntiban := False;

  repeat
    nState := Self.GetState();

    if nState <> Self.State then
    begin
      {$IFDEF WL_FATIGUE_INCLUDED}
      Fatigue.Update();
      if RandomBoolean(0.2) then Fatigue.DebugPrint();
      {$ENDIF}
      if Self.State <> EPestState.INIT then
        Self.StateTimer.Add(Self.State, Time - Self.StateT);

      if nState = EPestState.ANTIBAN then
      begin
        // Only save if interrupted state is gameplay state
        if Self.State in [EPestState.IN_BOAT, EPestState.WALK_MID,
                          EPestState.DEFEND, EPestState.AT_PLANK,
                          EPestState.EXIT_GAME] then
          sBeforeAntiban := Self.State
        else
          sBeforeAntiban := EPestState.UNKNOWN;
      end
      else if JustDidAntiban then
      begin
        if sBeforeAntiban <> EPestState.UNKNOWN then
          Self.StateTimer.Add(sBeforeAntiban, Time - Self.StateT);
        JustDidAntiban := False;
      end;

      Self.StateT := Time;
      Self.State := nState;
      Self.UpdateAndDrawHUD(False, False, 0, True);
      Logger.Info('[STATE] ' + ToStr(Self.State));
    end
    else
    begin
      Self.State := nState;
      Self.UpdateAndDrawHUD();
    end;

    ProgressReport.Print();

    case Self.State of
      EPestState.UNKNOWN:
        begin
          Sleep(LogNormalInt(500, 0.35));
          Writeln('[UNKNOWN STATE]', FormatMilliseconds(Logger.TimeRunning.Elapsed, TIME_SHORT));
        end;

      EPestState.LOGIN: Login.DoLogin();
      EPestState.CMBT_LVL: Self.UpdateCmbtLvl();

      EPestState.ANTIBAN:
        begin
          Antiban.DoTask();
          JustDidAntiban := True;
        end;

      EPestState.BREAK: Antiban.DoBreak();
      EPestState.SLEEP: Antiban.DoSleep();

      EPestState.IN_BOAT: Self.WhileInBoat();
      EPestState.WALK_MID: Self.WalkToDefend();
      EPestState.DEFEND: Self.DefendKnight();
      EPestState.EXIT_GAME: Self.LeaveTheGame();
      EPestState.SPEND_PTS: Self.SpendPestPoints();
      EPestState.AT_PLANK: Self.EnterBoat();
      EPestState.WALK_PLANK: Map.Walker.WalkBlind(Self.AtPlank, 0);

      EPestState.NO_ACTIVITY, EPestState.MAX_ACTIONS,
      EPestState.MAX_TIME, EPestState.END_SCRIPT: Exit;
    end;
  until (Self.PtsTotal > (3800 + tRand));

  Writeln('Total Points: ', Self.PtsTotal, ' is more than: ', 3800 + tRand);
  WriteLn('[COMPLETE] Thank you for using Pest Control JDS');
  Self.StateTimer.LogAll();
end;

type
  TPCForm = record
    form: TScriptForm;
    config: TConfigJSON;

    AutoStartTimer: TLazTimer;
    CountdownLabel: TLazLabel;
    TimerStartTime: UInt64;
    DisplayTimer: TLazTimer;

    ChkQuickPrayer,
    ChkChillIfActive,
    ChkDisableFatigue,
    ChkDisableHUD,
    ChkDisableMoveInBoat,
    ChkDisablePace,
    ChkDisableLeaveGame,
    ChkRestAfterGame,
    ChkDisableInactive: TLazCheckBox;

    EditPointsPerWin,
    EditSpendPointsAt,
    EditCombatLevel,
    EditActiveThreshold,
    EditRewardAmount: TLazSpinEdit;

    ComboUserRewards: TLazComboBox;

    // Emotes
    EditEmoteInactive,
    EditEmoteChilling,
    EditEmoteWinning: TLazSpinEdit;

    EditEmoteMinS,
    EditEmoteMaxS: TLazFloatSpinEdit;

    UserListInactive,
    UserListChilling,
    UserListWinning: TIntegerArray;

    UserMemoInactive,
    UserMemoChilling,
    UserMemoWinning: TLazMemo;

    CheckListInactive,
    CheckListChilling,
    CheckListWinning: TLazListBox;

    btnClearAllEmotes: TLazButton;
  end;
const
  EMOTE_NAMES: TStringArray =[
    'Yes','No','Bow','Angry',
    'Think','Wave','Shrug','Cheer',
    'Beckon','Laugh','Jump for Joy','Yawn',
    'Dance','Jig','Spin','Headbang',
    'Cry','Blow Kiss','Panic','Raspberry',
    'Clap','Salute','Goblin Bow','Goblin Salute',
    'Glass Box','Climb Rope','Lean','Glass Wall',
    'Idea','Stamp','Flap','Slap Head',
    'Zombie Walk','Zombie Dance','Scared','Rabbit Hop',
    'Sit up','Push up','Star jump','Jog',
    'Flex','Zombie Hand','Hypermobile Drinker','Skill Cape',
    'Air Guitar','Uri transform','Smooth dance','Crazy dance',
    'Premier Shield','Explore','Relic unlock','Party',
    'Trick','Fortis Salute','Sit down','Crab dance'
  ];
var
  GUI: TPCForm;

procedure OnAnyInteraction(sender: TLazObject);
begin
  if GUI.AutoStartTimer <> nil then
  begin
    GUI.AutoStartTimer.Enabled := False;
    GUI.AutoStartTimer.Free();
    GUI.AutoStartTimer := nil;
  end;
  if GUI.DisplayTimer <> nil then
  begin
    GUI.DisplayTimer.Enabled := False;
    GUI.DisplayTimer.Free();
    GUI.DisplayTimer := nil;
  end;
  if GUI.CountdownLabel <> nil then
  begin
    GUI.CountdownLabel.Free();
    GUI.CountdownLabel := nil;
  end;
end;

procedure OnTimerTick(sender: TLazObject);
begin
  GUI.AutoStartTimer.Enabled := False;
  WriteLn('[AUTO-START] Starting script');
  GUI.Form.Start.Click();
end;

procedure UpdateCountdown(sender: TLazObject);
var
  elapsed, remaining: Int32;
begin
  elapsed := (Time - GUI.TimerStartTime) div 1000;
  remaining := AUTO_START_DELAY - elapsed;

  if remaining > 0 then
    GUI.CountdownLabel.Caption := 'Auto-start in ' + ToStr(remaining) + 's'
  else
    GUI.CountdownLabel.Caption := 'Starting...';
end;


procedure StartAutoTimer(sender: TLazObject);
var
  bottomPanel: TLazPanel;
begin
  GUI.TimerStartTime := Time;

  GUI.AutoStartTimer := TLazTimer.Create(GUI.Form.Form);
  GUI.AutoStartTimer.Interval := AUTO_START_DELAY*ONE_SECOND;
  GUI.AutoStartTimer.OnTimer := @OnTimerTick;
  GUI.AutoStartTimer.Enabled := True;

  GUI.DisplayTimer := TLazTimer.Create(GUI.Form.Form);
  GUI.DisplayTimer.Interval := 1000;
  GUI.DisplayTimer.OnTimer := @UpdateCountdown;
  GUI.DisplayTimer.Enabled := True;

  bottomPanel := TLazPanel(GUI.Form.Start.Parent);

  GUI.CountdownLabel := TLazLabel.CreateEx(bottomPanel);
  GUI.CountdownLabel.Caption := 'Auto-start in ' + ToStr(AUTO_START_DELAY) + 's';
  GUI.CountdownLabel.Font.Size := 9;
  GUI.CountdownLabel.Font.Color := $0000FF;  // Red
  GUI.CountdownLabel.Transparent := True;
  GUI.CountdownLabel.Left := GUI.Form.Start.Left - 100;
  GUI.CountdownLabel.Top := (bottomPanel.Height - 16) div 2;
  GUI.CountdownLabel.Width := 100;
  GUI.CountdownLabel.Height := 16;
end;

procedure TScriptForm.OnStart(sender: TLazObject); override;
var
  GoalT, GoalA: UInt64;
begin
  inherited;
  RSClient.DisableRealInput();
  GoalA := Self.Goals.Actions.Value;
  GoalA := GoalA + Round(Random(GoalA*-0.13, GoalA*0.23));
  PestControl.MaxActions := GoalA;
  GoalT := Self.Goals.Time.Value * ONE_MINUTE;
  GoalT := GoalT + Round(Random(GoalT*-0.13, GoalT*0.23));
  PestControl.MaxTime := GoalT;

  PestControl.UserQuickPrayer := GUI.ChkQuickPrayer.IsChecked();
  PestControl.UserChillIfActive := GUI.ChkChillIfActive.IsChecked();
  PestControl.UserActiveThreshold := GUI.EditActiveThreshold.Value;
  PestControl.PtsPerGame := GUI.EditPointsPerWin.Value;
  PestControl.UserDisableHUD := GUI.ChkDisableHUD.IsChecked();
  PestControl.UserDisableMoveInBoat := GUI.ChkDisableMoveInBoat.IsChecked();
  PestControl.UserDisablePace := GUI.ChkDisablePace.IsChecked();
  PestControl.UserDisableLeaveGame := GUI.ChkDisableLeaveGame.IsChecked();
  PestControl.UserCombatLevel := GUI.EditCombatLevel.Value;
  PestControl.UserDisableFatigue := GUI.ChkDisableFatigue.IsChecked();
  PestControl.UserSpendPointsAt := Gui.EditSpendPointsAt.Value;
  PestControl.UserDisableInactive := GUI.ChkDisableInactive.IsChecked();
  PestControl.UserRestAfterGame := GUI.ChkRestAfterGame.IsChecked();
  PestControl.UserReward := GUI.ComboUserRewards.Text;
  PestControl.UserRewardAmount := GUI.EditRewardAmount.Value;
  PestControl.UserEmoteListI := GUI.UserListInactive;
  PestControl.UserEmoteListC := GUI.UserListChilling;
  PestControl.UserEmoteListW := GUI.UserListWinning;
  PestControl.UserEmoteInactive := PestControl.UserEmoteListI.Length > 0;
  PestControl.UserEmoteChilling := PestControl.UserEmoteListC.Length > 0;
  PestControl.UserEmoteWinning := PestControl.UserEmoteListW.Length > 0;

  PestControl.UserSpendPoints := (PestControl.UserSpendPointsAt > PestControl.PtsPerGame)
    and (PestControl.UserReward <> '') and (PestControl.UserRewardAmount <> 0);

  writeln(PestControl.UserReward);
  writeln(PestControl.UserRewardAmount);

  GUI.config.SetConfig('goal_actions', Self.Goals.Actions.Value);
  GUI.config.SetConfig('goal_time', Self.Goals.Time.Value);
  GUI.config.SetConfig('quick_prayer', PestControl.UserQuickPrayer);
  GUI.config.SetConfig('chill_if_active', PestControl.UserChillIfActive);
  GUI.config.SetConfig('active_threshold', PestControl.UserActiveThreshold);
  GUI.config.SetConfig('points_per_win', PestControl.PtsPerGame);
  GUI.config.SetConfig('disable_hud', PestControl.UserDisableHUD);
  GUI.config.SetConfig('disable_move_in_boat', PestControl.UserDisableMoveInBoat);
  GUI.config.SetConfig('disable_pace', PestControl.UserDisablePace);
  GUI.config.SetConfig('disable_leave_game', PestControl.UserDisableLeaveGame);
  GUI.config.SetConfig('disable_fatigue', PestControl.UserDisableFatigue);
  GUI.config.SetConfig('combat_level', PestControl.UserCombatLevel);
  GUI.config.SetConfig('disable_inactive', PestControl.UserDisableInactive);
  GUI.config.SetConfig('rest_after_game', PestControl.UserRestAfterGame);

  GUI.config.Save();
end;

procedure OnInactiveEmoteClick(sender: TLazObject);
var
  idx, i: Integer;
begin
  idx := TLazListBox(sender).ItemIndex;
  if GUI.UserListInactive.Length >= 100 then Exit;
  GUI.UserListInactive+=idx;
  GUI.UserMemoInactive.Text := Format('(%d selected) ', [GUI.UserListInactive.Length]);
  for i := 0 to GUI.UserListInactive.High do
    GUI.UserMemoInactive.Text+=EMOTE_NAMES[GUI.UserListInactive[i]]+', ';
end;

procedure OnChillingEmoteClick(sender: TLazObject);
var
  idx, i: Integer;
begin
  idx := TLazListBox(sender).ItemIndex;
  if GUI.UserListChilling.Length >= 100 then Exit;
  GUI.UserListChilling+=idx;
  GUI.UserMemoChilling.Text := Format('(%d selected) ', [GUI.UserListChilling.Length]);
  for i := 0 to GUI.UserListChilling.High do
    GUI.UserMemoChilling.Text+=EMOTE_NAMES[GUI.UserListChilling[i]]+', ';
end;

procedure OnWinningEmoteClick(sender: TLazObject);
var
  idx, i: Integer;
begin
  idx := TLazListBox(sender).ItemIndex;
  if Gui.UserListWinning.Length >= 100 then Exit;
  Gui.UserListWinning+=idx;
  GUI.UserMemoWinning.Text := Format('(%d selected) ', [GUI.UserListWinning.Length]);
  for i := 0 to GUI.UserListWinning.High do
    GUI.UserMemoWinning.Text+=EMOTE_NAMES[GUI.UserListWinning[i]]+', ';
end;

procedure OnClickClearEmotesButton(sender: TLazObject);
begin
  GUI.UserListInactive.Clear();
  GUI.UserListChilling.Clear();
  GUI.UserListWinning.Clear();
  GUI.UserMemoInactive.Clear();
  GUI.UserMemoChilling.Clear();
  GUI.UserMemoWinning.Clear();
end;

function TScriptForm.CreateEmotesTab(): TLazTabSheet;
var
  groupInactive, groupChilling, groupWinning, groupSettings: TLazGroupBox;
  emoteInfo, lblMin, lblMax: TLazLabel;
begin
  Result := Self.CreateTab('Emotes');

  GUI.btnClearAllEmotes := TLazButton.CreateEx(Result, 'CLEAR ALL EMOTES', 'Clear everything and start-over');
  GUI.btnClearAllEmotes.AutoSize := True;
  GUI.btnClearAllEmotes.Align := ELazAlign.Top;
  GUI.btnClearAllEmotes.Cursor := ELazCursor.NoDrop;
  GUI.btnClearAllEmotes.OnClick := @OnClickClearEmotesButton;

  groupChilling := TLazGroupBox.Create(Result);
  groupChilling.Parent := Result;
  groupChilling.Caption := 'Chilling Emotes (amount)';
  groupChilling.Align := ELazAlign.Left;
  groupChilling.Width := 255;
  groupChilling.BorderSpacing.Left := 10;
  groupChilling.BorderSpacing.Right := 10;

  GUI.CheckListChilling := TLazListBox.CreateEx(groupChilling, '', 'click to select emotes');
  GUI.CheckListChilling.Items.AddStrings(EMOTE_NAMES);
  GUI.CheckListChilling.Align := ELazAlign.Client;
  GUI.CheckListChilling.ClickOnSelChange := False;
  GUI.CheckListChilling.OnClick := @OnChillingEmoteClick;

  GUI.UserMemoChilling := TLazMemo.CreateEx(groupChilling, '', 'pool of emotes to sample when chilling');
  GUI.UserMemoChilling.ReadOnly := True;
  GUI.UserMemoChilling.ScrollBars := ELazScrollStyle.AutoVertical;
  GUI.UserMemoChilling.Align := ELazAlign.Bottom;

  GUI.EditEmoteChilling := TLazSpinEdit.CreateEx(groupChilling, '', 'amount of samples from pool each burst');
  GUI.EditEmoteChilling.Align := ELazAlign.Top;
  GUI.EditEmoteChilling.MinValue := 1;
  GUI.EditEmoteChilling.MaxValue := 10;
  GUI.EditEmoteChilling.ValueEmpty := True;
  GUI.EditEmoteChilling.Value := 1;

  groupInactive := TLazGroupBox.Create(Result);
  groupInactive.Parent := Result;
  groupInactive.Caption := 'Inactive Emotes (amount)';
  groupInactive.Align := ELazAlign.Left;
  groupInactive.Width := 255;
  groupInactive.BorderSpacing.Left := 10;
  groupInactive.BorderSpacing.Right := 10;

  GUI.CheckListInactive := TLazListBox.CreateEx(groupInactive, '', 'click to select emotes');
  GUI.CheckListInactive.Items.AddStrings(EMOTE_NAMES);
  GUI.CheckListInactive.Align := ELazAlign.Client;
  GUI.CheckListInactive.ClickOnSelChange := False;
  GUI.CheckListInactive.OnClick := @OnInactiveEmoteClick;

  GUI.UserMemoInactive := TLazMemo.CreateEx(groupInactive, '', 'pool of emotes to sample when inactive');
  GUI.UserMemoInactive.ReadOnly := True;
  GUI.UserMemoInactive.ScrollBars := ELazScrollStyle.AutoVertical;
  GUI.UserMemoInactive.Align := ELazAlign.Bottom;

  GUI.EditEmoteInactive := TLazSpinEdit.CreateEx(groupInactive, '', 'amount of samples from pool each burst');
  GUI.EditEmoteInactive.Align := ELazAlign.Top;
  GUI.EditEmoteInactive.MinValue := 1;
  GUI.EditEmoteInactive.MaxValue := 10;
  GUI.EditEmoteInactive.ValueEmpty := True;
  GUI.EditEmoteInactive.Value := 1;

  groupWinning := TLazGroupBox.Create(Result);
  groupWinning.Parent := Result;
  groupWinning.Caption := 'Winning Emotes (amount)';
  groupWinning.Align := ELazAlign.Client;
  groupWinning.BorderSpacing.Left := 10;
  groupWinning.BorderSpacing.Right := 10;

  GUI.CheckListWinning := TLazListBox.CreateEx(groupWinning, '', 'click to select emotes');
  GUI.CheckListWinning.Items.AddStrings(EMOTE_NAMES);
  GUI.CheckListWinning.Align := ELazAlign.Client;
  GUI.CheckListWinning.ClickOnSelChange := False;
  GUI.CheckListWinning.OnClick := @OnWinningEmoteClick;

  GUI.UserMemoWinning := TLazMemo.CreateEx(groupWinning, '', 'pool of emotes to sample when winning');
  GUI.UserMemoWinning.ReadOnly := True;
  GUI.UserMemoWinning.ScrollBars := ELazScrollStyle.AutoVertical;
  GUI.UserMemoWinning.Align := ELazAlign.Bottom;

  GUI.EditEmoteWinning := TLazSpinEdit.CreateEx(groupWinning, '', 'amount of samples from pool each burst');
  GUI.EditEmoteWinning.Align := ELazAlign.Top;
  GUI.EditEmoteWinning.MinValue := 1;
  GUI.EditEmoteWinning.MaxValue := 10;
  GUI.EditEmoteWinning.ValueEmpty := True;
  GUI.EditEmoteWinning.Value := 1;

  groupSettings := TLazGroupBox.Create(Result);
  groupSettings.Parent := Result;
  groupSettings.Caption := 'Emote Settings (Min and Max delay between emoting, in seconds)';
  groupSettings.Align := ELazAlign.Bottom;

  lblMin := TLazLabel.CreateEx(groupSettings, 'Min (s):', 'Minimum delay before emoting', 10, 10, 50, 25);
  GUI.EditEmoteMinS := TLazFloatSpinEdit.CreateEx(groupSettings);
  GUI.EditEmoteMinS.Hint := 'these values will be randomized';
  GUI.EditEmoteMinS.ShowHint := True;
  GUI.EditEmoteMinS.SetBounds(65, 8, 80, 25);
  GUI.EditEmoteMinS.MinValue := 7.0;
  GUI.EditEmoteMinS.MaxValue := 3600.0;
  GUI.EditEmoteMinS.Increment := Random(0.1, 0.49);
  GUI.EditEmoteMinS.Value := Random(17.0, 47.0);

  lblMax := TLazLabel.CreateEx(groupSettings, 'Max (s):', 'Maximum delay before emoting', 160, 10, 50, 25);
  GUI.EditEmoteMaxS := TLazFloatSpinEdit.CreateEx(groupSettings);
  GUI.EditEmoteMaxS.Hint := 'these values will be randomized';
  GUI.EditEmoteMaxS.ShowHint := True;
  GUI.EditEmoteMaxS.SetBounds(215, 8, 80, 25);
  GUI.EditEmoteMaxS.MinValue := 21.0;
  GUI.EditEmoteMaxS.MaxValue := 43200.0;
  GUI.EditEmoteMaxS.Increment := RandomRight(0.5, 3.5);
  GUI.EditEmoteMaxS.Value := GUI.EditEmoteMinS.Value * Random(2.9, 3.1);

  emoteInfo := TLazLabel.CreateEx(groupSettings);
  emoteInfo.Align := ELazAlign.Bottom;
  emoteInfo.Alignment := ELazAlignment.Center;
  emoteInfo.Caption := 'Select emotes you''d like to perform when "Inactive", "Chilling" or "Winning".' + LINE_SEP
    + 'Amount controls how many emotes to do at once. Min and Max is the delay between in seconds.' + LINE_SEP
    + 'The emote(s) performed will be random. To perform a specific emote more often than others, simply select it multiple times.';

end;

procedure TScriptForm.Init();
const
  ShopRewardsString = ['Attack', 'Defence', 'Magic', 'Prayer', 'Strength', 'Ranged', 'Hitpoints',
    'Herb Pack', 'Mineral Pack', 'Seed Pack',
    'Void Knight Mace', 'Void Knight Top', 'Void Knight Robes', 'Void Knight Gloves',
    'Void Mage Helm', 'Void Ranger Helm', 'Void Melee Helm', 'Void Knight Seal'];
var
  tab: TLazTabSheet;
  goalsPanel: TLazPanel;
  enableGroup, disableGroup: TLazGroupBox;
  lblCombatLevel,
  lblActiveThresh,
  lblPointsPerWin,
  titleLabel,
  authorLabel,
  lblSpendPoints,
  lblRewards,
  lblRewardAmount: TLazLabel;
  bgImage: TLazImage;
  y: Int32;
begin
  GUI.config.Setup('jds-pestcontrol');
  Self.Setup('Pest Control LITE', GUI.config.Data);

  if USE_AUTO_START then
    Self.Form.OnShow := @StartAutoTimer;

  tab := Self.CreateTab('Settings');
  tab.Color := $1A1A1A;

  if not FileExists(SimbaEnv.DataPath+'jdsBackground.png') then
    URLFetchToFile('https://i.imgur.com/xN2rmA4.png', SimbaEnv.DataPath+'jdsBackground.png');

  bgImage := TLazImage.CreateEx(tab);
  bgImage.Align := ELazAlign.Client;
  bgImage.Picture.LoadFromFile(SimbaEnv.DataPath + 'jdsBackground.png');
  bgImage.Stretch := True;
  bgImage.Proportional := False;
  bgImage.SendToBack();

  y := 20;

  lblActiveThresh := TLazLabel.CreateEx(tab, 'Relax at:',
    'Stop playing at this threshold, lightly randomized', 20, y, 180, 30);
  lblActiveThresh.Font.Size := 14;
  lblActiveThresh.Font.Color := $F0F0F0;
  lblActiveThresh.Font.Style := [ELazFontStyles.Bold];

  GUI.EditActiveThreshold := TLazSpinEdit.CreateEx(tab, '', 'disengage at this threshold');
  GUI.EditActiveThreshold.SetBounds(170, y, 100, 30);
  GUI.EditActiveThreshold.MinValue := 50;
  GUI.EditActiveThreshold.MaxValue := 100;
  GUI.EditActiveThreshold.ValueEmpty := True;
  GUI.EditActiveThreshold.Value := 75;
  GUI.EditActiveThreshold.Font.Size := 14;
  GUI.EditActiveThreshold.Font.Color := $F0F0F0;
  GUI.EditActiveThreshold.Color := $2A2A2A;
  Inc(y, 50);

  lblPointsPerWin := TLazLabel.CreateEx(tab, 'Points/Win:', '', 20, y, 140, 30);
  lblPointsPerWin.Font.Size := 14;
  lblPointsPerWin.Font.Color := $F0F0F0;
  lblPointsPerWin.Font.Style := [ELazFontStyles.Bold];

  GUI.EditPointsPerWin := TLazSpinEdit.CreateEx(tab);
  GUI.EditPointsPerWin.SetBounds(170, y, 100, 30);
  GUI.EditPointsPerWin.MinValue := 3;
  GUI.EditPointsPerWin.MaxValue := 8;
  GUI.EditPointsPerWin.ValueEmpty := True;
  GUI.EditPointsPerWin.Value := 7;
  GUI.EditPointsPerWin.Font.Size := 14;
  GUI.EditPointsPerWin.Font.Color := $F0F0F0;
  GUI.EditPointsPerWin.Color := $2A2A2A;
  Inc(y, 50);

  lblCombatLevel := TLazLabel.CreateEx(tab, 'Combat Level:', '', 20, y, 140, 30);
  lblCombatLevel.Font.Size := 14;
  lblCombatLevel.Font.Color := $F0F0F0;
  lblCombatLevel.Font.Style := [ELazFontStyles.Bold];

  GUI.EditCombatLevel := TLazSpinEdit.CreateEx(tab);
  GUI.EditCombatLevel.SetBounds(170, y, 100, 30);
  GUI.EditCombatLevel.MinValue := 40;
  GUI.EditCombatLevel.MaxValue := 126;
  GUI.EditCombatLevel.ValueEmpty := True;
  GUI.EditCombatLevel.Value := 40;
  GUI.EditCombatLevel.Font.Size := 14;
  GUI.EditCombatLevel.Font.Color := $F0F0F0;
  GUI.EditCombatLevel.Color := $2A2A2A;
  Inc(y, 50);
  
  lblRewards := TLazLabel.CreateEx(tab, 'Reward:',
    'Select experience or items', 20, y, 80, 30);
  lblRewards.Font.Size := 14;
  lblRewards.Font.Color := $F0F0F0;
  lblRewards.Font.Style := [ELazFontStyles.Bold];

  GUI.ComboUserRewards := TLazComboBox.CreateEx(tab);
  GUI.ComboUserRewards.SetBounds(110, y, 160, 30);
  GUI.ComboUserRewards.Items.AddStrings(ShopRewardsString);
  GUI.ComboUserRewards.AutoSelected := False;
  Inc(y, 30);

  lblRewardAmount := TLazLabel.CreateEx(tab, 'Amount:',
    'amount of points to spend, -1 for all, 0 disable', 20, y, 80, 30);
  lblRewardAmount.Font.Size := 14;
  lblRewardAmount.Font.Color := $F0F0F0;
  lblRewardAmount.Font.Style := [ELazFontStyles.Bold];

  GUI.EditRewardAmount := TLazSpinEdit.CreateEx(tab);
  GUI.EditRewardAmount.SetBounds(110, y, 80, 30);
  GUI.EditRewardAmount.MinValue := -1;
  GUI.EditRewardAmount.MaxValue := 4000;
  GUI.EditRewardAmount.Value := 0;
  GUI.EditRewardAmount.Font.Size := 14;
  GUI.EditRewardAmount.Font.Color := $F0F0F0;
  GUI.EditRewardAmount.Color := $2A2A2A;
  Inc(y, 50);

  enableGroup := TLazGroupBox.create(tab);
  enableGroup.Parent := tab;
  enableGroup.SetBounds(500, 0, 150, 150);
  enableGroup.Caption := 'Options to enable';

  GUI.ChkRestAfterGame := TLazCheckBox.CreateEx(enableGroup, 'Rest After Game',
    'Sometimes decide to pause briefly after a game ends');
  GUI.ChkRestAfterGame.Align := ELazAlign.Top;
  GUI.ChkRestAfterGame.SetChecked(False);

  GUI.ChkQuickPrayer := TLazCheckBox.CreateEx(enableGroup, 'Use quick prayers',
    'Enable quick prayers during combat');
  GUI.ChkQuickPrayer.Align := ELazAlign.Top;
  GUI.ChkQuickPrayer.SetChecked(False);

  GUI.ChkChillIfActive := TLazCheckBox.CreateEx(enableGroup, 'Chill if active',
    'Reduce activity if above threshold');
  GUI.ChkChillIfActive.Align := ELazAlign.Top;
  GUI.ChkChillIfActive.SetChecked(False);

  disableGroup := TLazGroupBox.create(tab);
  disableGroup.Parent := tab;
  disableGroup.SetBounds(650, 0, 150, 150);
  disableGroup.Caption := 'Options to disable';

  GUI.ChkDisableHUD := TLazCheckBox.CreateEx(disableGroup, 'Disable HUD',
    'Turn off in-game overlay');
  GUI.ChkDisableHUD.Align := ELazAlign.Top;
  GUI.ChkDisableHUD.SetChecked(False);

  GUI.ChkDisableMoveInBoat := TLazCheckBox.CreateEx(disableGroup, 'Disable Boat Move',
    'Disable boat movement entirely');
  GUI.ChkDisableMoveInBoat.Align := ELazAlign.Top;
  GUI.ChkDisableMoveInBoat.SetChecked(False);

  GUI.ChkDisablePace := TLazCheckBox.CreateEx(disableGroup, 'Disable Pacing',
    'Disable game movement entirely');
  GUI.ChkDisablePace.Align := ELazAlign.Top;
  GUI.ChkDisablePace.SetChecked(False);

  GUI.ChkDisableLeaveGame := TLazCheckBox.CreateEx(disableGroup, 'Disable Auto-Leave',
    'Never leave a game, even if activity drops to 0');
  GUI.ChkDisableLeaveGame.Align := ELazAlign.Top;
  GUI.ChkDisableLeaveGame.SetChecked(False);

  GUI.ChkDisableFatigue := TLazCheckBox.CreateEx(disableGroup, 'Disable Fatigue',
    'Disable fatigue system (will be disabled if unavailable)');
  GUI.ChkDisableFatigue.Align := ELazAlign.Top;
  GUI.ChkDisableFatigue.SetChecked(False);

  GUI.ChkDisableInactive := TLazCheckBox.CreateEx(disableGroup, 'Disable Inactive',
    'Disable activities performed when inactive');
  GUI.ChkDisableInactive.Align := ELazAlign.Top;
  GUI.ChkDisableInactive.SetChecked(False);

  titleLabel := TLazLabel.CreateEx(tab, 'Pest Control LITE', '', 520, 420, 250, 35);
  titleLabel.Font.Size := 24;
  titleLabel.Font.Color := $3B9FFF;
  titleLabel.Font.Style := [ELazFontStyles.Bold];
  titleLabel.Transparent := True;
  titleLabel.Alignment := ELazAlignment.RightJustify;

  authorLabel := TLazLabel.CreateEx(tab, 'by footballjds', 'Thanks to WaspLib contributors!!!', 580, 455, 190, 20);
  authorLabel.Font.Size := 12;
  authorLabel.Font.Color := $3B9FFF;
  authorLabel.Transparent := True;
  authorLabel.Alignment := ELazAlignment.RightJustify;

  Self.CreateEmotesTab();

  goalsPanel := Self.CreateGoals(tab, True, True, False, EOrientation.HORIZONTAL);
  goalsPanel.Align := ELazAlign.Bottom;
  goalsPanel.Color := $3B9FFF;
  goalsPanel.Font.Style := [ELazFontStyles.Bold];
  goalsPanel.Font.Color := $000000;

  lblSpendPoints := TLazLabel.CreateEx(goalsPanel);
  lblSpendPoints.Align := ELazAlign.Right;
  lblSpendPoints.BorderSpacing.Top    := 10;
  lblSpendPoints.BorderSpacing.Bottom := 10;
  lblSpendPoints.BorderSpacing.Left   := 5;
  lblSpendPoints.BorderSpacing.Right  := 5;
  lblSpendPoints.Caption := 'Spend at';

  GUI.EditSpendPointsAt := TLazSpinEdit.CreateEx(goalsPanel, '', 'Threshold at which to spend points', 0, 0, 80);
  GUI.EditSpendPointsAt.Align := ELazAlign.Right;
  GUI.EditSpendPointsAt.BorderSpacing.Around := 8;
  GUI.EditSpendPointsAt.MinValue := -1;
  GUI.EditSpendPointsAt.MaxValue := Random(3500, 3800);
  GUI.EditSpendPointsAt.Value := -1;
  GUI.EditSpendPointsAt.ValueEmpty := True;
  GUI.EditSpendPointsAt.Increment := Random(17, 63);

  if GUI.config.Data.Has('goal_actions') then
    Self.Goals.Actions.Value := GUI.config.Data.Item['goal_actions'].AsInt;
  if GUI.config.Data.Has('goal_time') then
    Self.Goals.Time.Value := GUI.config.Data.Item['goal_time'].AsInt;
  if GUI.config.Data.Has('quick_prayer') then
    GUI.ChkQuickPrayer.SetChecked(GUI.config.Data.Item['quick_prayer'].AsBool);
  if GUI.config.Data.Has('chill_if_active') then
    GUI.ChkChillIfActive.SetChecked(GUI.config.Data.Item['chill_if_active'].AsBool);
  if GUI.config.Data.Has('active_threshold') then
    GUI.EditActiveThreshold.Text := ToStr(GUI.config.Data.Item['active_threshold'].AsInt);
  if GUI.config.Data.Has('points_per_win') then
    GUI.EditPointsPerWin.Text := ToStr(GUI.config.Data.Item['points_per_win'].AsInt);
  if GUI.config.Data.Has('disable_hud') then
    GUI.ChkDisableHUD.SetChecked(GUI.config.Data.Item['disable_hud'].AsBool);
  if GUI.config.Data.Has('disable_move_in_boat') then
    GUI.ChkDisableMoveInBoat.SetChecked(GUI.config.Data.Item['disable_move_in_boat'].AsBool);
  if GUI.config.Data.Has('disable_pace') then
    GUI.ChkDisablePace.SetChecked(GUI.config.Data.Item['disable_pace'].AsBool);
  if GUI.config.Data.Has('disable_leave_game') then
    GUI.ChkDisableLeaveGame.SetChecked(GUI.config.Data.Item['disable_leave_game'].AsBool);
  if GUI.config.Data.Has('disable_fatigue') then
    GUI.ChkDisableFatigue.SetChecked(GUI.config.Data.Item['disable_fatigue'].AsBool);
  if GUI.config.Data.Has('combat_level') then
    GUI.EditCombatLevel.Text := ToStr(GUI.config.Data.Item['combat_level'].AsInt);
  if GUI.config.Data.Has('disable_inactive') then
    GUI.ChkDisableFatigue.SetChecked(GUI.config.Data.Item['disable_inactive'].AsBool);
  if GUI.config.Data.Has('rest_after_game') then
    GUI.ChkDisableFatigue.SetChecked(GUI.config.Data.Item['rest_after_game'].AsBool);

  Self.CreateAntibanTab();

  GUI.ChkQuickPrayer.OnChange := @OnAnyInteraction;
  GUI.ChkChillIfActive.OnChange := @OnAnyInteraction;
  GUI.EditActiveThreshold.OnChange := @OnAnyInteraction;
  GUI.EditPointsPerWin.OnChange := @OnAnyInteraction;
  GUI.ChkDisableHUD.OnChange := @OnAnyInteraction;
  GUI.ChkDisableMoveInBoat.OnChange := @OnAnyInteraction;
  GUI.ChkDisablePace.OnChange := @OnAnyInteraction;
  GUI.ChkDisableLeaveGame.OnChange := @OnAnyInteraction;
  GUI.EditCombatLevel.OnChange := @OnAnyInteraction;
  GUI.ChkDisableFatigue.OnChange := @OnAnyInteraction;
  Gui.EditSpendPointsAt.OnChange := @OnAnyInteraction;
  GUI.ChkDisableInactive.OnChange := @OnAnyInteraction;
  GUI.ChkRestAfterGame.OnChange := @OnAnyInteraction;
  GUI.ComboUserRewards.OnChange := @OnAnyInteraction;
  GUI.EditRewardAmount.OnChange := @OnAnyInteraction;
  Self.Goals.Actions.OnChange := @OnAnyInteraction;
  Self.Goals.Time.OnChange := @OnAnyInteraction;
  Self.PageControl.OnChange := @OnAnyInteraction;
  Self.Run();
end;

begin
  ClearSimbaOutput();
  GUI.form.Init();
  PestControl.Run();
end.
