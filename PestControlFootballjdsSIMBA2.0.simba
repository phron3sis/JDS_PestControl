{$DEFINE SCRIPT_ID := 'pest_control_jds'}
{$DEFINE SCRIPT_REVISION := '1'}
{$DEFINE SCRIPT_GUI}
{$I WaspLib/osrs.simba}
//{$I WaspLib/osrs/antiban/fatigue.simba}
const
  USE_AUTO_START    = TRUE; //auto-start
  AUTO_START_DELAY  = 30;   //delay(in seconds) before auto-starting
type
  TPestControlGameData = record
    Nov, Inter, Vet: record
      AtPlank, PlankObj: TPoint;
      BoatBox: TBox;
    end;

    Portals: record
      W, SW, SE, E: TPoint;
    end;

    Knight, Spawn, LeaveNPC: TPoint;

    OCR: record
      KnightHP: TBox;
      ActivBox, PointsBox, W, E, SE, SW: TBox;
      Shield_W, Shield_E, Shield_SE, Shield_SW: TBox;
      ActivGreen, ActivRed: Int32;
    end;

    GameIsland, OutpostIsland: TBox;
  end;

var
  PCData: TPestControlGameData;
// =============================================================================
// ENUMS
// =============================================================================

type
  EPestState = (
    INIT,
    LOGIN,
    CMBT_LVL,

    IN_BOAT,
    WALK_MID,
    DEFEND,
    AT_PLANK,
    WALK_PLANK,
    EXIT_GAME,
    SPEND_PTS,
    ANTIBAN,
    BREAK,
    SLEEP,

    NO_ACTIVITY, UNKNOWN, MAX_ACTIONS, MAX_TIME, END_SCRIPT
  );
  EAttackChoice = (Self, Knight, Rand);
// =============================================================================
// TYPES
// =============================================================================
type
  TUV = record
    Hash, Salt: String;   // Hash string + Salt
    U: Double;// U (0..1)
  end;
  TUVArray = array of TUV;

  TDeseqState = record
    U: TUVArray;

    // Per-game (set in SetPerGame)
    WinThreshGame: Double;
    InactiveThreshGame: Double;
    KnightHPLvl: Integer;

    // Per-interval noise (rerolled every few seconds)
    WinNoise: Double;
    InactiveNoise: Double;
    LastNoiseReroll: UInt64;
    NoiseInterval: UInt64;  // 3-8s from U at init
  end;

type
  TAttackTempo = record
    XPMean, LowMean, XPMeanGame, LowMeanGame: UInt64;
    XPStick, LowStick: Double;
  end;
  TStateTimer = record
    Times: array[EPestState] of UInt64;  // milliseconds per state
  end;
type
  TPestControl = record

    // Account unique decisions
    Flag: record
      NoPray, NoLeave, NoPace, NoBoatMove, DelayBoatMove: Boolean;
      Choices: TUVArray;
      GameKnightOffset: TPoint;
    end;

    State: EPestState;
    StateT: UInt64;
    StateTimer: TStateTimer;
    
    // Map coordinates
    Center, AtPlank, CrossPlank: TPoint;
    BoatBox: TBox;

    // U's and Choices
    P: TUVArray; // Prayer
    M: TUVArray; // Mouse
    B: TUVArray; // Boat
    SampleRTUs: TUVArray; // Random RT selection U's
    Deseq: TDeseqState; // Desequence
    attkC: TUVArray; // Attack choices
    AttackChoice: EAttackChoice;
    AttackIndex: Int32;
    AttackWeights: array[0..2] of Double;
    AttackStick: Double;

    // Objects & Entities  
    Gangplank: TRSObject;
    Squire, Shifter, VoidKnight: TRSEntity;

    // Timing
    bRT: UInt64;
    RT: TUVArray;//0..2 RT_U1, RT_U2, RTC_U
    Tempo: TAttackTempo;
    XPAttkDelay: UInt64;
    NextAttkDelay, LastAttack: UInt64;
    LastXP,
    LastXPTime,
    HUDLastUpdate,
    GameStart: UInt64;
    GameStarted: Boolean;
    LastEmoteMS: UInt64;
    EmoteDelayMS: Int64;//
    PostAttack: Double;// chance 0..1 to skip waiting after attack

    // Prayer
    PrayerEnableTime: UInt64;
    
    // Boat movement
    LastBoatMove: UInt64;
    BoatMoveDelay: UInt64;
    
    // Activity
    ActivityThresh: Int32;

    // Stats
    Start, LastWin, CombatLevel: UInt64;
    KnightHP, wHP, eHP, seHP, swHP, portalsHP: Int32;
    WShielded, EShielded, SEShielded, SWShielded: Boolean;
    GamesWon, PtsPerGame, LeaveGameCount: UInt32;
    PtsStart, PtsEarned, PtsTotal, SkillInterfacesClosed: Int32;

    UserDisableHUD, UserDisableMoveInBoat, UserDisablePace, UserDisableLeaveGame: Boolean;
    UserDisableFatigue: Boolean;
    Actions, MaxActions, MaxTime: UInt64;
    UserActiveThreshold, UserCombatLevel, UserSpendPointsAt, UserEmoteAmount: Int32;
    UserRewards: TStringArray;
    UserRwardAmmount, UserEmoteList: TIntegerArray;
    UserEmoteInactive, UserEmoteChilling, UserEmoteWinning: Boolean;
    UserQuickPrayer, UserChillIfActive, UserSpendPoints, UserRestAfterGame: Boolean;
  end;

var
  PestControl: TPestControl;
  bhM, _bhM: TUV;

// =============================================================================
// HELPER FUNCTIONS - Distribution Math
// =============================================================================
function SoftRandBool(U: Double; _power: Double = 2.0; scale: Double = 1.0): Boolean;
begin
  Result := RandomBoolean(Power(U, _power) * scale);
end;

function FmtTime(ms: UInt64): String;
begin
  if ms < 60000 then
    Result := FormatFloat('0.0', ms / 1000) + 's'
  else if ms < 3600000 then
    Result := FormatMilliseconds(ms, 'm\m s\s')
  else
    Result := FormatMilliseconds(ms, 'h\h m\m');
end;

// Truncated Gaussian with re-sample instead of EnsureRange
function TruncGauss(mu, sigma, lo, hi: Double): Double;
begin
  repeat
    Result := GaussRand(mu, sigma);
  until (Result >= lo) and (Result <= hi);
end;

// 0 < Random < 1
function NZRandom: Double;
begin
  repeat
    Result := Random;
  until (Result > 0) and (Result < 1);

end;

// John D. Cook approximation ported to Simba 2.0
// Domain: x > 0
// Exposes: Gamma(x), LogGamma(x)

function LogGamma(x: Double): Double; forward;

function Gamma(x: Double): Double;
const
  EULER_GAMMA = 0.577215664901532860606512090;

  p: array[0..7] of Double = [
    -1.71618513886549492533811E+0,
     2.47656508055759199108314E+1,
    -3.79804256470945635097577E+2,
     6.29331155312818442661052E+2,
     8.66966202790413211295064E+2,
    -3.14512729688483675254357E+4,
    -3.61444134186911729807069E+4,
     6.64561438202405440627855E+4
  ];

  q: array[0..7] of Double = [
    -3.08402300119738975254353E+1,
     3.15350626979604161529144E+2,
    -1.01515636749021914166146E+3,
    -3.10777167157231109440444E+3,
     2.25381184209801510330112E+4,
     4.75584627752788110767815E+3,
    -1.34659959864969306392456E+5,
    -1.15132259675553483497211E+5
  ];

var
  DBL_MAX: Double = 1.7976931348623157E+308;
  y, z, num, den, res: Double;
  n, i: Int32;
  argLT1: Boolean;
begin
  if x <= 0 then
    raise 'Gamma domain error: x must be > 0';

  // (0, 0.001)
  if x < 0.001 then
    Exit(1.0 / (x * (1.0 + EULER_GAMMA * x)));

  // [0.001, 12)
  if x < 12.0 then
  begin
    y := x;
    n := 0;
    argLT1 := (y < 1.0);

    if argLT1 then
      y := y + 1.0
    else
    begin
      // y >= 1 here, so Trunc(y) == Floor(y)
      n := Int32(Trunc(y)) - 1;
      y := y - n;
    end;

    num := 0.0;
    den := 1.0;

    z := y - 1.0;
    for i := 0 to 7 do
    begin
      num := (num + p[i]) * z;
      den := den * z + q[i];
    end;

    res := num / den + 1.0;

    if argLT1 then
      // gamma(z) = gamma(z+1)/z ; here z = y-1 (original x)
      res := res / (y - 1.0)
    else
      // gamma(z+n) = z*(z+1)*...*(z+n-1)*gamma(z)
      for i := 1 to n do
      begin
        res := res * y;
        y := y + 1.0;
      end;

    Exit(res);
  end;

  // [12, inf)
  if x > 171.624 then
    Exit(DBL_MAX);

  Result := Exp(LogGamma(x));
end;

function LogGamma(x: Double): Double;
const
  c: array[0..7] of Double = [
     1.0/12.0,
    -1.0/360.0,
     1.0/1260.0,
    -1.0/1680.0,
     1.0/1188.0,
    -691.0/360360.0,
     1.0/156.0,
    -3617.0/122400.0
  ];

  HALF_LOG_TWO_PI = 0.91893853320467274178032973640562;

var
  z, sum, series: Double;
  i: Int32;
begin
  if x <= 0 then
    raise 'LogGamma domain error: x must be > 0';

  if x < 12.0 then
    Exit(Ln(Abs(Gamma(x))));

  // Abramowitz & Stegun 6.1.41
  z := 1.0 / (x * x);

  sum := c[7];
  for i := 6 downto 0 do
    sum := sum * z + c[i];

  series := sum / x;

  Result := (x - 0.5) * Ln(x) - x + HALF_LOG_TWO_PI + series;
end;

// Gamma sampler (Marsaglia-Tsang method)
function SampleGamma(shape: Double): Double;
var
  d, c, x, v, u: Double;
begin
  if shape < 1.0 then
  begin
    Result := SampleGamma(shape + 1.0) * Power(Random(), 1.0 / shape);
    Exit;
  end;

  d := shape - 1.0/3.0;
  c := 1.0 / Sqrt(9.0 * d);

  repeat
    repeat
      x := GaussRand(0.0, 1.0);
      v := 1.0 + c * x;
    until v > 0;

    v := v * v * v;
    u := Random();
  until (u < 1.0 - 0.0331*x*x*x*x) or (Ln(u) < 0.5*x*x + d*(1.0 - v + Ln(v)));

  Result := d * v;
end;

// Beta distribution via Gamma ratio
function SampleBeta(alpha, beta: Double): Double;
var
  x, y: Double;
begin
  x := SampleGamma(alpha);
  y := SampleGamma(beta);
  Result := x / (x + y);
end;

// LOGNORMAL (math form):
//   If Z ~ N(muLog, sigmaLog), then X = exp(Z) is lognormal.
//   Use when you want strictly positive, right-skewed reaction times.
function LogNormalEx(muLog, sigmaLog: Double): Double;
begin
  // Lognormal transform
  Result := Exp(muLog + sigmaLog * GaussRand(0.0, 1.0));
end;

// LOGNORMAL (human form):
//                 mean = typical delay (mean-ish RT)
function LogNormal(mean, sigma: Double): Double;
begin
  Result := LogNormalEx(Ln(mean) - 0.5 * sigma * sigma, sigma);
end;

function LogNormalInt(mean, sigma:Double): UInt64;
begin
  Result := Max(0, Round(LogNormal(mean, sigma)));
end;

function LogNormalRT(mean: Double = PestControl.bRT): UInt64;
var
  sigma: Double;
begin
  if mean < 1 then mean := 1;

  // Per-account sigma preference (0.3-0.7 range)
  sigma := 0.3 + 0.4 * PestControl.RT[3].U;

  {$IFDEF WL_FATIGUE_INCLUDED}
  // Fatigue: slower + heavier tail
  mean := mean * Fatigue.RTMuMultiplier;
  sigma := sigma * Fatigue.RTSigmaMultiplier;
  {$ENDIF}

  Result := Round(LogNormal(mean, sigma));
end;

// EX-GAUSSIAN (math form):
//   X = Gaussian(mu, sigma) + Exponential(tau)
//   This is the classic RT model: Gaussian core + exponential tail.
function ExpoGaussEx(mu, sigma, tau: Double): Double;
begin
  // Gaussian core + Exponential tail (rate = 1/tau)
  Result := GaussRand(mu, sigma) + (-tau * Ln(NZRandom));

  if Result < 0 then
    Result := 0;
end;

function ExpoGaussRT(mean: Double = PestControl.bRT; shouldLog: Boolean = False): UInt64;
var
  mu, sigma, tau: Double;
begin
  if mean < 1 then mean := 1;
  mu := mean;
  sigma := mu * (0.10 + 0.08*PestControl.RT[0].U);
  tau   := mu * (0.22 + 0.15*PestControl.RT[1].U);
  {$IFDEF WL_FATIGUE_INCLUDED}
  if shouldLog then
    Logger.Warn('mu=%.2f | simga=%.2f | tau=%.2f', [mu, sigma, tau]);
  Fatigue.AdjRTParams(mu, sigma, tau);
  if shouldLog then
  begin
    Logger.Warn('mu=%.2f | simga=%.2f | tau=%.2f', [mu, sigma, tau]);
    Logger.Warn('Multipliers: mu=%.2f | simga=%.2f | tau=%.2f', [Fatigue.RTMuMultiplier, Fatigue.RTSigmaMultiplier, Fatigue.RTTauMultiplier]);
  end;
  {$ENDIF}
  Result := Round(ExpoGaussEx(mu, sigma, tau));
end;

// WEIBULL (math form):
//   CDF: 1 - exp(-(x/scale)^shape)
//   shape_k > 0, scale_lambda > 0
//   Useful for fatigue / hazard-rate modeling.
function WeibullEx(shape_k, scale_lambda: Double): Double;
var
  u: Double;
begin
  if shape_k <= 0 then
    shape_k := 0.000001;
  if scale_lambda <= 0 then
    scale_lambda := 0.000001;

  u := NZRandom; // uniform [0,1)

  // Inverse CDF
  Result := scale_lambda * Power(-Ln(u), 1.0 / shape_k);

  if Result < 0 then
    Result := 0;
end;

function WeibullRT(mean: Double = PestControl.bRT): UInt64;
var
  shape, scale: Double;
begin
  if mean < 1 then mean := 1;

  // Per-account shape preference (1.2-2.2 range, higher = less tail)
  shape := 1.2 + 1.0 * PestControl.RT[4].U;
  scale := mean / Gamma(1.0 + 1.0/shape);

  {$IFDEF WL_FATIGUE_INCLUDED}
  // Fatigue: slower (scale up) + more variable (shape down)
  scale := scale * Fatigue.RTMuMultiplier;
  shape := shape / (1.0 + 0.3 * Fatigue.FatigueNormalized);
  {$ENDIF}

  Result := Round(WeibullEx(shape, scale));
end;

function SampleRT(mean: Double = PestControl.bRT): UInt64;
begin
  if SoftRandBool(PestControl.RT[5].U, 2.0, 0.55) then
    Result := ExpoGaussRT(mean)
  else if SoftRandBool(PestControl.RT[6].U, 2.0, 0.65) then
    Result := WeibullRT(mean)
  else
    Result := LogNormalRT(mean);
end;

function HashToU(const salt: String): Double;
const
  INV_POW2_53 = 1.1102230246251565e-16;
var
  ident, msg, hex: String;
  v, k: UInt64;
begin
  if InRange(ProfileIndex, 0, High(Profiles)) and
     ((Profiles[ProfileIndex].Name <> '') or (Profiles[ProfileIndex].Username <> '')) then
    ident := IntToStr(Length(Profiles[ProfileIndex].Name)) + ':' +
             Profiles[ProfileIndex].Name + ':' +
             Profiles[ProfileIndex].Username
  else
    ident := '0:ANON:' + SimbaEnv.SimbaPath;

  msg := 'HashToU|v1|' + ident + '|' + salt;
  hex := HashString(EHashAlgo.SHA256, msg);
  v := StrToUInt64('$' + Copy(hex, 1, 16));
  k := (v shr 11);
  Result := (k * INV_POW2_53) + (0.5 * INV_POW2_53);
end;

procedure TUV.Create(salt: String = '');
begin
  Self.Hash := Profiles[ProfileIndex].Name + Profiles[ProfileIndex].Username;
  Self.Salt := salt;
  Self.U := HashToU(salt);
  WriteLn(PadR(Self.Salt, 16), Self.U);
end;

procedure TUVArray.Create(salts: TStringArray);
var
  i: Int32;
begin
  SetLength(Self, salts.Length);
  for i := 0 to salts.High do
    Self[i].Create(salts[i]);
end;

function TUVArray.Get(salt: String): Double;
var
  i: Integer;
begin
  for i := 0 to Self.High do
    if Self[i].Salt = salt then
      Exit(Self[i].U);
  Writeln GetDebugLn('Salt not found: ' + salt, ELogLevel.ERROR, True);
end;

procedure TPestControl.CloseSkillInterface();
begin
  if Target.CountColor([$0A3146, 0.375, EColorSpace.HSV, [1.000, 1.000, 1.000]],
    MainScreen.Bounds) < 100 then Exit();
  Sleep(Self.bRT, 8000);
  Target.KeyPress(EKeyCode.ESCAPE);
  Sleep(Self.bRT, 1800);
  Writeln(GetDebugLn('SKILL INTERFACE CLOSED - why was it open? lol, Message footballjds!', ELogLevel.ERROR));
  Inc(Self.SkillInterfacesClosed);
  if Self.SkillInterfacesClosed > (5 + 10 * _bhM.U) then
    TerminateScript('TOO MANY INTERFACES CLOSED, failsafe. Message footballjds!!!');
end;

procedure TConfigJSON.SetConfig(const key: String; value: UInt64); overload;
begin
  if not Self.Data.Has(key) then
    Self.Data.AddInt(key, value)
  else
    Self.Data.Item[key].AsInt := value;
end;

procedure TConfigJSON.SetConfig(const key: String; value: Double); overload;
begin
  if not Self.Data.Has(key) then
    Self.Data.AddFloat(key, value)
  else
    Self.Data.Item[key].AsFloat := value;
end;

procedure TConfigJSON.SetConfig(const key: String; value: Boolean); overload;
begin
  if not Self.Data.Has(key) then
    Self.Data.AddBool(key, value)
  else
    Self.Data.Item[key].AsBool := value;
end;

procedure TConfigJSON.SetConfig(const key: String; value: String); overload;
begin
  if not Self.Data.Has(key) then
    Self.Data.AddString(key, value)
  else
    Self.Data.Item[key].AsString := value;
end;

type
  TRSPestShop = record
    Title: TRSInterfaceTitle;
    SpendablePoints: Integer;
    Bounds, PointsOCR: TBox;
    ConfirmButton: TRSButton;
    RewardStrings: TStringArray;
    ItemBoxes: TBoxArray;
    Costs: TIntegerArray;
    Scroll: TRSScrollBar;
    NPC: TRSEntity;
  end;

var
  PestShop: TRSPestShop;

procedure TRSPestShop.Setup();
var
  x1, y1, x2, slotW, slotW2, slotH, gapX, gapY: Int32;
  boxes: TBoxArray;
begin
  Self.RewardStrings := ['Attack', 'Defence', 'Magic', 'Prayer', 'Strength', 'Ranged', 'Hitpoints'];
  Self.RewardStrings += ['Herb Pack', 'Mineral Pack', 'Seed Pack'];
  Self.RewardStrings += ['Void Knight Mace', 'Void Knight Top', 'Void Knight Robes', 'Void Knight Gloves'];
  Self.RewardStrings += ['Void Mage Helm', 'Void Ranger Helm', 'Void Melee Helm', 'Void Knight Seal'];

  case RSClient.Mode of
    ERSMode.FIXED:
      Self.Bounds := MSInterface.CreateBounds([0, 0, 0, 0], 489, 319);
    ERSMode.RESIZABLE, ERSMode.MODERN_COMPACT, ERSMode.MODERN_WIDE:
      Self.Bounds := MSInterface.CreateBounds([0, 0, 0, 0], 489, 319);
  end;


  Self.PointsOCR.X1 := Self.Bounds.X1 + 83;
  Self.PointsOCR.Y1 := Self.Bounds.Y2 - 37;
  Self.PointsOCR.X2 := Self.Bounds.X1 + 133;
  Self.PointsOCR.Y2 := Self.Bounds.Y2 - 18;

  Self.Scroll.Area.X1 := Self.Bounds.X1 + 10;
  Self.Scroll.Area.Y1 := Self.Bounds.Y1 + 42;
  Self.Scroll.Area.X2 := Self.Bounds.X2 - 27;
  Self.Scroll.Area.Y2 := Self.Bounds.Y2 - 51;

  Self.Scroll.Setup(True);
  Self.Title.Setup(Self.Bounds);

  x1 := Self.Scroll.Area.X1 + 42;
  x2 := Self.Scroll.Area.X1+2;
  slotW2 := Self.Scroll.Area.Width div 2 - 2;
  y1 := Self.Scroll.Area.Y1 + 4;
  slotW := 61;
  slotH := 29;
  gapX := 0;
  gapY := 6;

  // Top section: 6 columns x 3.5 rows
  boxes := TBoxArray.Create([x1, y1], 3, 4, slotW, slotH, [gapX, gapY]);
  x1 := Self.Scroll.Area.X1 + 84 + slotW*3;
  boxes += TBoxArray.Create([x1, y1], 3, 3, slotW, slotH, [gapX, gapY]);

  ////// Middle section after divider: 2 columns x 1.5 rows
  y1 := Self.Scroll.Area.Y1+157; // after divider
  boxes += TBoxArray.Create([x2, y1], 2, 1, slotW2, slotH, [gapX, gapY]);
  Inc(y1, slotH+gapY);
  boxes += TBoxArray.Create([x2, y1], 1, 1, slotW2, slotH, [gapX, gapY]);

  // Bottom section: 2 columns x 4 rows
  y1 := Self.Scroll.Area.Y1+85;
  boxes += TBoxArray.Create([x2, y1], 2, 4, slotW2, slotH, [gapX, gapY]);
  Self.ItemBoxes := boxes;

  Self.Costs := [1, 10, 100, 1, 10, 100, 1, 10, 100,
    1, 10, 100, 1, 10, 100, 1, 10, 100, 1, 10, 100];
  Self.Costs += [30, 15, 15];
  Self.Costs += [250, 250, 250, 150, 200, 200, 200, 10];

  Writeln(GetTimeRunning,' ', Self.ItemBoxes.Length);
  Writeln(GetTimeRunning,' ',Self.RewardStrings.Length);

  if (self.Costs.Length <> Self.ItemBoxes.Length) or
    (Self.ItemBoxes.Length <> Self.RewardStrings.Length + 14) then
    RaiseException('!FATAL! TRSPestShop.Setup(); Reward strings don''t match boxes!');

  Self.ConfirmButton.Bounds := Box(
    Self.Bounds.Center.X - 73,
    Self.Bounds.Y2 - 42,
    Self.Bounds.Center.X + 74,
    Self.Bounds.Y2 - 10
  );
  self.ConfirmButton.EnabledColors := [[$1F98FF, 0]];

  Self.NPC := TRSEntity.Create(
    @Map.Walker,
    [1, 1, 1],
    20,
    [[10648, 39826], [10640, 39826]],
    ['Talk-to Void', 'Void Knight', 'to Void K', 'oid Knight'],
    [ERSMinimapDot.NPC]
  );
  Self.NPC.Finder.ColorClusters += [[
    [$7192B6, 0.519, EColorSpace.HSV, [1.444, 1.444, 0.114]],
    [$321B1B, 0.759, EColorSpace.HSV, [2.300, 0.168, 0.533]],
    5
  ]];
  Self.NPC.Finder.ColorClusters += [[
    [$351D1D, 0.827, EColorSpace.HSV, [2.405, 0.158, 0.439]],
    [$27657E, 0.625, EColorSpace.HSV, [1.410, 1.314, 0.277]],
    5
  ]];

end;

function TRSPestShop.IsOpen(): Boolean;
begin
  result := Target.CountColor(2070783, 0, [163, 21, 359, 39]) = 638;
end;

function TRSPestShop.isClosed(): Boolean;
begin
  result := not Self.IsOpen();
end;

function TRSPestShop.WaitOpen(): Boolean;
begin
  result := SleepUntil(Self.IsOpen(), 50, random(2000, 4000));
end;

function TRSPestShop.DidPurchase(): Boolean;
begin
  Result := Chat.HasContinue and not Chat.LeveledUp();
  writeln('DidPurchase():', result, ' | GetTimeRunning=', GetTimeRunning);
end;

function TRSPestShop.WaitPurchased(openAgain: Boolean = False): Boolean;
var
 t: Int64;
begin
  t := Time + Random(1500, 4000);
  writeln('WaitPurchased GetTimeRunning=',GetTimeRunning, ' | t=',t);
  repeat
    writeln('in waitpurchased loop GetTimeRunning=',GetTimeRunning);
    if Self.DidPurchase then
    begin
      if openAgain and Chat.Continue() then
        Exit(Self.WaitOpen())
      else
        Exit(True);
    end;
  until (Time > t);
  writeln('WaitPurchased GetTimeRunning=',GetTimeRunning);
end;

function TRSPestShop.Close(escape: Boolean): Boolean;
begin
  Result := Self.Title.Close(escape);
end;

function TRSPestShop.Close(escapeProbability: Single = -1): Boolean; overload;
begin
  Result := Self.Title.Close(escapeProbability);
end;

function TRSPestShop.Open(attempts: Integer = 3): Boolean;
var
  i: Integer;
begin
  if Chat.HasContinue() then
  begin
    writeln('Chat.HasContinue()=', FormatMilliseconds(GetTimeRunning, TIME_SHORT));
    Target.KeyPress(EKeyCode.SPACE);
    result := Self.WaitOpen();
    if result then Exit;
  end;
  if attempts <= 3 then attempts := random(3,5);
  for i := 0 to attempts do
  begin
    writeln('in Open loop GetTimeRunning=',GetTimeRunning, ' | i=', i);
    if Self.IsOpen() then Exit(true);
    if ChooseOption.IsOpen() then
    begin
      if ChooseOption.Select(['Exchange Void Knight', 'Exchange Void'], True, True) then
        if Self.WaitOpen() then
          Exit(True);
      ChooseOption.Close();
      Sleep(60, 200);
    end;
    if self.NPC.DistanceTo(Map.Position()) > RandomMode(4, 4, 7) then
      Map.Walker.WebWalk(Self.NPC.Coordinates[Random(0, Self.NPC.Coordinates.High)], 2, 0.3);
    if Self.NPC.Interact(['Exchange Void Knight', 'Exchange Void'], 1) then
      if Self.WaitOpen() then
        Exit(True);
  end;
end;

function TRSPestShop.ReadPoints: Integer;
begin
  Result := 0;
  if not Self.IsOpen() then Exit;
  result := OCR.RecognizeNumber(Self.PointsOCR, RSFonts.BOLD_SHADOW, [RSFonts.WHITE], 0);
  Self.SpendablePoints := Result;
end;


function TRSPestShop.BuyReward(reward:String; pts: Integer): Boolean;
var
  ptBox, textBox: Tbox;
  f: TRSFonts;
  s: String;
  xpBefore: UInt64;
  idx, i, invCt: Integer;// TBoxArray index of reward string
begin
  if not Self.IsOpen() then Exit;
  if not Self.RewardStrings.Contains(reward) then
    RaiseException('!FATAL! TRSPestShop.BuyReward(); Reward INVALID!');
  xpBefore := XPBar.Read;
  invCt := Inventory.Slots.Count();
  if reward.Contains('Void', True) then
    Self.Scroll.SetLevel(100)
  else
    Self.Scroll.SetLevel(0);
  Sleep(60, 400);
  idx := (Self.RewardStrings.IndexOf(reward)+1)*3 - 1;
  if reward in ['Attack', 'Defence', 'Magic', 'Prayer', 'Strength', 'Ranged', 'Hitpoints'] then
    if pts = 1 then idx-=2
    else if pts = 10 then
      idx-=1;
  Self.SpendablePoints := Self.ReadPoints;
  if pts > Self.SpendablePoints then
  begin
    Writeln(GetTimeRunning,' ','Not enough points to purchase...');
    Exit;
  end;
  Mouse.Click(Self.ItemBoxes[idx].Expand(-1), EMouseButton.LEFT);
  Sleep(220, 480);

  if self.ConfirmButton.WaitEnabled() then
  begin
    Self.ConfirmButton.Click();
    if SleepUntil(Self.isClosed(), RandomLeft(111, 321), RandomLeft(1800, 5300)) then
      Result := (Inventory.Slots.Count() <> invCt) or (XPBar.Read <> xpBefore);
    if Result then Self.SpendablePoints-=pts;
    writeln(GetTimeRunning,' ','did buy ', result);
  end;
end;

procedure TRSPestShop.PurchaseExp(expString: String; stopAt: Integer);
var
  spend, remaining, before, fails, attempts: Integer;
  tEnd: UInt64;
begin
  tEnd := Time + Random(ONE_MINUTE*5, ONE_MINUTE*8);
  attempts := Random(10, 20);
  fails := 0;
  repeat
    writeln('in PurchaseExp GetTimeRunning=',GetTimeRunning);
    if not Self.Open() then
      Exit;
    Sleep(120, 500);
    Self.SpendablePoints := Self.ReadPoints;
    remaining := Self.SpendablePoints - stopAt;
    if remaining <= 0 then Break;

    writeln(GetTimeRunning,' ','TRSPestShop.PurchaseExp() remaining points=', remaining);
    spend := 1 + 9*(Ord(remaining >= 10) and 1) + 90*(Ord(remaining >= 100) and 1);

    writeln(GetTimeRunning,' ','TRSPestShop.PurchaseExp() spendable points', spend);
    before := Self.SpendablePoints;
    if not Self.BuyReward(expString, spend) then
      Inc(fails);

    if Self.SpendablePoints >= before then
      Inc(fails);
    Sleep(120, 500);
  until (Self.SpendablePoints <= stopAt) or (Time >= tEnd) or (fails >= attempts);
end;

function TPestControl.SpendPestPoints(): Boolean;
begin
  Sleep(ExpoGaussRT(Self.bRT));
  //PestShop.PurchaseExp('Prayer', 0);
  Sleep(ExpoGaussRT(Self.bRT));
end;

//override include to set zoom if it is wrong
function TRSOptions.GetZoomLevel(useCache: Boolean = True): Integer; override;
begin
  if useCache and (Self.ZoomLevel > -1) then
    Exit(Self.ZoomLevel);

  WriteLn GetDebugLn('Options', 'Unknown zoom level, reading from the gametab...');
  if Self.OpenTab(ERSOptionsTab.DISPLAY) then
    Self.ZoomLevel := Self.Sliders[ERSOptionsSlider.ZOOM].GetLevel();
  if Self.ZoomLevel = -1 then
    WriteLn GetDebugLn('Options', 'Failed to read zoom!', ELogLevel.ERROR)
  else
    WriteLn GetDebugLn('Options', 'Current zoom level: ' + ToString(Self.ZoomLevel), ELogLevel.SUCCESS);

  Result := Self.ZoomLevel;
  if InRange(Result, 30, 50) then exit;
  if Self.SetZoomLevel(RandomMode(35+Round(10*bhM.U), 30, 50)) then
  begin
    Result := Self.ZoomLevel;
    WriteLn GetDebugLn('Options', 'Zoom adjusted level: ' + ToString(Self.ZoomLevel), ELogLevel.SUCCESS);
  end;
end;

//override include
function TRSEntity._HoverHelper(action: TStringArray; attempts: Integer): Boolean; override;
var
  shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
  coordinates, tpa: TPointArray;
begin
  Result := Self._UpTextCheck(shouldExit, action);
  if shouldExit then Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(coordinates, atpa) then
    begin
      if Length(coordinates) <> Length(atpa) then
        raise 'SOMETHING WENT WRONG CACHING COORDINATES.';

      if attempt < 2 then i := 0
      else if Length(atpa) > (attempt - 2) then i := attempt - 2
      else i := Random(Low(atpa), High(atpa));

      tpa := atpa[i];
      Self.LastCoordinate := coordinates[i];

      Mouse.Move(tpa.RandomMean());

      if Self.UpText = [] then Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText) then Exit(True);

    if attempt <> (attempts - 1) then
      Continue;
    if not self.UpText.Contains('tack Shifter') then
      Minimap.CompassRadians := Minimap.CompassRadians + PI/3.6 * Random(-1,1);
  end;
end;

// =============================================================================
// PEST CONTROL METHODS
// =============================================================================

function TPestControl.GetReportValues(): TStringArray;
var
  playTime: UInt64;
  winsPerHour, ptsPerHour: Double;
  actionsStr, sleepInfo: String;
begin
  actionsStr := ToStr(Self.Actions);
  if Self.MaxActions <> 0 then
    actionsStr += '/' + ToStr(Self.MaxActions);

  if Antiban.Sleeps = [] then
    sleepInfo := 'No sleep'
  else
    sleepInfo := Antiban.TimeUntilSleep(Antiban.Sleeps.First, TIME_SHORT);

  playTime := Logger.TimeRunning.Elapsed;
  Self.GamesWon := Round(Self.PtsEarned/Self.PtsPerGame);
  winsPerHour := (Self.GamesWon / Max(1, playTime)) * ONE_HOUR;
  ptsPerHour := (Self.PtsEarned / Max(1, playTime)) * ONE_HOUR;


  Result := [
    GetTimeStamp(TIME_SHORT),
    Logger.TimeRunning.ElapsedFmt(TIME_SHORT),
    Antiban.TimeRunning.ElapsedFmt(TIME_SHORT),
    sleepInfo,
    ToStr(Self.GamesWon),
    FormatNumber(winsPerHour, 2),
    ToStr(Self.PtsEarned),
    FormatNumber(ptsPerHour, 2),
    actionsStr
  ];
end;

function TPestControl.InGame(): Boolean;
const
  sBox: Tbox = [11, 94, 49, 108];
begin
  result := Target.CountColor($CCCCCC, 0, sBox) > 35;
  if not result then Self.GameStarted := False;
end;

function TPestControl.ReadActivityBar(): Int32;
var
  greenCount: Int32;
  activBox: TBox = [368, 126, 508, 126];
begin
  result := -1;
  if not Self.InGame() then Exit;
  greenCount := Target.CountColor(PCData.OCR.ActivGreen, 0, activBox);
  Result := Round((greenCount / 141) * 100);
end;

function TPestControl.ReadKnightHP(): Int32;
begin
  Self.KnightHP := OCR.RecognizeNumber(PCData.OCR.KnightHP, RSFonts.PLAIN_11, [$00F800, $0000F8], 0);
  result := Self.KnightHP;
end;

function TPestControl.ReadPortalHP(): Int32;
begin
  Self.wHP := OCR.RecognizeNumber(PCData.OCR.W, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.eHP := OCR.RecognizeNumber(PCData.OCR.E, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.seHP := OCR.RecognizeNumber(PCData.OCR.SE, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.swHP := OCR.RecognizeNumber(PCData.OCR.SW, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.portalsHP := Self.wHP + Self.eHP + Self.seHP + Self.swHP;
  result := Self.portalsHP;
end;

procedure TPestControl.UpdatePortalShields();
const
  SHIELD_COLOR = $73737A;
  TOL = 1;
begin
  Self.ReadPortalHP();
  Self.WShielded := SimilarColors(Target.GetColor(Point(382, 95)), SHIELD_COLOR, TOL);
  Self.EShielded := SimilarColors(Target.GetColor(Point(420, 95)), SHIELD_COLOR, TOL);
  Self.SEShielded := SimilarColors(Target.GetColor(Point(457, 95)), SHIELD_COLOR, TOL);
  Self.SWShielded := SimilarColors(Target.GetColor(Point(495, 95)), SHIELD_COLOR, TOL);
  //writeln('W: ', Self.WShielded, '| E: ', Self.EShielded, '| SE: ', Self.SEShielded, '| SW: ', Self.SWShielded);
end;

procedure TPestControl.UpdateAndDrawHUD(onBreak: Boolean = False; onSleep: Boolean = False; remaining: UInt64 = 0; Force: Boolean = False);
const
  REFRESH_RATE = 500;//milliseconds
  HUD_BG_COLOR = $181818;
  HUD_BORDER_COLOR = $404040;
  HUD_HEADER_TEXT = $3B9FFF;
  HUD_TEXT_COLOR = $F0F0F0;
  HUD_TEXT_MUTED = $A5A5A5;
  HUD_SEP_COLOR = $404040;
  HUD_ACTIVITY_RED = $0000F8;
  HUD_ACTIVITY_WARN = $57C8FF;
  HUD_ACTIVITY_GREEN = $47FF47;
  THRESHOLD_COLOR = $F0F0F0;
  TRACK_COLOR = $202020;
  PAD = 8;
  ROW_GAP = 11;
  SEP_MARGIN = 3;
  SEP_HEIGHT = 2;
var
  elapsed: UInt64;
  winsPerHour, ptsPerHour, xpPerHour: Double;
  abox, aboxBorder, headerBox, footerBox, barBox, barBorder, fillBox: TBox;
  xLabel, xVal, xRate, y, fullWidth, filledWidth, thrX, totalWidth: Int32;
  activityValue, runtimeStr, stateStr, winsStr, winsHrStr, ptsStr, ptsHrStr, portalStr: String;
  xpStr, xpHrStr, prayerStr, atkDelayStr, breakStr, sleepStr, maxActStr, maxTimeStr: String;
  breakRemain, sleepRemain: String;
  barColor, valueColor, actPercent, currentMinutes, xPos: Int32;

  function DrawSep(cy: Int32): Int32;
  begin
    Inc(cy, SEP_MARGIN);
    RSClient.Canvas.DrawColor := HUD_SEP_COLOR;
    RSClient.Canvas.DrawBoxFilled(Box(abox.X1 + 6, cy -1, abox.X2 - 6, cy + 1));
    Result := cy + SEP_HEIGHT + SEP_MARGIN;
  end;

  function DrawRow(const lbl, val: String; cy: Int32; const rate: String = ''): Int32;
  begin
    RSClient.Canvas.DrawColor := HUD_TEXT_MUTED;
    RSClient.Canvas.DrawText(lbl, Point(xLabel, cy));
    RSClient.Canvas.DrawColor := HUD_TEXT_COLOR;
    RSClient.Canvas.DrawText(val, Point(xVal, cy));
    if rate <> '' then
      RSClient.Canvas.DrawText(rate, Point(xRate, cy));
    Result := cy + ROW_GAP;
  end;

begin
  if Self.UserDisableHUD then Exit;
  if ((Time - Self.HUDLastUpdate) < REFRESH_RATE) and
    not Force then Exit;
  Self.HUDLastUpdate := Time;

  Self.PtsEarned := Self.PtsTotal - Self.PtsStart;
  Self.GamesWon := Round(Self.PtsEarned / Self.PtsPerGame);
  elapsed := Logger.TimeRunning.Elapsed;
  winsPerHour := (Self.GamesWon / Max(1, elapsed)) * ONE_HOUR;
  ptsPerHour := (Self.PtsEarned / Max(1, elapsed)) * ONE_HOUR;
  xpPerHour := (XPBar.TotalEarnedXP() / Max(1, elapsed)) * ONE_HOUR;

  runtimeStr := FormatMilliseconds(GetTimeRunning, TIME_SHORT);
  stateStr := ToStr(Self.State).After('EPestState.');

  breakRemain := '';
  sleepRemain := '';
  if onBreak then
  begin
    breakStr := FormatMilliseconds(remaining, TIME_SHORT);
    stateStr := 'ON_BREAK';
    breakRemain := 'remaining';
  end else
  begin
    breakStr := 'None';
    if Length(Antiban.Breaks) > 0 then
      breakStr := Antiban.TimeUntilBreak(Antiban.Breaks[0], TIME_SHORT);
  end;
  if onSleep then
  begin
    sleepStr := FormatMilliseconds(remaining, TIME_SHORT);
    stateStr := 'ON_SLEEP';
    sleepRemain := 'remaining';
  end else
  begin
    sleepStr := 'None';
    if Length(Antiban.Sleeps) > 0 then
      sleepStr := Antiban.TimeUntilSleep(Antiban.Sleeps[0], TIME_SHORT);
  end;

  winsStr := ToStr(Self.GamesWon);
  winsHrStr := FormatNumber(winsPerHour, 1);
  ptsStr := ToStr(Self.PtsEarned);
  ptsHrStr := FormatNumber(ptsPerHour, 0);
  xpStr := FormatNumber(XPBar.TotalEarnedXP(), 1);
  xpHrStr := FormatNumber(xpPerHour, 0);

  if (Self.LastXPTime + Self.XPAttkDelay) > Time then
    atkDelayStr := FormatFloat('#,##0', Round(Self.XPAttkDelay)) + 'ms'
  else
    atkDelayStr := FormatFloat('#,##0', Round(Self.NextAttkDelay)) + 'ms';

  prayerStr := 'N/A';
  if Self.UserQuickPrayer then
    prayerStr := FormatFloat('#,##0', Round(Self.PrayerEnableTime)) + 'ms';

  maxActStr := '';
  if Self.MaxActions > 0 then
    maxActStr := ToStr(Self.Actions) + '/' + ToStr(Self.MaxActions);

  maxTimeStr := '';
  if Self.MaxTime > 0 then
  begin
    currentMinutes := GetTimeRunning div 60000;
    maxTimeStr := ToStr(currentMinutes) + '/' + ToStr(Self.MaxTime div 60000);
  end;

  actPercent := Self.ReadActivityBar();
  if actPercent < 0 then
  begin
    activityValue := 'N/A';
    valueColor := HUD_TEXT_MUTED;
    barColor := HUD_ACTIVITY_WARN;
  end
  else
  begin
    activityValue := ToStr(actPercent)+'%';
    if actPercent < 30 then
    begin
      valueColor := HUD_ACTIVITY_RED;
      barColor := HUD_ACTIVITY_RED;
    end
    else if actPercent < Self.ActivityThresh then
    begin
      valueColor := HUD_ACTIVITY_WARN;
      barColor := HUD_ACTIVITY_WARN;
    end
    else
    begin
      valueColor := HUD_ACTIVITY_GREEN;
      barColor := HUD_ACTIVITY_GREEN;
    end;
  end;

  abox := Box(552, 206, 731, 463);
  aboxBorder := abox.Expand(2);
  headerBox := Box(abox.X1, abox.Y1, abox.X2, abox.Y1 + 24);
  footerBox := Box(abox.X1, abox.Y2 - 18, abox.X2, abox.Y2);
  xLabel := abox.X1 + PAD;
  xVal := abox.X1 + 55;
  xRate := abox.X2 - 55;

  with RSClient.Canvas do
  begin
    BeginUpdate();

    DrawColor := HUD_BORDER_COLOR;
    DrawBoxFilled(aboxBorder);
    DrawColor := HUD_BG_COLOR;
    DrawBoxFilled(abox);
    DrawBoxFilled(headerBox);
    DrawBoxFilled(footerBox);

    FontName := 'Segoe UI';
    FontAntialiasing := True;
    FontSize := 16;
    DrawColor := HUD_HEADER_TEXT;
    DrawText('Pest Control LITE', Point(headerBox.X1 + PAD, headerBox.Y1 + 4));

    barBox := Box(abox.X1 + PAD, headerBox.Y2, abox.X1 + PAD +
      TextWidth('Pest Control LITE'), headerBox.Y2 + 8);
    barBorder := barBox.Expand(2);

    DrawColor := TRACK_COLOR;
    DrawBoxFilled(barBox);
    fullWidth := barBox.X2 - barBox.X1;
    filledWidth := (fullWidth * EnsureRange(actPercent, 0, 100)) div 100;
    if filledWidth > 0 then
    begin
      fillBox := barBox;
      fillBox.X2 := fillBox.X1 + filledWidth;
      DrawColor := barColor;
      DrawBoxFilled(fillBox);
      DrawBox(barBorder);
    end;
    thrX := barBox.X1 + (fullWidth * EnsureRange(Self.ActivityThresh, 0, 100)) div 100;
    DrawColor := THRESHOLD_COLOR;
    DrawBoxFilled(Box(thrX, barBox.Y1, thrX + 1, barBox.Y2));

    FontSize := 16;
    DrawColor := valueColor;
    DrawText(activityValue, Point(barBox.X2 + 4, barBox.Y1-2));

    y := barBox.Y2 +4;
    y := DrawSep(y);
    FontSize := 12;
    {$IFDEF WL_FATIGUE_INCLUDED}
    y := DrawRow('Runtime', runtimeStr, y, 'F '+ FormatFloat('##0.0', Fatigue.FatigueLevel*100)+'%');
    {$ELSE}
    y := DrawRow('Runtime', runtimeStr, y, 'F ');
    {$ENDIF}

    if stateStr.Contains('DEFEND') then
      y := DrawRow('State', stateStr, y, FmtTime(Time-Self.GameStart))
    else
      y := DrawRow('State', stateStr, y, FmtTime(Time-Self.StateT));
    y := DrawRow('Break', breakStr, y, breakRemain);
    y := DrawRow('Sleep', sleepStr, y, sleepRemain);
    y := DrawSep(y);
    y := DrawRow('Wins', winsStr, y, winsHrStr + '/hr');
    y := DrawRow('Points', ptsStr, y, ptsHrStr + '/hr');
    y := DrawRow('XP', xpStr, y, xpHrStr + '/hr');
    y := DrawSep(y);
    y := DrawRow('Prayer', prayerStr, y);
    DrawColor := HUD_TEXT_COLOR;
    if not onSleep and not onBreak then
      DrawText('Z: ' + ToStr(Options.ZoomLevel), Point(xRate, y - ROW_GAP));
    y := DrawRow('Attack', atkDelayStr, y);
    if Self.LeaveGameCount > 0 then
      DrawText('L''s: ' + ToStr(Self.LeaveGameCount), Point(xRate, y - ROW_GAP));
    y := DrawSep(y);
    y := DrawRow('Total', ToStr(Self.State).After('.'), y, FmtTime(Self.StateTimer.Times[Self.State]+ (Time - Self.StateT)));
    y := DrawRow('Total', 'Points', y, FormatFloat('#,##0', Self.PtsTotal));
    if Self.InGame() then
      y := DrawRow('Sort/idx', ToStr(Self.AttackChoice).After('.'), y, IntToStr(Self.AttackIndex));
    if maxActStr <> '' then y := DrawRow('Max', 'Actions', y, maxActStr);
    if maxTimeStr <> '' then y := DrawRow('Max', 'Time', y, maxTimeStr);

    if Self.InGame() then
    begin
      Self.UpdatePortalShields();

      //FontSize := 10;

      // Calculate total width for centering
      totalWidth := TextWidth('(W) 999|') + TextWidth('(E) 999|') +
                    TextWidth('(SE)999|') + TextWidth('(SW)999');
      xPos := (abox.X1 + abox.X2) div 2 - totalWidth div 2;

      // W portal
      DrawColor := 16711935;
      if Self.WShielded then DrawText('(W)', Point(xPos, y+1))
      else DrawText('W:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(W) '));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.wHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 16711935;
      DrawText('|', Point(xPos, y+1));
      Inc(xPos, TextWidth('|'));

      // E portal
      DrawColor := 16737894;
      if Self.EShielded then DrawText('(E)', Point(xPos, y+1))
      else DrawText('E:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(E) '));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.eHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 16737894;
      DrawText('|', Point(xPos, y+1));
      Inc(xPos, TextWidth('|'));

      // SE portal
      DrawColor := 65535;
      if Self.SEShielded then DrawText('(SE)', Point(xPos, y+1))
      else DrawText('SE:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(SE)'));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.seHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 65535;
      DrawText('|', Point(xPos, y+1));
      Inc(xPos, TextWidth('|'));

      // SW portal
      DrawColor := 3355647;
      if Self.SWShielded then DrawText('(SW)', Point(xPos, y+1))
      else DrawText('SW:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(SW)'));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.swHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 3355647;
      DrawText('|', Point(xPos, y+1));

      FontSize := 12;
      y += ROW_GAP+2;
    end;

    DrawColor := HUD_SEP_COLOR;
    DrawBoxFilled(Box(abox.X1 + 6, footerBox.Y1, abox.X2 - 6, footerBox.Y1 + SEP_HEIGHT - 1));
    FontSize := 12;
    DrawColor := HUD_HEADER_TEXT;
    DrawText('Author: footballjds', Point(abox.X1 + PAD, footerBox.Y1 + 5));

    EndUpdate();
  end;
end;

function TPestControl.InBoat(): Boolean;
const
  ptsBox: TBox = [7, 62, 77, 80];
begin
  result := (target.CountColor(16777113, 0, ptsBox) = 140);
end;

procedure TPestControl.ReadPoints();
var
  blueNumber: Int32;
begin
  if not Self.InBoat() then Exit;
  blueNumber := OCR.RecognizeNumber(PCData.OCR.PointsBox, RSFonts.PLAIN_12, [16777113], 0);
  if self.PtsStart < 0 then
    self.PtsStart := blueNumber;
  self.PtsTotal := blueNumber;
  self.PtsEarned := self.PtsTotal-self.PtsStart;
end;

function TPestControl.PlatformCenter(var tpOut: TPoint): Boolean;
var
  platPts: TPointArray;
begin
  platPts := Target.FindColor(2782859, 0, Minimap.Bounds);
  if platPts.Length < 1300 then Exit;
  Result := true;
  tpOut := platPts.Mean();
end;

function TPestControl.AtKnight(): Boolean;
var
  platMean: TPoint;
begin
  if not Self.PlatformCenter(platMean) then Exit;
  Result := Distance(Minimap.Center, platMean)
          < 13 + 3 * bhM.U + Random(-1, 1);
end;

function TPestControl.AtBoatPlank(pos: TPoint): Boolean;
begin
  Result := Distance(pos, Self.AtPlank) < 5+5*bhM.U;
end;

procedure TPestControl.UpdateAttkDelay();
var
  candidate: UInt64;
begin
  candidate := ExpoGaussRT(Self.Tempo.LowMeanGame);
  if Self.NextAttkDelay > 0 then
  begin
    if Random() < (0.05 + 0.10 * Self.RT[2].U) then
      Self.NextAttkDelay := candidate
    else
      Self.NextAttkDelay := Round(Self.Tempo.LowStick * Self.NextAttkDelay
        + (1.0 - Self.Tempo.LowStick) * candidate);
  end else
    Self.NextAttkDelay := candidate;
  if Self.UserDisableHUD then
    Logger.Info('UpdateAttkDelay: %d', [Self.NextAttkDelay]);
end;

procedure TPestControl.UpdateXPAttkDelay();
var
  candidate: UInt64;
begin
  candidate := ExpoGaussRT(Self.Tempo.XPMeanGame);

  if Self.XPAttkDelay > 0 then
  begin
    if Random() < (0.05 + 0.10 * Self.RT[2].U) then
      Self.XPAttkDelay := candidate
    else
      Self.XPAttkDelay := Round(Self.Tempo.XPStick * Self.XPAttkDelay
        + (1.0 - Self.Tempo.XPStick) * candidate);
  end else
    Self.XPAttkDelay := candidate;
  if Self.UserDisableHUD then
    Logger.Info('New XP AttackDelay: %d', [Self.XPAttkDelay]);
end;

procedure TPestControl.UpdateXP();
var
  nXP: UInt64;
begin
  nXP := XPBar.Read;
  if nXP > Self.LastXP then
  begin
    if (Time-Self.LastXPTime) > Self.XPAttkDelay then
      Self.UpdateXPAttkDelay();
    Self.LastXP := nXP;
    Self.LastXPTime := Time;
  end;
end;

function TAntiban.TaskDue(): Boolean;
var
  i: Int32;
  activeTasks: PAntibanTaskArray;
begin
  if Self.DoingAntiban then
    Exit(False);

  activeTasks := Self.GetActiveTasks();
  for i := 0 to High(activeTasks) do
    if activeTasks[i]^.Countdown.Remaining = 0 then
      Exit(True);

  Result := False;
end;


function TAntiban.BreakDue(): Boolean;
var
  i: Int32;
  t: UInt64;
begin
  if Self.DoingAntiban then
    Exit(False);

  t := GetTimeRunning();
  for i := 0 to High(Self.Breaks) do
    if t > Self.Breaks[i].Next then
      Exit(True);

  Result := False;
end;


function TAntiban.SleepDue(): Boolean;
var
  i: Int32;
  t: UInt64;
begin
  if Self.DoingAntiban then
    Exit(False);

  t := GetTimeRunning();
  for i := 0 to High(Self.Sleeps) do
    if t > Self.Sleeps[i].Next then
      Exit(True);

  Result := False;
end;


function TPestControl.GetState(): EPestState;
var
  tmpP: TPoint;
begin
  if Activity.IsFinished then
    Exit(EPestState.NO_ACTIVITY);

  if (Self.MaxActions > 0) and (Self.Actions >= Self.MaxActions) then
    Exit(EPestState.MAX_ACTIONS);

  if (Self.MaxTime > 0) and (GetTimeRunning() >= Self.MaxTime) then
    Exit(EPestState.MAX_TIME);

  if not RSClient.IsLoggedIn() then
    Exit(EPestState.LOGIN);

  if Self.CombatLevel < 40 then
    Exit(EPestState.CMBT_LVL);

  if Antiban.TaskDue() then
    Exit(EPestState.ANTIBAN);

  if Antiban.BreakDue() then
    if not Self.InGame() then
      Exit(EPestState.BREAK);

  if Antiban.SleepDue() then
    if not Self.InGame() then
      Exit(EPestState.SLEEP);

  if Self.InBoat() then Exit(EPestState.IN_BOAT);

  if Self.InGame() then
  begin
    if not Self.UserDisableLeaveGame and not Self.Flag.NoLeave and (Self.ReadPortalHP >= 50+199*bhM.U)
      and (Self.ReadActivityBar() < 1) then
        Exit(EPestState.EXIT_GAME);
    if Self.AtKnight() then Exit(EPestState.DEFEND);
    Exit(EPestState.WALK_MID);
  end;
  tmpP := Map.Position();
  if Self.AtBoatPlank(tmpP) then
  begin
    if Self.UserSpendPoints and (Self.PtsTotal > Self.UserSpendPointsAt) and
      (Self.PtsTotal > Self.PtsPerGame) then
      Exit(EPestState.SPEND_PTS);
    Exit(EPestState.AT_PLANK);
  end;

  if PCData.OutpostIsland.Contains(tmpP) then
    Exit(EPestState.WALK_PLANK);

  result := EPestState.UNKNOWN;
end;

function TPestControl.PrayerSample(): UInt64;
var
  shape, scale: Double;
begin
  // Shape: How decision probability builds over time
  shape := Random(1.4, 1.5) + 1 * Self.P[1].U;

  // Scale: Typical timing
  scale := 5500 + GaussRand(400,125) + 6000 * Self.P[0].U;

  // Session variance: This game's randomness
  scale := scale * (0.8 + (0.4 + Self.P[2].U/5) * Random());

  // Sample from Weibull
  Result := Round(WeibullEx(shape, scale));

  if Self.UserDisableHUD then
    Logger.Info('PrayerSample: %.2fs (k=%.2f, Î»=%.0fms)',
      [Result / 1000.0, shape, scale]);
end;

procedure TPestControl.UpdateCmbtLvl();
const
  cbBox: TBox = [661, 229, 682, 244];
begin
  if InRange(Self.UserCombatLevel, 40, 126) then
    Self.CombatLevel := Self.UserCombatLevel
  else if GameTabs.Open(ERSGameTab.COMBAT) then
  begin
    Sleep(ExpoGaussRT(Self.bRT));
    Self.CombatLevel := OCR.RecognizeNumber(cbBox.Expand(3), RSFonts.PLAIN_11, [2070783], 0);
  end;
  Logger.Info('Combat Level: %d', [Self.CombatLevel]);
  XPBar.Read;
  if Self.CombatLevel >= 100 then
  begin
    Self.BoatBox := PCData.Vet.BoatBox;
    Self.AtPlank := PCData.Vet.AtPlank;
    Self.CrossPlank := PCData.Vet.PlankObj;

    Self.Shifter.Finder.ColorClusters += [[
      [$33C1E7, 4.010, EColorSpace.HSL, [1.562, 0.510, 0.930]],
      [$223B53, 0.882, EColorSpace.HSL, [1.421, 1.254, 0.326]],
      3
    ]];
    Self.Shifter.Finder.ColorClusters += [[
      [$B0BBB7, 1.153, EColorSpace.HSL, [0.506, 1.932, 0.563]],
      [$8E848A, 0.757, EColorSpace.HSL, [0.911, 1.517, 0.574]],
      3
    ]];
  end
  else if Self.CombatLevel >= 70 then
  begin
    Self.BoatBox := PCData.Inter.BoatBox;
    Self.AtPlank := PCData.Inter.AtPlank;
    Self.CrossPlank := PCData.Inter.PlankObj;

    //gold and brown shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$243E56, 1.203, EColorSpace.HSL, [1.022, 1.336, 0.644]],
      [$23BEE5, 4.008, EColorSpace.HSL, [1.359, 0.417, 1.226]],
      3
    ]];

    //red and black shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$505061, 1.477, EColorSpace.HSV, [0.737, 1.700, 0.564]],
      [$2133BF, 0.717, EColorSpace.HSL, [1.267, 1.196, 0.539]],
      3
    ]];

    //green shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$137C71, 1.936, EColorSpace.RGB, [0.534, 0.511, 1.957]],
      [$3C5624, 0.965, EColorSpace.HSL, [1.251, 1.181, 0.570]],
      3
    ]];
  end
  else if Self.CombatLevel >= 40 then
  begin
    Self.BoatBox := PCData.Nov.BoatBox;
    Self.AtPlank := PCData.Nov.AtPlank;
    Self.CrossPlank := PCData.Nov.PlankObj;

    //red shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$2234C2, 0.738, EColorSpace.HSL, [1.289, 1.289, 0.424]],
      [$242B76, 0.689, EColorSpace.HSL, [1.510, 0.899, 0.593]],
      3
    ]];
    //green shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$137C71, 1.936, EColorSpace.RGB, [0.534, 0.511, 1.957]],
      [$3C5624, 0.965, EColorSpace.HSL, [1.251, 1.181, 0.570]],
      3
    ]];
  end
  else
    TerminateScript('[INIT] Combat level too low: ' + ToStr(Self.CombatLevel));

  Self.Gangplank := TRSObject.Create(@Map.Walker, [1, 1, 1], [Self.CrossPlank], ['Cross Gang']);
end;

function SoftBehaviorSelect(): Int32;
var
  u: Double;
  probs: array[0..3] of Double;
  r, cumulative: Double;
  i: Int32;
begin
  u := PestControl.Flag.Choices.Get('BoatBehavior');
  // Overlapping Gaussians centered at 0.25, 0.5, 0.75, 0.9
  probs[0] := Exp(-Sqr((u - 0.25) / 0.2));
  probs[1] := Exp(-Sqr((u - 0.50) / 0.2));
  probs[2] := Exp(-Sqr((u - 0.75) / 0.2));
  probs[3] := Exp(-Sqr((u - 0.90) / 0.15));

  // Normalize and sample
  cumulative := 0;
  for i := 0 to 3 do cumulative += probs[i];
  r := Random() * cumulative;
  cumulative := 0;
  for i := 0 to 3 do
  begin
    cumulative += probs[i];
    if r < cumulative then Exit(i);
  end;
  Result := 3;
end;

function TPestControl.BoatMoveSample(): UInt64;
var
  shape, scale: Double;
begin
  shape := 1.3 + 1.2 * Self.M[0].U;  // 1.3-2.5, increasing hazard
  scale := 8000 + 20000 * Self.M[1].U;  // 8-28s base
  scale := scale * TruncGauss(1.0, 0.15, 0.7, 1.3);  // per-sample variance
  Result := Round(WeibullEx(shape, scale));
end;

procedure TPestControl.MoveInBoat();

var
  boatArea: TBox;
  current, target, mean: TPoint;
  destMS: TQuad;
  weight, bias: Single;
  primary, behavior: Int32;
begin
  Self.CloseSkillInterface();
  if Self.Flag.NoBoatMove then Exit;
  if Time < (Self.LastBoatMove + Self.BoatMoveDelay) then Exit;
  if not Self.InBoat() then Exit;

  boatArea := Self.BoatBox.Expand(Random(-4, 6 - Round(4 * bhM.U)));
  current := Map.Position();

  primary := SoftBehaviorSelect();

  if Random() < 0.60 + 0.35 * bhM.U then
    behavior := primary
  else
    behavior := Biometrics.RandomModeInteger(primary, 0, 3);

  case behavior of
    0: mean := [boatArea.Center.X, boatArea.Y2 - boatArea.Height div 4];
    1: mean := [boatArea.X2 - (current.X - boatArea.X1), boatArea.Y2 - (current.Y - boatArea.Y1)];
    2: begin
         mean.X := EnsureRange(boatArea.X2 - (Self.AtPlank.X - boatArea.X1), boatArea.X1, boatArea.X2);
         mean.Y := EnsureRange(boatArea.Y2 - (Self.AtPlank.Y - boatArea.Y1), boatArea.Y1, boatArea.Y2);
       end;
    else mean := boatArea.RandomPoint();
  end;

  weight := 2 + 8 * bhM.U;      // 2-10
  bias := 0.5 + 1.0 * _bhM.U;   // 0.5-1.5

  target := boatArea.RandomWeightedPoint(mean, weight, bias);
  if current.DistanceTo(target) < 5 + 3 * bhM.U then
    target := boatArea.RandomWeightedPoint(
      [boatArea.X1 + boatArea.X2 - mean.X, boatArea.Y1 + boatArea.Y2 - mean.Y],
      weight * 0.5, bias * 1.5);

  destMS := Map.Walker.GetQuadMS(current, target, [1], Minimap.CompassRadians);
  if not Mainscreen.Bounds.ContainsQuad(destMS) then
    Exit;
  if randomBoolean(0.05*bhm.U) then
    Mouse.Move(Mainscreen.Bounds, True, EMouseDistribution.GAUSS)
  else
    Mouse.Move(destMS, True, EMouseDistribution.GAUSS);

  Sleep(ExpoGaussRT(Self.bRT * 0.8));
  if not Self.InBoat() then Exit;

  if MainScreen.IsUpText('Walk here') then
    Mouse.Click(EMouseButton.LEFT)
  else if ChooseOption.Open() then
    ChooseOption.Select('Walk here');

  Self.LastBoatMove := Time;
  Self.BoatMoveDelay := Self.BoatMoveSample();
  Logger.Info('BoatMoveDelay: %dms', [Self.BoatMoveDelay]);
end;

procedure TPestControl.WhileInBoat();
begin
  if not Self.UserDisableMoveInBoat then Self.MoveInBoat();
  Sleep(ExpoGaussRT());
end;

//function from include, I am not author
function TRSChat.ReadPointsOption(): String;
var
  option: TRSChatOption;
begin
  for option in Self.GetOptions([$000080]) do
  begin
    if Result <> '' then Result += LINE_SEP;
    Result += option.Text;
  end;
  result := ToStr(result.ExtractInteger());
end;

procedure TPestControl.SetPerGame();
var
  driftX, driftY: Int32;
  errRate: Double;
begin
  {$IFDEF WL_FATIGUE_INCLUDED}
    errRate := Fatigue.ErrorRate;
  {$ENDIF}
  Self.Flag.NoPray := RandomBoolean(errRate + 0.001347 + 0.026438 * Self.Flag.Choices[0].U);
  Self.Flag.NoLeave := RandomBoolean(errRate + 0.00173 + 0.09573 * Self.Flag.Choices[1].U);
  Self.Flag.NoBoatMove := RandomBoolean(Power(Self.Flag.Choices[2].U, 3) * 0.10 * (1 + Self.Flag.Choices[3].U));
  Self.Flag.DelayBoatMove := RandomBoolean(0.15 + 0.55 * Power(Self.Flag.Choices[4].U, 0.7));

  Logger.Info('Self.Flag errRate %.2f', [errRate]);
  Logger.Info('Self.Flag.NoPray: %s', [toStr(Self.Flag.NoPray)]);
  Logger.Info('Self.Flag.NoLeave: %s', [toStr(Self.Flag.NoLeave)]);
  Logger.Info('Self.Flag.NoBoatMove: %s', [toStr(Self.Flag.NoBoatMove)]);
  Logger.Info('Self.Flag.DelayBoatMove: %s', [toStr(Self.Flag.DelayBoatMove)]);

  Self.Deseq.WinThreshGame := TruncGauss(1.0, 0.08, 0.85, 1.15);
  Self.Deseq.InactiveThreshGame := TruncGauss(1.0, 0.08, 0.85, 1.15);
  Self.Deseq.WinNoise := 1.0;
  Self.Deseq.InactiveNoise := 1.0;
  Self.Deseq.LastNoiseReroll := 0;
  Self.Deseq.KnightHPLvl := Random(80, 100);

  // Per-game position preference drift (Â±3-8  based on biometric)
  driftX := Round(GaussRand(0, 2 + 3 * bhM.U));
  driftY := Round(GaussRand(0, 2 + 3 * _bhM.U));
  Self.Flag.GameKnightOffset := Point(driftX, driftY);

  // Drift tempo per game
  Self.Tempo.XPMeanGame := Round(Self.Tempo.XPMean *
    TruncGauss(1.05, 0.07, 0.95, 1.15));
  Self.Tempo.LowMeanGame := Round(Self.Tempo.LowMean *
    TruncGauss(1.05, 0.07, 0.95, 1.15));

  Logger.Info('Self.Tempo.XPMeanGame %d', [Self.Tempo.XPMeanGame]);
  Logger.Info('Self.Tempo.LowMeanGame %d', [Self.Tempo.LowMeanGame]);

  Self.PrayerEnableTime := Self.PrayerSample();
  if Self.Flag.DelayBoatMove then
  begin
    Self.LastBoatMove := Time;
    Self.BoatMoveDelay := Self.BoatMoveSample();
    Logger.Info('BoatMoveDelay: %d', [Self.BoatMoveDelay]);
  end;
  Self.ReadPoints();
  Activity.Restart();
  Self.Actions+=1;
  Self.ActivityThresh := EnsureRange(Self.UserActiveThreshold + Round(GaussRand(0, 2.5)), 50, 100);
end;

procedure TPestControl.WaitAfterGame();
var
  baseMult: Double;
  restTime, restUntil: UInt64;
  checkTask, checkBreak, checkSleep: Boolean;
begin
  if not Self.UserRestAfterGame then Exit;

  if SoftRandBool(HashToU('restskip'), 1.5, 0.25) then
  begin
    Sleep(SampleRT(Self.bRT * RandomRight(1.5, 3.0)));
    Exit;
  end;

  baseMult := 8.0 + 40.0 * Power(HashToU('restbase'), 0.7 + HashToU('restpow'));
  restTime := EnsureRange(
    SampleRT(Self.bRT * baseMult * TruncGauss(1.0, 0.15, 0.7, 1.4)),
    Self.bRT * 3,
    Self.bRT * 120
  );
  restUntil := Time() + restTime;

  checkTask := not SoftRandBool(HashToU('checkTaskRest'), 2.0, 0.15);
  checkBreak := not SoftRandBool(HashToU('checkBreakRest'), 2.0, 0.25);
  checkSleep := not SoftRandBool(HashToU('checkSleepRest'), 2.0, 0.90);

  Logger.Info('WaitAfterGame: %.1fs (T=%s|B=%s|S=%s)',
    [restTime / 1000.0, ToStr(checkTask), ToStr(checkBreak), ToStr(checkSleep)]);

  while Time() < restUntil do
  begin
    Antiban.DoAntiban(checkTask, checkBreak, checkSleep);
    Sleep(LogNormalRT(Self.bRT * (3.0 + 7.0 * HashToU('restpace'))));
  end;
end;

procedure TPestControl.EnterBoat();
begin
  Self.CloseSkillInterface();
  Self.WaitAfterGame();

  if Chat.IsTitle('~ Warning ~') then
    TerminateScript('Too many points '+Chat.ReadPointsOption());
  try
    if Self.Gangplank.Click(True, 1 + Round(3*bhM.U)) then
      if SleepUntil(Self.InBoat, 50, Round(GaussRand(3000, 200))) then
      begin
        Self.SetPerGame();
        Sleep(ExpoGaussRT(Self.bRT * 3.9));
        if not InRange(Options.GetZoomLevel(True), 30, 50) then
          if Options.SetZoomLevel(RandomMode(35+Round(10*bhM.U), 30, 50)) then
            WriteLn GetDebugLn('Options', 'Zoom adjusted level: ' + ToString(Options.ZoomLevel), ELogLevel.SUCCESS);
        Exit;
      end;
  except Logger.Error('Exception in EnterBoat: %s', [GetExceptionMessage]); end;
end;

procedure TPestControl.EnablePrayerCheck();
begin
  if (not Self.Flag.NoPray) and Self.UserQuickPrayer and Self.GameStarted and
    (not Minimap.PrayerEnabled) and Self.InGame() and
    (Time > (Self.GameStart + Self.PrayerEnableTime)) and
    (Self.ReadPortalHP > Round(50 + 150*bhM.U)) then
      if Minimap.EnablePrayer() then
      begin
        if Biometrics.RandomBoolean() then
          Sleep(ExpoGaussRT(Self.bRT*(0.3+random(0.01, 2.1))));
        if Biometrics.RandomBoolean(0.23) then
          Mouse.Move(Mainscreen.Bounds, True);
      end;
end;

procedure TPestControl.WalkToDefend();
var
  uniqueMiddle, midP, msP: TPoint;
begin
  Sleep(ExpoGaussRT(Self.bRT * 1.7));

  {$IFDEF WL_FATIGUE_INCLUDED}
  if Fatigue.ShouldLapse then
    Sleep(LogNormalInt(Self.bRT, 0.35 + 0.1 * Self.RT[0].u));
  {$ENDIF}

  if not Self.InGame() then Exit;
  if not Self.GameStarted then
  begin
    Self.GameStarted := True;
    Self.GameStart := Time;
  end;

  Self.EnablePrayerCheck();
  if Self.PlatformCenter(midP) then
  begin
    uniqueMiddle := midP;
    uniqueMiddle.X += Biometrics.RandomModeInteger(9, -9, 9);
    uniqueMiddle.Y += Biometrics.RandomModeInteger(9, -9, 9);
    msP := Minimap.Point2MS(uniqueMiddle, Minimap.CompassRadians);
    if Mainscreen.Bounds.Contains(msP) then
    begin
      msP := [EnsureRange(msP.X + Random(-12, 12), MainScreen.Bounds.X1,
         MainScreen.Bounds.X2), EnsureRange(msP.Y + Random(-12, 12),
         MainScreen.Bounds.Y1, MainScreen.Bounds.Y2)];
      if Mainscreen.Bounds.Contains(msP) then
      begin
        Mouse.Click(msP, EMouseButton.LEFT);
        if RandomBoolean(0.63+0.30*bhM.U) and SoftRandBool(_bhM.U, 2, 0.95) then
        begin
          Minimap.WaitMoving(Round(Self.bRT*Random(100, 200)));
          Sleep(ExpoGaussRT(Self.bRT*RandomLeft(0.7, 3.1)));
        end else
          Sleep(ExpoGaussRT(Self.bRT*GaussRand(10, 2.5)));
        Exit;
      end;
    end;
  end;
  uniqueMiddle := PCData.Knight.Offset(Self.Flag.GameKnightOffset);
  uniqueMiddle.X += Biometrics.RandomModeInteger(0, -6, 6);
  uniqueMiddle.Y += Biometrics.RandomModeInteger(0, -6, 6);
  try
    Logger.Info('Walk to middle: ' + ToStr(Map.Walker.WebWalk(uniqueMiddle, 7+Round(5*bhM.U), 0.2+0.4*_bhM.U)));
  except Logger.Error('WalkToDefend exception: %s', [GetExceptionMessage]); end;
end;

procedure DebugShifterClusters(constref Shifter: TRSEntity);
var
  img: TImage;
  atpa: T2DPointArray;
  coordinates: TPointArray;
  i, totalPixels: Integer;
  avgSize, minSize, maxSize: Integer;
begin
  img := Target.GetImage();

  // Try to find shifters
  if Shifter.Find(coordinates, atpa) then
  begin
    WriteLn('=== SHIFTER DETECTION DEBUG ===');
    WriteLn('Found ', Length(atpa), ' potential shifter(s)');
    WriteLn();

    minSize := High(Integer);
    maxSize := 0;
    totalPixels := 0;

    // Analyze each detected cluster
    for i := 0 to High(atpa) do
    begin
      WriteLn('Cluster #', i + 1, ':');
      WriteLn('  Coordinate: ', coordinates[i]);
      WriteLn('  Pixel count: ', Length(atpa[i]));
      WriteLn('  Bounds: ', atpa[i].Bounds());
      WriteLn();

      totalPixels += Length(atpa[i]);
      if Length(atpa[i]) < minSize then minSize := Length(atpa[i]);
      if Length(atpa[i]) > maxSize then maxSize := Length(atpa[i]);

      // Draw on image
      img.DrawColor := $00FF00;
      img.DrawTPA(atpa[i]);
      img.DrawBox(atpa[i].Bounds());
      img.DrawText('Cluster ' + ToStr(i+1) + ': ' + ToStr(Length(atpa[i])) + 'px',
                   atpa[i].Bounds().TopLeft);
    end;

    if Length(atpa) > 0 then
    begin
      avgSize := totalPixels div Length(atpa);
      WriteLn('=== STATISTICS ===');
      WriteLn('Average cluster size: ', avgSize, ' pixels');
      WriteLn('Min cluster size: ', minSize, ' pixels');
      WriteLn('Max cluster size: ', maxSize, ' pixels');
      WriteLn();
      WriteLn('RECOMMENDATION:');
      if minSize > 50 then
        WriteLn('  Current ColorCluster "3" parameter might be too low.')
      else if maxSize < 20 then
        WriteLn('  Detection might be too sensitive. Consider stricter tolerances.')
      else
        WriteLn('  Cluster sizes look reasonable (', minSize, '-', maxSize, ' pixels)');
    end;
  end else
    WriteLn('NO SHIFTERS DETECTED');

  // Draw entity info
  img.DrawColor := $00FFFF;
  img.DrawText('ColorClusters: ' + ToStr(Length(Shifter.Finder.ColorClusters)), [10, 30]);
  img.DrawText('Transformer.Distance: ' + ToStr(Shifter.Finder.Transformer.Distance), [10, 50]);
  img.DrawText('Transformer.ShortSide.Min: ' + ToStr(Shifter.Finder.Transformer.ShortSide.Min), [10, 70]);

  img.Show();
end;

function TPestControl.MapPos: TPoint;
var
  radians: Single;
  platMM: TPoint;
begin
  if not Self.PlatformCenter(platMM) then
    Exit(Map.Position());
  radians := Minimap.CompassRadians;
  Result := Self.Center + Minimap.Center - platMM.Rotate(-radians, Minimap.Center);
end;

function TPestControl.FindShifters(out atpa: T2DPointArray): Boolean;
var
  coords: TPointArray;
  bounds: TPolygonArray;
begin
  Result := Self.Shifter.FindEx(Self.MapPos, bounds, coords, atpa);
end;

function TPestControl.ChooseStrategy(): EAttackChoice;
var
  r: Double;
begin
  if (Random() < Self.AttackStick) then
    Exit(Self.AttackChoice);

  r := Random();
  if r < Self.AttackWeights[0] then
    Result := EAttackChoice.Self
  else if r < (Self.AttackWeights[0] + Self.AttackWeights[1]) then
    Result := EAttackChoice.Knight
  else
    Result := EAttackChoice.Rand;
end;

procedure TPestControl.SortByStrategy(strategy: EAttackChoice; var atpa: T2DPointArray);
var
  platMM, knightMS: TPoint;
begin
  case strategy of
    EAttackChoice.Self:
      atpa := atpa.SortFrom(MainScreen.PlayerBox.Center);

    EAttackChoice.Knight:
      begin
        if Self.PlatformCenter(platMM) then
          knightMS := Minimap.Point2MS(platMM, Minimap.CompassRadians)
        else
          knightMS := MainScreen.Bounds.Center;
        atpa := atpa.SortFrom(knightMS);
      end;

    EAttackChoice.Rand:
      ; // No sorting needed
  end;
end;

function TPestControl.PickIndex(len: Int32; strategy: EAttackChoice): Int32;
var
  lambda, alpha, cumulative, r: Double;
  probs: TDoubleArray;
  i: Int32;
begin
  if len = 1 then Exit(0);
  if strategy = EAttackChoice.Rand then Exit(Random(len));

  SetLength(probs, len);

  // Calculate raw probabilities
  if RandomBoolean(Self.attkC[5].U) then
  begin
    lambda := 0.3 + 1.7 * Self.attkC[6].U;
    for i := 0 to len - 1 do
      probs[i] := Exp(-lambda * i);
  end
  else
  begin
    alpha := 0.5 + 1.5 * Self.attkC[6].U;
    for i := 0 to len - 1 do
      probs[i] := 1.0 / Power(i + 1, alpha);
  end;

  // Normalize
  cumulative := 0;
  for i := 0 to len - 1 do
    cumulative += probs[i];
  for i := 0 to len - 1 do
    probs[i] := probs[i] / cumulative;

  // Sample using cumulative distribution
  r := Random();
  cumulative := 0;
  for i := 0 to len - 1 do
  begin
    cumulative += probs[i];
    if r < cumulative then
      Exit(i);
  end;

  Result := len - 1;
end;

function TPestControl.AttackShifter(debug: Boolean = False): Boolean;
var
  atpa: T2DPointArray;
  strategy: EAttackChoice;
  idx: Int32;
begin
  if debug then DebugShifterClusters(Self.Shifter);

  try
    if not Self.FindShifters(atpa) then Exit(False);
    Sleep(ExpoGaussRT(Self.bRT*0.7));

    {$IFDEF WL_FATIGUE_INCLUDED}
    if Fatigue.ShouldLapse() then
    begin
      Sleep(ExpoGaussRT(Self.bRT*1.8));
      GetDebugLn('Fatigue lapse', ELogLevel.WARN, False);
      if Biometrics.RandomBoolean then
        Exit();
    end;
    {$ENDIF}

    strategy := Self.ChooseStrategy();
    Self.SortByStrategy(strategy, atpa);
    idx := Self.PickIndex(Length(atpa), strategy);

    Mouse.Move(atpa[idx].RandomMean());

    if MainScreen.IsUpText(Self.Shifter.UpText) then
      Result := Biometrics.RedClick(EMouseButton.LEFT);

    if Result then
    begin
      Self.AttackChoice := strategy;
      Self.AttackIndex := idx;
    end;

  except
    Logger.Error('AttackShifter exception: %s', [GetExceptionMessage]);
  end;
end;

procedure TPestControl.RerollDeseqNoise();
begin
  if Time < Self.Deseq.LastNoiseReroll + Self.Deseq.NoiseInterval then Exit;
  Self.Deseq.WinNoise := TruncGauss(1.0, 0.05, 0.9, 1.1);
  Self.Deseq.InactiveNoise := TruncGauss(1.0, 0.07, 0.85, 1.15);
  Self.Deseq.NoiseInterval := Round((3000 + 5000 * Power(Self.Deseq.U[0].U, 0.5 +
    Self.Deseq.U[1].U)) * TruncGauss(1.0, 0.15, 0.7, 1.3));
  Self.Deseq.LastNoiseReroll := Time;
end;

function TPestControl.UserIsWinning(): Boolean;
var
  portalThresh, timeThresh: Double;
  gameTime: UInt64;
  useTime: Boolean;
begin
  Result := False;
  Self.RerollDeseqNoise();

  // Per-account portal threshold: 200-500, power-transformed
  portalThresh := (200 + 300 * Power(Self.Deseq.U[0].U, 0.5 + 1.5 * Self.Deseq.U[1].U))
                * Self.Deseq.WinThreshGame * Self.Deseq.WinNoise;

  // Some accounts factor in game time
  useTime := Self.Deseq.U[2].U > 0.6;
  gameTime := Time - Self.GameStart;

  if useTime then
  begin
    // Time-based: game > 80-100s AND portals below threshold
    timeThresh := 80000 + 20000 * Self.Deseq.U[2].U;
    Result := (gameTime > timeThresh) and (Self.ReadPortalHP < portalThresh);
  end
  else
    Result := Self.ReadPortalHP < portalThresh;

  // Knight safety factor: some accounts also check knight HP
  if Result and (Self.Deseq.U[3].U > 0.5) then
    Result := Self.ReadKnightHP > 50 + Round(Self.Deseq.KnightHPLvl * Self.Deseq.U[3].U);
end;

function TPestControl.UserIsInactive(): Boolean;
var
  source: UInt64;
  thresh: Double;
begin
  Result := False;
  Self.RerollDeseqNoise();

  // Per-account source: LastAttack vs LastXPTime
  if Self.Deseq.U[4].U < 0.5 then
    source := Time - Self.LastAttack
  else
    source := Time - Self.LastXPTime;

  // Per-account threshold: 4-15s, power-transformed
  thresh := (4000 + 11000 * Power(Self.Deseq.U[5].U, 0.5 + 1.5 * Self.Deseq.U[6].U))
          * Self.Deseq.InactiveThreshGame * Self.Deseq.InactiveNoise;

  Result := source > thresh;
end;

//emote help
//use: Self.eHelper(Random(Self.UserEmoteList.Length));
procedure TPestControl.eHelper();
var
  i, limit: Integer;
begin
  if Time() < (Self.LastEmoteMS + Self.EmoteDelayMS) then
    Exit();
  limit := Self.UserEmoteAmount;
  for i := 0 to limit do
  begin
    Emotes.UseEmote(ERSEmote(Random(Self.UserEmoteList.Length)));
    //sifferent players mean sleep, 2s to 6s, expogaussianRT?
  end;
  // then do emote and set last emote time
  //for i := something down to 0 do
  //decay. powerlaw, idk what, every account has different max, every accounts min is 1, all have different means?
  // what is healthiest?
  //Self.UserEmoteAmount
  Self.LastEmoteMS := Time();
end;

procedure TPestControl.PaceInGame();
begin
  if Self.UserDisablePace then Exit();
  Self.WalkToDefend();
  Sleep(ExpoGaussRT(Self.bRT*3*_bhM.u));
end;

procedure TPestControl.ChillActivities();
var
  t: Int64 = 0;
begin
  if not Self.UserChillIfActive then Exit();
  if Self.ReadActivityBar > Self.ActivityThresh then
    t := Time() + ExpoGaussRT(Self.XPAttkDelay);
  //t can be based off player's last XPAttackDelay so it is relatively
  //in tempo, but it can be further decorrelated if needed
  while (t > Time()) and Self.InGame() do
  begin
    Sleep(ExpoGaussRT(Self.bRT));
    //randomized order of chill activities
    //what antiban we check can decorrelate accounts
    //some dont even check at all
    //Antiban.DoAntiban(false, false, false);

    //maybe some/most/all/sometimes accounts should add more time
    //if still above threshold instead of exiting to defend
    if (Self.ReadActivityBar > Self.ActivityThresh) and
      ((t - Time()) < Self.bRT) then
        t := Time() + ExpoGaussRT(Self.NextAttkDelay);
  end;
  //maybe change activityThresh mid game, maybe a better way

  if Biometrics.RandomBoolean() then
    Self.ActivityThresh := EnsureRange(Self.UserActiveThreshold +
      Round(GaussRand(0, 2.5)), 50, 100);
end;

procedure TPestControl.InactiveActivities();
begin
  //no user choice for inactive, we can disperse best to beat
  //serverside anticheat

  //if Self.FindShifters(atpa) then Exit();
end;

function TPestControl.Desequence(): Boolean;
begin
  Result := False;
  Self.ChillActivities();
  //respecting user choices, de-sequence accounts
end;

procedure TPestControl.DefendKnight();
begin
  Sleep(ExpoGaussRT(Self.bRT*0.8));
  Self.UpdateXP();
  if (Time - Self.LastXPTime) < Self.XPAttkDelay then Exit;
  if (Time - Self.LastAttack) < Self.NextAttkDelay then Exit;
  if not Self.InGame() then Exit;
  if Biometrics.RandomBoolean() then
    Self.EnablePrayerCheck();

  if Self.Desequence() then
    if Biometrics.RandomBoolean() then
      Exit();

  if Self.AttackShifter({true}) then
  begin
    Activity.Restart();
    Self.LastAttack := Time;
    Self.UpdateAttkDelay();
    Sleep(ExpoGaussRT(Self.bRT*2.2));
  end;
  Self.EnablePrayerCheck();
end;

procedure TPestControl.LeaveTheGame();
begin
  if not Self.InGame() then Exit;
  Sleep(ExpoGaussRT(Self.bRT * 3.3));
  if not Self.InGame() then Exit;
  try
    Writeln('Distance to Squire: ', Self.Squire.DistanceTo(Map.Position()));
    if not Self.InGame() then Exit;
    if Self.Squire.DistanceTo(Map.Position()) > (8+Random(4)+Round(5*bhM.U)) then
      if Map.Walker.WebWalk(Self.Squire.Coordinates[0].Offset(Random(-5, 5),
        Random(5, 10)), 3+Round(3*(bhM.U)), 0.2+0.5*bhM.U) then
          Writeln('Walked towards Squire');
    if not Self.InGame() then Exit;
    if Self.Squire.Interact(['Leave Squire', 'eave Squire'], 1+Round(3*bhM.U)) then
    begin
      Self.LeaveGameCount+=1;
      WriteLn('Left game at ', FormatMilliseconds(GetTimeRunning, TIME_SHORT));
      SleepUntil(not Self.InGame(), Round(200+random(200)), Round(17000+9000*bhM.U));
    end else
      Writeln('Failed to leave game');
  except Writeln('TPestControl.LeaveTheGame - ', GetExceptionMessage); end;
end;

procedure TPestControl.OnWalkerEvent(walker: PRSWalker; position, destination: TPoint);
begin
  if (PCData.GameIsland.Contains(position) and PCData.OutpostIsland.Contains(destination)) or
    (PCData.OutpostIsland.Contains(position) and PCData.GameIsland.Contains(destination)) then
      begin
        walker^.Walking := False;
        if Fatigue.ShouldLapse then
          Sleep(ExpoGaussRT(Self.bRT*RandomLeft(1.1, 7.7)))
        else
          Sleep(ExpoGaussRT());
        Exit;
      end;
  if (Self.State = EPestState.WALK_MID) then
    Self.EnablePrayerCheck();
  Self.UpdateAndDrawHUD();
end;

procedure TPestControl.SetAttackTempo();
var
  bhInt: Int32;
  xpVar, lowVar: Double;
begin
  bhInt := Trunc(bhM.U * 1000);

  // Session variance (Â±8%)
  xpVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);
  lowVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);

  Self.Tempo.XPMean := Round((2573 + 990 * bhM.U) * xpVar);
  Self.Tempo.XPStick := 0.20 + 0.18 * ((bhInt shr 5) mod 1000 / 1000.0);
  Self.XPAttkDelay := ExpoGaussRT(Self.Tempo.XPMean);

  Self.Tempo.LowMean := Round((750 + 350 * _bhM.U) * lowVar);
  Self.Tempo.LowStick := 0.20 + 0.18 * (((bhInt shr 5) xor 913) mod 1000 / 1000.0);
  Self.NextAttkDelay := ExpoGaussRT(Self.Tempo.LowMean);

  Self.Tempo.XPMeanGame := Round(Self.Tempo.XPMean *
    TruncGauss(1.0, 0.07, 0.85, 1.15));
  Self.Tempo.LowMeanGame := Round(Self.Tempo.LowMean *
    TruncGauss(1.0, 0.07, 0.85, 1.15));

  Logger.Info('Self.Tempo.XPMeanGame %d', [Self.Tempo.XPMeanGame]);
  Logger.Info('Self.Tempo.LowMeanGame %d', [Self.Tempo.LowMeanGame]);
  Logger.Info('SetAttackTempo() XP: %dms(x%.2f) Low: %dms(x%.2f)',
    [Self.Tempo.XPMean, xpVar, Self.Tempo.LowMean, lowVar]);
end;

procedure TStateTimer.Add(State: EPestState; Ms: UInt64);
begin
  Self.Times[State] := Self.Times[State] + Ms;
end;

procedure TStateTimer.LogAll();
var
  State: EPestState;
begin
  WriteLn('=== State Time Report ===');
  for State := Low(EPestState) to High(EPestState) do
    if Self.Times[State] > 0 then
      WriteLn(PadR(ToStr(State), 15), ' : ', FmtTime(Self.Times[State]));
end;

procedure TPestControl.OnBreakStart(task: PBreakTask);
begin
  {$IFDEF WL_FATIGUE_INCLUDED}
  if not Self.UserDisableFatigue then
    Logger.Info('Break starting - Fatigue: %.2f%%', [Fatigue.FatigueLevel * 100]);
  {$ENDIF}
  Logger.Info('Break starting: ' + FormatMilliseconds(Round(task^.Length), TIME_FORMAL));
end;

procedure TPestControl.OnSleepStart(task: PSleepTask);
begin
  {$IFDEF WL_FATIGUE_INCLUDED}
  if not Self.UserDisableFatigue then
    Logger.Info('Sleep starting - Fatigue: %.2f%%', [Fatigue.FatigueLevel * 100]);
  {$ENDIF}
  Logger.Info('Sleep starting: ' + FormatMilliseconds(Round(task^.Length), TIME_FORMAL));
end;

procedure TPestControl.OnBreakEnd(task: PBreakTask);
begin
  Activity.Restart();
  Logger.Info('Break of ' + FormatMilliseconds(Round(task^.Length), TIME_FORMAL) + ' ended');
end;

procedure TPestControl.OnSleepEnd(task: PSleepTask);
begin
  Activity.Restart();
  Logger.Info('Sleep of ' + FormatMilliseconds(Round(task^.Length), TIME_FORMAL) + ' ended');
end;

procedure TPestControl.OnBreakingHud(task: PBreakTask; var countdown: TCountdown);
begin
  Self.UpdateAndDrawHUD(True, False, countdown.Remaining, True);
end;

procedure TPestControl.OnSleepingHud(task: PSleepTask; var countdown: TCountdown);
begin
  Self.UpdateAndDrawHUD(False, True, countdown.Remaining, True);
end;

procedure TPestControl._OnPause();
begin
  WriteLn ProgressReport.Generate(ProgressReport.ValueProvider());
  RSClient.EnableRealInput();
  RSClient.Canvas.Clear();
end;

procedure TPestControl._OnResume();
begin
  RSClient.DisableRealInput();
end;


procedure TPestControl._OnTermination();
begin
  WriteLn ProgressReport.Generate(ProgressReport.ValueProvider());
  Self.StateTimer.Add(Self.State, Time - Self.StateT);
  Self.StateTimer.LogAll();
  Writeln('STATE ON TERMINATION: '+ToStr(Self.State));
  RSClient.Canvas.Clear;
  RSClient.EnableRealInput();
end;

procedure _InitPCData();
begin
  PCData.GameIsland := [10498, 39938, 10749, 40189];
  PCData.OutpostIsland := [10501, 39700, 10736, 39916];


  PCData.Nov.AtPlank := [10630, 39874];
  PCData.Nov.PlankObj := [10633, 39874];
  PCData.Nov.BoatBox := [10640, 39856, 10655, 39879];

  PCData.Inter.AtPlank := [10578, 39854];
  PCData.Inter.PlankObj := [10572, 39854];
  PCData.Inter.BoatBox := [10552, 39840, 10567, 39863];

  PCData.Vet.AtPlank := [10554, 39818];
  PCData.Vet.PlankObj := [10548, 39818];
  PCData.Vet.BoatBox := [10524, 39810, 10544, 39838];

  PCData.Portals.W := [];
  PCData.Portals.SW := [];
  PCData.Portals.SE := [];
  PCData.Portals.E := [];

  PCData.Knight := [10626, 40061];
  PCData.Spawn := [10632, 39994];
  PCData.LeaveNPC := [10620, 40002];

  PCData.OCR.ActivBox := [365, 121, 511, 131];
  PCData.OCR.PointsBox := [72, 64, 123, 81];
  PCData.OCR.ActivGreen := 40704;
  PCData.OCR.ActivRed := 255;

  PCData.OCR.W := [370, 53, 396, 68];
  PCData.OCR.E := [406, 53, 434, 68];
  PCData.OCR.SE := [445, 53, 470, 68];
  PCData.OCR.SW := [484, 53, 507, 68];

  PCData.OCR.Shield_W := [];
  PCData.OCR.Shield_E := [];
  PCData.OCR.Shield_SE := [];
  PCData.OCR.Shield_SW := [];

  PCData.OCR.KnightHP := [34, 39, 61, 54];
end;

procedure TPestControl.InitAttackProfile();
var
  baseWeights: array[0..2] of Double;
  i: Int32;
  total: Double;
begin
  //0..7
  Self.attkC.Create(['profileU', 'selfU', 'knightU', 'randU', 'stickU', 'decayType', 'decayParam']);

  if Self.attkC[0].U < 0.5 then
    baseWeights := [55.0, 40.0, 5.0]  // Self-primary
  else
    baseWeights := [40.0, 55.0, 5.0]; // Knight-primary

  total := 0;
  for i := 0 to 2 do
  begin
    Self.AttackWeights[i] := baseWeights[i] * (0.67 + 0.66 * Self.attkC[i+1].U);
    Self.AttackWeights[i] *= EnsureRange(GaussRand(1.0, 0.04), 0.84, 1.16);
    total += Self.AttackWeights[i];
  end;

  for i := 0 to 2 do
    Self.AttackWeights[i] := Self.AttackWeights[i] / total;

  Self.AttackStick := 0.15 + 0.25 * Self.attkC[4].U;
  Self.AttackStick *= EnsureRange(GaussRand(1.0, 0.025), 0.925, 1.075);

  if Self.AttackWeights[0] > Self.AttackWeights[1] then
    Self.AttackChoice := EAttackChoice.Self
  else
    Self.AttackChoice := EAttackChoice.Knight;

  Logger.Info('Attack Profile - Self:%.1f%% Knight:%.1f%% Rand:%.1f%% Stick:%.1f%%',
    [Self.AttackWeights[0]*100, Self.AttackWeights[1]*100, Self.AttackWeights[2]*100, Self.AttackStick*100]);
end;

procedure TPestControl.SetupMouse();
var
  speedBase, gravBase, windBase: Double;
  clickMinBase, clickMaxBase: Int32;
  speedVar, gravVar, windVar, clickVar: Double;
begin
  Self.M.Create(['speed', 'gravity', 'wind', 'click min', 'click max', 'miss chance']);

  // Base values
  speedBase := 10.0 + 4.0 * Self.M[0].U;
  gravBase := 7.0 + 4.0 * Self.M[1].U;
  windBase := 3.0 + 4.0 * Self.M[2].U;
  clickMinBase := 50 + Round(30.0 * Self.M[3].U);
  clickMaxBase := 120 + Round(80.0 * Self.M[4].U);

  // Session variance (Â±8%)
  speedVar := TruncGauss(1.0, 0.04, 0.88, 1.12);
  gravVar := TruncGauss(1.0, 0.04, 0.88, 1.12);
  windVar := TruncGauss(1.0, 0.04, 0.88, 1.12);
  clickVar := TruncGauss(1.0, 0.04, 0.88, 1.12);

  // Apply variance
  Mouse.Speed := speedBase * speedVar;
  Mouse.Gravity := gravBase * gravVar;
  Mouse.Wind := windBase * windVar;
  Mouse.PressMin := Round(clickMinBase * clickVar);
  Mouse.PressMax := Round(clickMaxBase * clickVar);

  Mouse.MissChance := 0.01 + 0.03 * Self.M[5].U;

  Logger.Info('Mouse - Speed:%.2f Grav:%.2f Wind:%.2f Click:%d-%dms Miss:%.2f%%',
    [Mouse.Speed, Mouse.Gravity, Mouse.Wind, Mouse.PressMin, Mouse.PressMax, Mouse.MissChance*100]);
end;

procedure TPestControl.Init();
begin
  WriteLn('[INIT] Pest Control - SIMBA2000');
  Logger.Setup('Pest Control JDS');
  Logger.RepeatedMessages := True;

  bhM.Create('bhM');
  Self.Flag.Choices.Create(['NoPray', 'NoLeave', 'NoBoatMove1', 'NoBoatMove2', 'DelayBoatMove', 'BoatBehavior']);
  _bhM.Create('_bhM');
  Self.B.Create(['shape', 'scale']);
  Self.P.Create(['U_Prayer1', 'U_Prayer2', 'U_Prayer3']);
  Self.RT.Create(['RT_U1', 'RT_U2', 'RTC_U', 'LogNormal', 'Weibull', 'rtdist0', 'rtdist1']);
  Self.Deseq.U.Create(['win_portal_base', 'win_portal_curve', 'win_use_time', 'win_knight_factor',
                   'inactive_source', 'inactive_base', 'inactive_curve']);
  Self.Deseq.NoiseInterval := 3000 + Round(5000 * Power(Self.Deseq.U[0].U, 0.5 + Self.Deseq.U[1].U));
  Self.Deseq.KnightHPLvl := Random(80, 100);

  // Result: 160-336ms with Gaussian distribution around personality baseline
  self.bRT := Round(TruncGauss(200, 30, 173, 227) + 123
    * bhM.U * TruncGauss(1.0, 0.05, 0.85, 1.15));
  {$IFDEF WL_FATIGUE_INCLUDED}
  if not Self.UserDisableFatigue then
  begin
    Fatigue.Debugging := True;
    Fatigue.Setup();
  end;
  {$ENDIF}



  ProgressReport.Setup(
    'Pest Control JDS',
    [
      'Total   runtime:', 'Active  runtime:', 'Antiban runtime:',
      'Next sleep:', 'Games Won:', 'Wins/Hour:', 'Points Earned:',
      'Points/Hour:', 'Actions:'
    ],
    @Self.GetReportValues,
    Round(ONE_MINUTE*2.5)
  );

  Antiban.OnBreaking := @Self.OnBreakingHud;
  Antiban.OnSleeping := @Self.OnSleepingHud;
  Antiban.OnStartBreak := @Self.OnBreakStart;
  Antiban.OnStartSleep := @Self.OnSleepStart;
  Antiban.OnFinishBreak := @Self.OnBreakEnd;
  Antiban.OnFinishSleep := @Self.OnSleepEnd;
  AddOnTerminate(@Self._OnTermination);
  AddOnPause(@Self._OnPause);
  AddOnResume(@Self._OnResume);
  _InitPCData();

  Self.SetupMouse();

  Self.InitAttackProfile();
  Self.SetAttackTempo();

  Self.ActivityThresh := EnsureRange(Self.UserActiveThreshold+Random(-7, 7), 50, 100);
  Self.PrayerEnableTime := Self.PrayerSample();
  // Map setup
  Map.Setup([Chunk(Box(40,41,41,41), 0)]); //pc boat area
  Map.Add([Chunk(Box(41,40,41,40), 0)]); //pc game area
  Map.Walker.OnWaitMovingEvent := @Self.OnWalkerEvent;
  Map.Walker.OnWalkEvent := @Self.OnWalkerEvent;
  Map.Walker.TargetUpText := ['tack Shifter', 'Attack Shifter'];
  Self.Center := PCData.Knight.Offset(2, 0);
  Self.Squire := TRSEntity.Create(@Map.Walker, [1, 1, 4], 5, [PCData.LeaveNPC], ['to Squire', 'Talk-to'], [ERSMinimapDot.NPC]);
  Self.Shifter := TRSEntity.Create(
    @Map.Walker,
    [1, 1, 1],
    14 + Round(3*bhM.U),
    [PCData.Knight],
    ['tack Shifter', 'Attack Shifter'],
    [ERSMinimapDot.NPC]
  );

  // Initialize stats
  Self.Start := Time;
  Self.GameStart := Time;
  Self.GamesWon := -1;
  Self.PtsTotal := -1;
  Self.PtsStart := -1;
  Self.CombatLevel := -1;
  
  // Antiban setup
  Antiban.Zoom.Min := 30;
  Antiban.Zoom.Max := 50;
  Antiban.Skills := [ERSSkill.RANGED, ERSSkill.MAGIC, ERSSkill.PRAYER, ERSSkill.ATTACK, ERSSkill.STRENGTH, ERSSkill.DEFENCE, ERSSkill.TOTAL];

  Activity.Restart();

  PestShop.Setup();

  WriteLn('[INIT] Initialization complete');
end;

procedure TPestControl.Run();
var
  nState, sBeforeAntiban: EPestState;
  tRand: Int32;
  JustDidAntiban: Boolean;
begin
  Self.Init();
  tRand := Round(Random(0, 80+100*bhM.U));
  Profiles[ProfileIndex].Worlds := [344];

  Self.State := EPestState.INIT;
  sBeforeAntiban := EPestState.INIT;
  JustDidAntiban := False;

  repeat
    nState := Self.GetState();

    if nState <> Self.State then
    begin
      {$IFDEF WL_FATIGUE_INCLUDED}
      Fatigue.Update();
      if RandomBoolean(0.1) then Fatigue.DebugPrint();
      {$ENDIF}
      if Self.State <> EPestState.INIT then
        Self.StateTimer.Add(Self.State, Time - Self.StateT);

      if nState = EPestState.ANTIBAN then
      begin
        // Only save if interrupted state is gameplay state
        if Self.State in [EPestState.IN_BOAT, EPestState.WALK_MID,
                          EPestState.DEFEND, EPestState.AT_PLANK,
                          EPestState.EXIT_GAME] then
          sBeforeAntiban := Self.State
        else
          sBeforeAntiban := EPestState.UNKNOWN;
      end
      else if JustDidAntiban then
      begin
        if sBeforeAntiban <> EPestState.UNKNOWN then
          Self.StateTimer.Add(sBeforeAntiban, Time - Self.StateT);
        JustDidAntiban := False;
      end;

      Self.StateT := Time;
      Self.State := nState;
      Self.UpdateAndDrawHUD(False, False, 0, True);
      Logger.Info('[STATE] ' + ToStr(Self.State));
    end
    else
    begin
      Self.State := nState;
      Self.UpdateAndDrawHUD();
    end;

    ProgressReport.Print();

    case Self.State of
      EPestState.UNKNOWN:
        begin
          Sleep(LogNormalInt(500, 0.35));
          Writeln('[UNKNOWN STATE]', FormatMilliseconds(Logger.TimeRunning.Elapsed, TIME_SHORT));
        end;

      EPestState.LOGIN: Login.DoLogin();
      EPestState.CMBT_LVL: Self.UpdateCmbtLvl();

      EPestState.ANTIBAN:
        begin
          Antiban.DoTask();
          JustDidAntiban := True;
        end;

      EPestState.BREAK: Antiban.DoBreak();
      EPestState.SLEEP: Antiban.DoSleep();

      EPestState.IN_BOAT: Self.WhileInBoat();
      EPestState.WALK_MID: Self.WalkToDefend();
      EPestState.DEFEND: Self.DefendKnight();
      EPestState.EXIT_GAME: Self.LeaveTheGame();
      EPestState.SPEND_PTS: Self.SpendPestPoints();
      EPestState.AT_PLANK: Self.EnterBoat();
      EPestState.WALK_PLANK: Map.Walker.WalkBlind(
        Self.AtPlank.Offset(
          Biometrics.RandomModeInteger(2, -5, 5),
          Biometrics.RandomModeInteger(2, -5, 5)));

      EPestState.NO_ACTIVITY, EPestState.MAX_ACTIONS,
      EPestState.MAX_TIME, EPestState.END_SCRIPT: Exit;
    end;
  until (Self.PtsTotal > (3800 + tRand));

  Writeln('Total Points: ', Self.PtsTotal, ' is more than: ', 3800 + tRand);
  WriteLn('[COMPLETE] Thank you for using Pest Control JDS');
  Self.StateTimer.LogAll();
end;

type
  TPCForm = record
    form: TScriptForm;
    config: TConfigJSON;

    AutoStartTimer: TLazTimer;
    CountdownLabel: TLazLabel;
    TimerStartTime: UInt64;
    DisplayTimer: TLazTimer;

    ChkQuickPrayer,
    ChkChillIfActive,
    ChkDisableFatigue: TLazCheckBox;

    ChkDisableHUD,
    ChkDisableMoveInBoat,
    ChkDisablePace,
    ChkDisableLeaveGame: TLazCheckBox;

    EditPointsPerWin,
    EditSpendPointsAt,
    EditCombatLevel,
    EditActiveThreshold: TLazSpinEdit;

  end;
var
  GUI: TPCForm;

procedure OnAnyInteraction(sender: TLazObject);
begin
  if GUI.AutoStartTimer <> nil then
  begin
    GUI.AutoStartTimer.Enabled := False;
    GUI.AutoStartTimer.Free();
    GUI.AutoStartTimer := nil;
  end;
  if GUI.DisplayTimer <> nil then
  begin
    GUI.DisplayTimer.Enabled := False;
    GUI.DisplayTimer.Free();
    GUI.DisplayTimer := nil;
  end;
  if GUI.CountdownLabel <> nil then
  begin
    GUI.CountdownLabel.Free();
    GUI.CountdownLabel := nil;
  end;
end;


procedure OnTimerTick(sender: TLazObject);
begin
  GUI.AutoStartTimer.Enabled := False;
  WriteLn('[AUTO-START] Starting script');
  GUI.Form.Start.Click();
end;

procedure UpdateCountdown(sender: TLazObject);
var
  elapsed, remaining: Int32;
begin
  elapsed := (Time - GUI.TimerStartTime) div 1000;
  remaining := AUTO_START_DELAY - elapsed;

  if remaining > 0 then
    GUI.CountdownLabel.Caption := 'Auto-start in ' + ToStr(remaining) + 's'
  else
    GUI.CountdownLabel.Caption := 'Starting...';
end;


procedure StartAutoTimer(sender: TLazObject);
var
  bottomPanel: TLazPanel;
begin
  GUI.TimerStartTime := Time;

  GUI.AutoStartTimer := TLazTimer.Create(GUI.Form.Form);
  GUI.AutoStartTimer.Interval := AUTO_START_DELAY*ONE_SECOND;
  GUI.AutoStartTimer.OnTimer := @OnTimerTick;
  GUI.AutoStartTimer.Enabled := True;

  GUI.DisplayTimer := TLazTimer.Create(GUI.Form.Form);
  GUI.DisplayTimer.Interval := 1000;
  GUI.DisplayTimer.OnTimer := @UpdateCountdown;
  GUI.DisplayTimer.Enabled := True;

  // Find bottom panel (Start button's parent)
  bottomPanel := TLazPanel(GUI.Form.Start.Parent);

  GUI.CountdownLabel := TLazLabel.CreateEx(bottomPanel);
  GUI.CountdownLabel.Caption := 'Auto-start in ' + ToStr(AUTO_START_DELAY) + 's';
  GUI.CountdownLabel.Font.Size := 9;
  GUI.CountdownLabel.Font.Color := $0000FF;  // Red
  GUI.CountdownLabel.Transparent := True;
  GUI.CountdownLabel.Left := GUI.Form.Start.Left - 100;  // Left of Start button
  GUI.CountdownLabel.Top := (bottomPanel.Height - 16) div 2;  // Centered vertically
  GUI.CountdownLabel.Width := 100;
  GUI.CountdownLabel.Height := 16;
end;

procedure TScriptForm.OnStart(sender: TLazObject); override;
var
  GoalT, GoalA: UInt64;
begin
  inherited;
  RSClient.DisableRealInput();
  GoalA := Self.Goals.Actions.Value;
  GoalA := GoalA + Round(Random(GoalA*-0.13, GoalA*0.23));
  PestControl.MaxActions := GoalA;
  GoalT := Self.Goals.Time.Value * ONE_MINUTE;
  GoalT := GoalT + Round(Random(GoalT*-0.13, GoalT*0.23));
  PestControl.MaxTime := GoalT;

  PestControl.UserQuickPrayer := GUI.ChkQuickPrayer.IsChecked();
  PestControl.UserChillIfActive := GUI.ChkChillIfActive.IsChecked();
  PestControl.UserActiveThreshold := GUI.EditActiveThreshold.Value;
  PestControl.PtsPerGame := GUI.EditPointsPerWin.Value;
  PestControl.UserDisableHUD := GUI.ChkDisableHUD.IsChecked();
  PestControl.UserDisableMoveInBoat := GUI.ChkDisableMoveInBoat.IsChecked();
  PestControl.UserDisablePace := GUI.ChkDisablePace.IsChecked();
  PestControl.UserDisableLeaveGame := GUI.ChkDisableLeaveGame.IsChecked();
  PestControl.UserCombatLevel := GUI.EditCombatLevel.Value;
  PestControl.UserDisableFatigue := GUI.ChkDisableFatigue.IsChecked();
  PestControl.UserSpendPointsAt := Gui.EditSpendPointsAt.Value;
  PestControl.UserSpendPoints := Gui.EditSpendPointsAt.Value > GUI.EditPointsPerWin.Value;

  if PestControl.UserSpendPoints then
    Logger.Success('We''ll spend out points at %d', [PestControl.UserSpendPointsAt]);

  GUI.config.SetConfig('goal_actions', Self.Goals.Actions.Value);
  GUI.config.SetConfig('goal_time', Self.Goals.Time.Value);
  GUI.config.SetConfig('quick_prayer', PestControl.UserQuickPrayer);
  GUI.config.SetConfig('chill_if_active', PestControl.UserChillIfActive);
  GUI.config.SetConfig('active_threshold', PestControl.UserActiveThreshold);
  GUI.config.SetConfig('points_per_win', PestControl.PtsPerGame);
  GUI.config.SetConfig('disable_hud', PestControl.UserDisableHUD);
  GUI.config.SetConfig('disable_move_in_boat', PestControl.UserDisableMoveInBoat);
  GUI.config.SetConfig('disable_pace', PestControl.UserDisablePace);
  GUI.config.SetConfig('disable_leave_game', PestControl.UserDisableLeaveGame);
  GUI.config.SetConfig('disable_fatigue', PestControl.UserDisableFatigue);
  GUI.config.SetConfig('combat_level', PestControl.UserCombatLevel);

  GUI.config.Save();
end;

procedure TScriptForm.Init();
var
  tab: TLazTabSheet;
  goalsPanel: TLazPanel;
  lblQuickPrayer,
  lblCombatLevel,
  lblChillActive,
  lblActiveThresh,
  lblPointsPerWin,
  titleLabel,
  authorLabel,
  lblSpendPoints: TLazLabel;
  bgImage: TLazImage;
  y: Int32;
begin
  GUI.config.Setup('jds-pestcontrol');
  Self.Setup('Pest Control LITE', GUI.config.Data);

  if USE_AUTO_START then
    Self.Form.OnShow := @StartAutoTimer;

  // ===== Settings Tab =====
  tab := Self.CreateTab('Settings');
  tab.Color := $1A1A1A;

  if not FileExists(SimbaEnv.DataPath+'jdsBackground.png') then
    URLFetchToFile('https://i.imgur.com/xN2rmA4.png', SimbaEnv.DataPath+'jdsBackground.png');

  // Background image
  bgImage := TLazImage.CreateEx(tab);
  bgImage.Align := ELazAlign.Client;
  bgImage.Picture.LoadFromFile(SimbaEnv.DataPath + 'jdsBackground.png');
  bgImage.Stretch := True;
  bgImage.Proportional := False;
  bgImage.SendToBack();

  y := 20;

  // Activity Threshold
  lblActiveThresh := TLazLabel.CreateEx(tab, 'Relax at:',
    'Stop playing at this threshold, lightly randomized', 20, y, 180, 30);
  lblActiveThresh.Font.Size := 14;
  lblActiveThresh.Font.Color := $F0F0F0;
  lblActiveThresh.Color := $2A2A2A;
  lblActiveThresh.Transparent := False;
  lblActiveThresh.Alignment := ELazAlignment.Center;
  lblActiveThresh.Layout := ELazTextLayout.Center;

  GUI.EditActiveThreshold := TLazSpinEdit.CreateEx(tab);
  GUI.EditActiveThreshold.SetBounds(170, y, 100, 30);
  GUI.EditActiveThreshold.MinValue := 50;
  GUI.EditActiveThreshold.MaxValue := 100;
  GUI.EditActiveThreshold.ValueEmpty := True;
  GUI.EditActiveThreshold.Value := 75;
  GUI.EditActiveThreshold.Font.Size := 14;
  GUI.EditActiveThreshold.Font.Color := $F0F0F0;
  GUI.EditActiveThreshold.Color := $2A2A2A;

  GUI.ChkChillIfActive := TLazCheckBox.CreateEx(tab, 'Relax in game',
    'Reduce activity if above threshold',330, y, 560, 30);
  GUI.ChkChillIfActive.Font.Size := 14;
  GUI.ChkChillIfActive.Font.Color := $F0F0F0;
  GUI.ChkChillIfActive.SetChecked(False);

  Inc(y, 45);

  // Points Per Win
  lblPointsPerWin := TLazLabel.CreateEx(tab, 'Points/Win:', '', 20, y, 140, 30);
  lblPointsPerWin.Font.Size := 14;
  lblPointsPerWin.Font.Color := $F0F0F0;
  lblPointsPerWin.Color := $2A2A2A;
  lblPointsPerWin.Transparent := False;
  lblPointsPerWin.Alignment := ELazAlignment.Center;
  lblPointsPerWin.Layout := ELazTextLayout.Center;

  GUI.EditPointsPerWin := TLazSpinEdit.CreateEx(tab);
  GUI.EditPointsPerWin.SetBounds(170, y, 100, 30);
  GUI.EditPointsPerWin.MinValue := 3;
  GUI.EditPointsPerWin.MaxValue := 8;
  GUI.EditPointsPerWin.ValueEmpty := True;
  GUI.EditPointsPerWin.Value := 7;
  GUI.EditPointsPerWin.Font.Size := 14;
  GUI.EditPointsPerWin.Font.Color := $F0F0F0;
  GUI.EditPointsPerWin.Color := $2A2A2A;

  GUI.ChkQuickPrayer := TLazCheckBox.CreateEx(tab, 'Use quick prayers',
    'Enable quick prayers during combat', 330, y, 0, 0);
  GUI.ChkQuickPrayer.Font.Size := 14;
  GUI.ChkQuickPrayer.ShowHint := True;
  GUI.ChkQuickPrayer.SetChecked(True);

  Inc(y, 50);

  // Combat Level
  lblCombatLevel := TLazLabel.CreateEx(tab, 'Combat Level:', '', 20, y, 140, 30);
  lblCombatLevel.Font.Size := 14;
  lblCombatLevel.Font.Color := $F0F0F0;
  lblCombatLevel.Color := $2A2A2A;
  lblCombatLevel.Transparent := False;
  lblCombatLevel.Alignment := ELazAlignment.Center;
  lblCombatLevel.Layout := ELazTextLayout.Center;

  GUI.EditCombatLevel := TLazSpinEdit.CreateEx(tab);
  GUI.EditCombatLevel.SetBounds(170, y, 100, 30);
  GUI.EditCombatLevel.MinValue := 40;
  GUI.EditCombatLevel.MaxValue := 126;
  GUI.EditCombatLevel.ValueEmpty := True;
  GUI.EditCombatLevel.Value := 40;
  GUI.EditCombatLevel.Font.Size := 14;
  GUI.EditCombatLevel.Font.Color := $F0F0F0;
  GUI.EditCombatLevel.Color := $2A2A2A;
  Inc(y, 50);

  // === Advanced Options Header ===
  lblQuickPrayer := TLazLabel.CreateEx(tab, 'User Options', '', 20, y, 220, 30);
  lblQuickPrayer.Font.Size := 14;
  lblQuickPrayer.Font.Color := $3B9FFF;
  lblQuickPrayer.Font.Style := [ELazFontStyles.Bold];
  lblQuickPrayer.Color := $2A2A2A;
  lblQuickPrayer.Transparent := False;
  lblQuickPrayer.Alignment := ELazAlignment.Center;
  lblQuickPrayer.Layout := ELazTextLayout.Center;
  Inc(y, 40);

  // Disable HUD
  GUI.ChkDisableHUD := TLazCheckBox.CreateEx(tab);
  GUI.ChkDisableHUD.SetBounds(20, y, 300, 30);
  GUI.ChkDisableHUD.Caption := 'Disable HUD';
  GUI.ChkDisableHUD.Hint := 'Turn off in-game overlay';
  GUI.ChkDisableHUD.ShowHint := True;
  GUI.ChkDisableHUD.Font.Size := 14;
  GUI.ChkDisableHUD.Font.Color := $F0F0F0;
  GUI.ChkDisableHUD.SetChecked(False);

  // Disable Boat Movement
  GUI.ChkDisableMoveInBoat := TLazCheckBox.CreateEx(tab);
  GUI.ChkDisableMoveInBoat.SetBounds(390, y, 330, 30);
  GUI.ChkDisableMoveInBoat.Caption := 'Disable Boat Move';
  GUI.ChkDisableMoveInBoat.Hint := 'Disable boat movement entirely';
  GUI.ChkDisableMoveInBoat.ShowHint := True;
  GUI.ChkDisableMoveInBoat.Font.Size := 14;
  GUI.ChkDisableMoveInBoat.Font.Color := $F0F0F0;
  GUI.ChkDisableMoveInBoat.SetChecked(False);
  Inc(y, 35);

  // Disable Pacing
  GUI.ChkDisablePace := TLazCheckBox.CreateEx(tab);
  GUI.ChkDisablePace.SetBounds(20, y, 300, 30);
  GUI.ChkDisablePace.Caption := 'Disable Pacing';
  GUI.ChkDisablePace.Hint := 'Disable game movement entirely';
  GUI.ChkDisablePace.ShowHint := True;
  GUI.ChkDisablePace.Font.Size := 14;
  GUI.ChkDisablePace.Font.Color := $F0F0F0;
  GUI.ChkDisablePace.SetChecked(False);

  // Disable Leave Game
  GUI.ChkDisableLeaveGame := TLazCheckBox.CreateEx(tab);
  GUI.ChkDisableLeaveGame.SetBounds(390, y, 330, 30);
  GUI.ChkDisableLeaveGame.Caption := 'Disable Auto-Leave';
  GUI.ChkDisableLeaveGame.Hint := 'Never leave a game, even if activity drops';
  GUI.ChkDisableLeaveGame.ShowHint := True;
  GUI.ChkDisableLeaveGame.Font.Size := 14;
  GUI.ChkDisableLeaveGame.Font.Color := $F0F0F0;
  GUI.ChkDisableLeaveGame.SetChecked(False);
  Inc(y, 35);

  // Disable Fatigue
  GUI.ChkDisableFatigue := TLazCheckBox.CreateEx(tab);
  GUI.ChkDisableFatigue.SetBounds(20, y, 300, 30);
  GUI.ChkDisableFatigue.Caption := 'Disable Fatigue';
  GUI.ChkDisableFatigue.Hint := 'Disable fatigue system';
  GUI.ChkDisableFatigue.ShowHint := True;
  GUI.ChkDisableFatigue.Font.Size := 14;
  GUI.ChkDisableFatigue.Font.Color := $F0F0F0;
  GUI.ChkDisableFatigue.SetChecked(False);

  // Title and Author in bottom right
  titleLabel := TLazLabel.CreateEx(tab, 'Pest Control LITE', '', 520, 420, 250, 35);
  titleLabel.Font.Size := 24;
  titleLabel.Font.Color := $3B9FFF;
  titleLabel.Font.Style := [ELazFontStyles.Bold];
  titleLabel.Transparent := True;
  titleLabel.Alignment := ELazAlignment.RightJustify;

  authorLabel := TLazLabel.CreateEx(tab, 'by footballjds', '', 580, 455, 190, 20);
  authorLabel.Font.Size := 12;
  authorLabel.Font.Color := $3B9FFF;
  authorLabel.Transparent := True;
  authorLabel.Alignment := ELazAlignment.RightJustify;

  // Load saved config
  if GUI.config.Data.Has('quick_prayer') then
    GUI.ChkQuickPrayer.SetChecked(GUI.config.Data.Item['quick_prayer'].AsBool);
  if GUI.config.Data.Has('chill_if_active') then
    GUI.ChkChillIfActive.SetChecked(GUI.config.Data.Item['chill_if_active'].AsBool);
  if GUI.config.Data.Has('active_threshold') then
    GUI.EditActiveThreshold.Text := ToStr(GUI.config.Data.Item['active_threshold'].AsInt);
  if GUI.config.Data.Has('points_per_win') then
    GUI.EditPointsPerWin.Text := ToStr(GUI.config.Data.Item['points_per_win'].AsInt);

  if GUI.config.Data.Has('disable_hud') then
    GUI.ChkDisableHUD.SetChecked(GUI.config.Data.Item['disable_hud'].AsBool);
  if GUI.config.Data.Has('disable_move_in_boat') then
    GUI.ChkDisableMoveInBoat.SetChecked(GUI.config.Data.Item['disable_move_in_boat'].AsBool);
  if GUI.config.Data.Has('disable_pace') then
    GUI.ChkDisablePace.SetChecked(GUI.config.Data.Item['disable_pace'].AsBool);
  if GUI.config.Data.Has('disable_leave_game') then
    GUI.ChkDisableLeaveGame.SetChecked(GUI.config.Data.Item['disable_leave_game'].AsBool);
  if GUI.config.Data.Has('disable_fatigue') then
    GUI.ChkDisableFatigue.SetChecked(GUI.config.Data.Item['disable_fatigue'].AsBool);
  if GUI.config.Data.Has('combat_level') then
    GUI.EditCombatLevel.Text := ToStr(GUI.config.Data.Item['combat_level'].AsInt);

  // Goals panel at bottom
  goalsPanel := Self.CreateGoals(tab, True, True, False, EOrientation.HORIZONTAL);
  goalsPanel.Align := ELazAlign.Bottom;
  goalsPanel.Color := $3B9FFF;
  goalsPanel.Font.Style := [ELazFontStyles.Bold];
  goalsPanel.Font.Color := $000000;

  lblSpendPoints := TLazLabel.CreateEx(goalsPanel);
  lblSpendPoints.Align := ELazAlign.Right;
  lblSpendPoints.BorderSpacing.Top    := 10;
  lblSpendPoints.BorderSpacing.Bottom := 10;
  lblSpendPoints.BorderSpacing.Left   := 5;
  lblSpendPoints.BorderSpacing.Right  := 5;
  lblSpendPoints.Caption := 'Spend at';

  GUI.EditSpendPointsAt := TLazSpinEdit.CreateEx(goalsPanel, '', 'Threshold at which to spend points', 0, 0, 80);
  GUI.EditSpendPointsAt.Align := ELazAlign.Right;
  GUI.EditSpendPointsAt.BorderSpacing.Around := 8;
  GUI.EditSpendPointsAt.MinValue := -1;
  GUI.EditSpendPointsAt.MaxValue := 4000;
  GUI.EditSpendPointsAt.Value := -1;
  GUI.EditSpendPointsAt.ValueEmpty := True;
  GUI.EditSpendPointsAt.Increment := Random(25, 50);

  if GUI.config.Data.Has('goal_actions') then
    Self.Goals.Actions.Value := GUI.config.Data.Item['goal_actions'].AsInt;
  if GUI.config.Data.Has('goal_time') then
    Self.Goals.Time.Value := GUI.config.Data.Item['goal_time'].AsInt;

  // ===== Antiban Tab =====
  Self.CreateAntibanTab();

  // Hook interactions
  GUI.ChkQuickPrayer.OnChange := @OnAnyInteraction;
  GUI.ChkChillIfActive.OnChange := @OnAnyInteraction;
  GUI.EditActiveThreshold.OnChange := @OnAnyInteraction;
  GUI.EditPointsPerWin.OnChange := @OnAnyInteraction;
  GUI.ChkDisableHUD.OnChange := @OnAnyInteraction;
  GUI.ChkDisableMoveInBoat.OnChange := @OnAnyInteraction;
  GUI.ChkDisablePace.OnChange := @OnAnyInteraction;
  GUI.ChkDisableLeaveGame.OnChange := @OnAnyInteraction;
  GUI.EditCombatLevel.OnChange := @OnAnyInteraction;
  GUI.ChkDisableFatigue.OnChange := @OnAnyInteraction;
  Self.Goals.Actions.OnChange := @OnAnyInteraction;
  Self.Goals.Time.OnChange := @OnAnyInteraction;
  Gui.EditSpendPointsAt.OnChange := @OnAnyInteraction;
  Self.Run();
end;

begin
  ClearSimbaOutput();
  GUI.form.Init();
  PestControl.Run();
end.
