{$DEFINE SCRIPT_ID := 'pest_control_jds'}
{$DEFINE SCRIPT_REVISION := '1'}
{$DEFINE SCRIPT_GUI}
{$I WaspLib/osrs.simba}
const
  USE_AUTO_START    = TRUE;//auto-start
  AUTO_START_DELAY  = 30;  //delay(in seconds) before auto-starting
type
  TPestControlGameData = record
    Nov, Inter, Vet: record
      AtPlank, PlankObj: TPoint;
      BoatBox: TBox;
    end;

    Portals: record
      W, SW, SE, E: TPoint;
    end;

    Knight, Spawn, LeaveNPC: TPoint;

    OCR: record
      KnightHP: TBox;
      ActivBox, PointsBox, W, E, SE, SW: TBox;
      Shield_W, Shield_E, Shield_SE, Shield_SW: TBox;
      ActivGreen, ActivRed: Int32;
    end;

    GameIsland, OutpostIsland: TBox;
  end;

var
  PCData: TPestControlGameData;
// =============================================================================
// ENUMS
// =============================================================================

type
  EPestState = (
    INIT,
    LOGIN,
    CMBT_LVL,
    
    IN_BOAT,
    WALK_MID,
    DEFEND,
    AT_PLANK,
    EXIT_GAME,
    ANTIBAN,
    BREAK,
    SLEEP,

    NO_ACTIVITY, UNKNOWN, MAX_ACTIONS, MAX_TIME, END_SCRIPT
  );
  EAttackChoice = (Self, Knight, Rand);
// =============================================================================
// FATIGUE SYSTEM - Complete Implementation
// =============================================================================

const
  // Global homeostat constants
  S_TAU_WAKE_MS  = 65520000.0;   // 18.2 hours in ms
  S_TAU_SLEEP_MS = 15120000.0;   // 4.2 hours in ms

  // Inertia thresholds
  NAP_THRESHOLD_MIN = 20.0;  // Minutes

type
  TFatigue = record
    // =========================================================================
    // TIMING (Timestamps in milliseconds)
    // =========================================================================
    Start, Last, LastWakeTime, LastSleepTime, LastSave: UInt64;

    // Store data JSON
    Config: TConfigJSON;

    // =========================================================================
    // STATE VARIABLES (Updated each frame)
    // =========================================================================
    R_resource, R_driftCur: Double;   // Time-on-task resource + OU drift
    S_homeostat: Double;               // Homeostatic sleep pressure [S_MIN..S_MAX]
    I_current: Double;                 // Current inertia level [0..1]
    D_debt: Double;                    // Sleep debt (hours owed)

    // Computed (not persisted, calculated on demand)
    C_current: Double;                 // Current circadian value (scaled)
    F_raw: Double;                     // Raw fatigue before circadian modulation
    F_total: Double;                   // Final combined fatigue signal [0..1.2]


    // =========================================================================
    // PROFILE PARAMETERS (Stable traits, stored in config)
    // =========================================================================
    C_phaseHours: Double;              // Chronotype offset [-4.5..+4.5]
    D_required: Double;                // Daily sleep need [6..10 hours]
    C_amplitude: Double;               // Circadian strength [0.05..0.35]
    I_magnitude: Double;               // Base inertia severity [0.05..0.60]
    I_tau: Double;                     // Inertia decay time constant (ms) [1.2e6..7.2e6]
    D_lambda: Double;                  // Debt memory factor [0.60..0.92]

    // =========================================================================
    // SESSION PARAMETERS (Generated per-run from hash)
    // =========================================================================
    R_deplete: Double;                 // ToT depletion rate (1/min)
    R_recover: Double;                 // Break recovery rate (1/min)
    R_drift: Double;                   // OU noise scale (per sqrt(min))
    R_revert: Double;                  // OU mean reversion (1/min)
    R_onsetTime: Double;               // Sigmoid onset midpoint (minutes)
    R_onsetSteep: Double;              // Sigmoid steepness
    BreakQuality: Double;              // Current break quality [0..1]
    D_kpay: Double;                    // Sleep debt recovery [0.4 .. 1.0]

    // =========================================================================
    // OUTPUT CAPS (Rendering constraints)
    // =========================================================================
    RTMult: Double;                    // Max RT multiplier [1.1..2.2]
    ErrRate: Double;                   // Max error probability [0.0..0.20]
    F_cap: Double;                     // Max combined fatigue [1.0..1.4]

    // Modulation bounds (per-account variability)
    K_circadian: Double;     // Circadian strength [0.15..0.35]
    CircMult_min: Double;    // Circadian min [0.50..0.70]
    CircMult_max: Double;    // Circadian max [1.30..1.50]
    S_min: Double;           // Homeostat min [0.08..0.12]
    S_max: Double;           // Homeostat max [0.90..0.98]
    D_max: Double;           // Debt cap [60..90 hours]
    Drift_range: Double;     // Drift bounds [0.3..0.5]
  end;

// =============================================================================
// TYPES
// =============================================================================
type
  TStateGroup = record
    S: array of EPestState;     // group of states to emote in
    E: array of ERSEmote;       // group of emotes for specific states
    Min, Max: Integer;          // number of emotes to do in a row
    DelayMin, DelayMax: UInt64; // ms delay between bursts of emotes
  end;

  TUserEmotes = array of TStateGroup;

type
  TAttackTempo = record
    XPMean, XPStick, LowMean, LowStick: Double;
  end;
  TStateTimer = record
    Times: array[EPestState] of Int64;  // milliseconds per state
  end;
type
  TUV = record
    Hash, Salt: String;   // Hash string + Salt
    U: Double;// U (0..1)
  end;
  TUVArray = array of TUV;
type
  TPestControl = record

    // Account unique decisions
    Flag: record
      NoPray, NoLeave, NoPace, NoBoatMove, DelayBoatMove: Boolean;
      Choices: TUVArray;
    end;

    State: EPestState;
    StateT: UInt64;
    StateTimer: TStateTimer;
    
    // Map coordinates
    Center, AtPlank, CrossPlank: TPoint;
    BoatBox: TBox;

    // U's and Choices
    P: TUVArray; // Prayer
    M: TUVArray; // Mouse
    attkC: TUVArray; // Attack choices
    AttackChoice: EAttackChoice;
    AttackIndex: Int32;
    AttackWeights: array[0..2] of Double;
    AttackStick: Double;

    // Objects & Entities  
    Gangplank: TRSObject;
    Squire, Shifter, VoidKnight: TRSEntity;

    // Timing
    F: TFatigue;//Fatigue
    bRT: Double;
    RT: TUVArray;//0..2 RT_U1, RT_U2, RTC_U
    Tempo: TAttackTempo;
    XPAttkDelay: Double;
    NextAttkDelay, LastAttack: Double;
    LastXP: UInt64;
    LastXPTime: UInt64;
    HUDLastUpdate: UInt64;
    GameStart: UInt64;
    GameStarted: Boolean;

    // Prayer
    PrayerEnableTime: Double;
    
    // Boat movement
    LastBoatMove: UInt64;
    BoatMoveDelay: Double;
    
    // Activity
    ActivityThresh: Int32;
    
    // Stats
    Start, LastWin, CombatLevel: UInt64;
    KnightHP, wHP, eHP, seHP, swHP, portalsHP: Int32;
    WShielded, EShielded, SEShielded, SWShielded: Boolean;
    GamesWon, PtsPerGame, LeaveGameCount: UInt32;
    PtsStart, PtsEarned, PtsTotal: Int32;
    

    UserDisableHUD, UserDisableMoveInBoat, UserDisablePace, UserDisableLeaveGame: Boolean;
    UserDisableFatigue: Boolean;
    Actions, MaxActions, MaxTime: UInt64;
    UserActiveThreshold, UserCombatLevel, UserSpendPointsAt: Int32;
    UserRewards: TStringArray;
    UserRwardAmmount: TIntegerArray;
    UserQuickPrayer, UserChillIfActive, UserSpendPoints, UserRestAfterGame: Boolean;
  end;

var
  PestControl: TPestControl;
  bhM, _bhM: TUV;

// =============================================================================
// HELPER FUNCTIONS - Distribution Math
// =============================================================================

// Truncated Gaussian with re-sample instead of EnsureRange
function TruncGauss(mu, sigma, lo, hi: Double): Double;
begin
  repeat
    Result := GaussRand(mu, sigma);
  until (Result >= lo) and (Result <= hi);
end;

// 0 < Random < 1
function NZRandom: Double;
begin
  repeat
    Result := Random;
  until (Result > 0) and (Result < 1);

end;

// LOGNORMAL (math form):
//   If Z ~ N(muLog, sigmaLog), then X = exp(Z) is lognormal.
//   Use when you want strictly positive, right-skewed reaction times.
function LogNormalEx(muLog, sigmaLog: Double): Double;
begin
  // Lognormal transform
  Result := Exp(muLog + sigmaLog * GaussRand(0.0, 1.0));
end;

// LOGNORMAL (human form):
//                 mean = typical delay (mean-ish RT)
function LogNormal(mean, sigma: Double): Double;
begin
  Result := LogNormalEx(Ln(mean) - 0.5 * sigma * sigma, sigma);
end;

function LogNormalInt(mean, sigma:Double): UInt64;
begin
  Result := Round(LogNormal(mean, sigma));
end;

// EX-GAUSSIAN (math form):
//   X = Gaussian(mu, sigma) + Exponential(tau)
//   This is the classic RT model: Gaussian core + exponential tail.
function ExpoGaussEx(mu, sigma, tau: Double): Double;
begin
  // Gaussian core + Exponential tail (rate = 1/tau)
  Result := GaussRand(mu, sigma) + (-tau * Ln(NZRandom));

  if Result < 0 then
    Result := 0;
end;

procedure TUV.Create(salt: String = '');
 var
  hashStr, output: String;
  hashValue: UInt64;
  eps: double = 5.42101086242752E-20;
  r: Double;
begin
  hashStr := HashString(EHashAlgo.SHA1, Profiles[ProfileIndex].Name + Profiles[ProfileIndex].Username + salt);
  Self.Hash := Profiles[ProfileIndex].Name + Profiles[ProfileIndex].Username;
  Self.Salt := salt;
  // Use first 16 hex chars (8 bytes = 64 bits) for full Double precision
  hashValue := StrToInt64('$' + Copy(hashStr, 1, 16));

  r := hashValue / High(UInt64); // Normalize to 0.0 - 1.0

  // patch only the impossible-for-math endpoints
  if r <= 0.0 then r := eps;         // replaces exact 0 only
  if r >= 1.0 then r := 1.0 - eps;   // replaces exact 1 only

  Self.U := r;
  WriteLn(PadR(Self.Salt, 16), Self.U);
end;

procedure TUVArray.Create(salts: TStringArray);
var
  i: Int32;
begin
  SetLength(Self, salts.Length);
  for i := 0 to salts.High do
    Self[i].Create(salts[i]);
end;

function TUVArray.Get(salt: String): Double;
var
  i: Integer;
begin
  for i := 0 to Self.High do
    if Self[i].Salt = salt then
      Exit(Self[i].U);
  Writeln GetDebugLn('Salt not found: ' + salt, ELogLevel.ERROR, True);
end;

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

// Ramp function for regime transitions
function Ramp(x, x0, x1: Double): Double;
begin
  Result := EnsureRange((x - x0) / (x1 - x0), 0.0, 1.0);
end;

// Gamma sampler (Marsaglia-Tsang method)
function SampleGamma(shape: Double): Double;
var
  d, c, x, v, u: Double;
begin
  if shape < 1.0 then
  begin
    Result := SampleGamma(shape + 1.0) * Power(Random(), 1.0 / shape);
    Exit;
  end;

  d := shape - 1.0/3.0;
  c := 1.0 / Sqrt(9.0 * d);

  repeat
    repeat
      x := GaussRand(0.0, 1.0);
      v := 1.0 + c * x;
    until v > 0;

    v := v * v * v;
    u := Random();
  until (u < 1.0 - 0.0331*x*x*x*x) or (Ln(u) < 0.5*x*x + d*(1.0 - v + Ln(v)));

  Result := d * v;
end;

// Beta distribution via Gamma ratio
function SampleBeta(alpha, beta: Double): Double;
var
  x, y: Double;
begin
  x := SampleGamma(alpha);
  y := SampleGamma(beta);
  Result := x / (x + y);
end;

// Safe hash to normalized [0..1]
function HashToNormalized(str: String): Double;
var
  hashStr: String;
  hashValue: UInt64;
begin
  hashStr := HashString(EHashAlgo.SHA1, str);
  hashValue := StrToUInt64('$' + Copy(hashStr, 1, 16));
  Result := hashValue / High(UInt64);
  Result := EnsureRange(Result, 0.0001, 0.9999);
end;

// =============================================================================
// TFATIGUE METHODS
// =============================================================================

procedure TFatigue.InitProfileTraits(profileName: String);
var
  tau_days: Double;
begin
  // Set RandSeed sequence
  RandSeed := Round(HashToNormalized(profileName + 'profile_traits') * High(UInt32));

  // C_phaseHours: Normal(mean=0, sd=1.3), clamp [-4.5, +4.5]
  Self.C_phaseHours := TruncGauss(0.0, 1.3, -4.5, 4.5);

  // D_required: Normal(mean=8.0, sd=0.7), clamp [6, 10]
  Self.D_required := TruncGauss(8.3, 0.7, 7.0, 10.0);

  // C_amplitude: Lognormal(mean=0.15, log_sigma=0.45), clamp [0.05, 0.35]
  Self.C_amplitude := EnsureRange(LogNormal(0.15, 0.45), 0.05, 0.35);

  // I_magnitude: Beta(2,5), clamp [0.05, 0.60]
  Self.I_magnitude := EnsureRange(SampleBeta(2.0, 5.0), 0.05, 0.60);

  // I_tau: Lognormal(mean=40min, log_sigma=0.5), clamp [20, 120] min → ms
  Self.I_tau := EnsureRange(LogNormal(40.0, 0.5), 20.0, 120.0) * ONE_MINUTE;

  // Sleep date repayment rate
  Self.D_kpay := EnsureRange(0.4 + SampleBeta(3.0, 2.0) * 0.6, 0.4, 1.0);

  // D_lambda: from tau_days Lognormal(mean=5, log_sigma=0.45), clamp [2, 10]
  tau_days := EnsureRange(LogNormal(5.0, 0.45), 2.0, 10.0);
  Self.D_lambda := Exp(-1.0 / tau_days);

  // Per-account modulation bounds
  Self.K_circadian := TruncGauss(0.25, 0.03, 0.18, 0.32);
  Self.CircMult_min := TruncGauss(0.70, 0.05, 0.60, 0.80);
  Self.CircMult_max := TruncGauss(1.30, 0.05, 1.20, 1.40);
  Self.S_min := TruncGauss(0.12, 0.01, 0.10, 0.14);
  Self.S_max := TruncGauss(0.90, 0.02, 0.88, 0.95);
  Self.D_max := TruncGauss(55, 5.0, 36.0, 60.0);
  Self.Drift_range := TruncGauss(0.35, 0.05, 0.25, 0.45);

  // Done setting profile, randomize seed
  Randomize();

  Logger.Info('Fatigue Profile - Chronotype:%.1fh Sleep:%.1fh Rhythm:%.2f Inertia:%.0fmin/%.2f Debt:%.2f',
    [Self.C_phaseHours, Self.D_required, Self.C_amplitude,
    Self.I_tau/ONE_MINUTE, Self.I_magnitude, Self.D_lambda]);
  Logger.Info('Modulation Bounds - K_circ:%.2f Circ:[%.2f,%.2f] S:[%.2f,%.2f] D_max:%.0fh Drift:±%.2f',
    [Self.K_circadian, Self.CircMult_min, Self.CircMult_max,
    Self.S_min, Self.S_max, Self.D_max, Self.Drift_range]);
end;

procedure TFatigue.InitSessionTraits(profileName: String);
var
  dayNumber: UInt64;
  HL_work, HL_break, HL_revert: Double;
begin
  // Generate deterministic seed for this day
  dayNumber := Time() div ONE_DAY;
  RandSeed := Round(HashToNormalized(profileName + 'day' + ToStr(dayNumber)) * High(UInt32));

  // R_deplete: via half-life Lognormal(median=30, log_sigma=0.6), clamp [8, 90]
  HL_work := EnsureRange(LogNormal(30.0, 0.6), 8.0, 90.0);
  Self.R_deplete := Ln(2.0) / HL_work;

  // R_recover: via half-life Lognormal(median=5, log_sigma=0.5), clamp [2, 20]
  HL_break := EnsureRange(LogNormal(5.0, 0.5), 2.0, 20.0);
  Self.R_recover := Ln(2.0) / HL_break;

  // R_drift: Lognormal(median=0.03, log_sigma=0.6), clamp [0.005, 0.12]
  Self.R_drift := EnsureRange(LogNormal(0.03, 0.6), 0.005, 0.12);

  // R_revert: via half-life Lognormal(median=10, log_sigma=0.6), clamp [3, 45]
  HL_revert := EnsureRange(LogNormal(10.0, 0.6), 3.0, 45.0);
  Self.R_revert := Ln(2.0) / HL_revert;

  // R_onsetTime: SampleBeta(2.5, 2.5), clamp [8, 50]
  Self.R_onsetTime := EnsureRange(8.0 + SampleBeta(2.5, 2.5) * 42.0, 8.0, 50.0);

  // R_onsetSteep: SampleBeta(3.0, 2.0), clamp [0.15, 0.70]
  Self.R_onsetSteep := EnsureRange(0.15 + SampleBeta(3.0, 2.0) * 0.55, 0.15, 0.70);

  // RTMult: Normal(mean=1.4, sd=0.15), clamp [1.1, 2.2]
  Self.RTMult := EnsureRange(1.1 + SampleBeta(2.0, 3.0) * 1.0, 1.1, 2.1);

  // ErrRate: Beta [0.02, 0.10]
  Self.ErrRate := EnsureRange(0.02 + SampleBeta(2.0, 8.0) * 0.08, 0.02, 0.10);

  //
  Self.F_cap := TruncGauss(1.1, 0.08, 0.9, 1.2);

  // New random seed
  Randomize();

  Logger.Info('Session Traits - Deplete:%.3f/min Recover:%.3f/min Drift:%.3f Revert:%.3f/min Onset:%.0fmin/%.2f',
    [Self.R_deplete, Self.R_recover, Self.R_drift, Self.R_revert,
     Self.R_onsetTime, Self.R_onsetSteep]);
end;

procedure TFatigue.Update(forceSave: Boolean = False);
const
  SAVE_INTERVAL = 5 * ONE_MINUTE;
var
  dt_ms, dt_min, dt_hours, sessionMin, awakeHours: Double;
  onsetFactor, noise, driftFactor, exp2theta, ouStdDev: Double;
  w_ToT, w_S, w_I, w_D, wSum: Double;
  rS, rD: Double;
  circMult, C_norm: Double;
  dt: TDateTime;
  hourOfDay: Double;
begin
  if PestControl.UserDisableFatigue then Exit;

  // Guard against multiple calls per tick
  if Time() <= Self.Last then Exit;

  dt_ms := Time() - Self.Last;
  if dt_ms < 1.0 then Exit;

  dt_min := dt_ms / ONE_MINUTE;
  dt_hours := dt_ms / ONE_HOUR;
  sessionMin := (Time() - Self.Start) / ONE_MINUTE;
  awakeHours := (Time() - Self.LastWakeTime) / ONE_HOUR;

  // ========================================================================
  // LAYER 1: Time-on-Task Resource (only during active play)
  // ========================================================================

  if not (PestControl.State in [EPestState.BREAK, EPestState.SLEEP]) then
  begin
    onsetFactor := 1.0 / (1.0 + Exp(-Self.R_onsetSteep * (sessionMin - Self.R_onsetTime)));

    Self.R_revert := Max(Self.R_revert, 1.0e-6);
    exp2theta := Exp(-2.0 * Self.R_revert * dt_min);
    ouStdDev := Self.R_drift * Sqrt((1.0 - exp2theta) / (2.0 * Self.R_revert));
    noise := GaussRand(0.0, ouStdDev);
    Self.R_driftCur := Self.R_driftCur * Exp(-Self.R_revert * dt_min) + noise;
    Self.R_driftCur := EnsureRange(Self.R_driftCur, -Self.Drift_range, Self.Drift_range);

    driftFactor := EnsureRange(1.0 + Self.R_driftCur, 0.3, 1.7);

    // old: R_resource := R_resource - (R_deplete * driftFactor * onsetFactor * dt_min)
    Self.R_resource := Self.R_resource * Exp(-Self.R_deplete * driftFactor * onsetFactor * dt_min);
    Self.R_resource := EnsureRange(Self.R_resource, 0.0, 1.0);
  end;

  // ========================================================================
  // LAYER 2: Homeostatic Sleep Pressure (always during wake)
  // ========================================================================

  if not (PestControl.State in [EPestState.SLEEP]) then
  begin
    Self.S_homeostat := Self.S_max - (Self.S_max - Self.S_homeostat) * Exp(-dt_ms / S_TAU_WAKE_MS);
    Self.S_homeostat := EnsureRange(Self.S_homeostat, Self.S_min, Self.S_max);
  end;

  // ========================================================================
  // LAYER 3: Circadian Rhythm (always updates)
  // ========================================================================

  dt := TDateTime.CreateFromSystem();
  hourOfDay := dt.Hour + dt.Minute / 60.0;

  C_norm := Cos((2.0 * PI / 24.0) * (hourOfDay - Self.C_phaseHours));
  C_norm := EnsureRange(C_norm, -1.0, 1.0);

  Self.C_current := Self.C_amplitude * C_norm;

  // ========================================================================
  // LAYER 4: Sleep Inertia (always decays)
  // ========================================================================

  if Self.I_current > 0.001 then
    Self.I_current := Self.I_current * Exp(-dt_ms / Self.I_tau)
  else
    Self.I_current := 0.0;

  // ========================================================================
  // COMBINE: Dynamic Weight Regime Transitions
  // ========================================================================

  rS := Ramp(awakeHours, 2.0, 10.0);
  rD := Ramp(awakeHours, 12.0, 24.0);

  w_ToT := 0.45 - 0.15 * rS;
  w_S := 0.20 + 0.20 * rS;
  w_I := 0.15;
  w_D := 0.05 + 0.15 * rD;

  wSum := w_ToT + w_S + w_I + w_D;
  if wSum > 0 then
  begin
    w_ToT := w_ToT / wSum;
    w_S   := w_S   / wSum;
    w_I   := w_I   / wSum;
    w_D   := w_D   / wSum;
  end;

  Self.F_raw := w_ToT * (1.0 - Self.R_resource)
              + w_S * ((Self.S_homeostat - Self.S_min) / (Self.S_max - Self.S_min))
              + w_I * Self.I_current
              + w_D * EnsureRange(Self.D_debt / Self.D_max, 0.0, Self.D_max);

  circMult := EnsureRange(1.0 - Self.K_circadian * Self.C_current, Self.CircMult_min, Self.CircMult_max);

  Self.F_total := EnsureRange(Self.F_raw * circMult, 0.0, Self.F_cap);

  Self.Last := Time();

  if forceSave or ((Time() - Self.LastSave) >= SAVE_INTERVAL) then
  begin
    Self.SaveToConfig();
    Self.Config.Save();
    Self.LastSave := Time();
    Logger.Success('-Saved Fatigue Profile Data-', [Self.Config.Data.Format]);
  end;
end;

procedure TFatigue.RecoverFromBreak(breakDuration_ms: UInt64);
var
  breakMin: Double;
  napFactor, contextFactor: Double;
  isCircadianLow, isCircadianHigh, highDebt: Boolean;
  C_norm, hourOfDay: Double;
  dt: TDateTime;
  beforeR: Double;
begin
  breakMin := breakDuration_ms / 60000.0;
  beforeR := Self.R_resource;

  // Resource recovery - exponential approach
  Self.R_resource := 1.0 - (1.0 - Self.R_resource) * Exp(-Self.R_recover * Self.BreakQuality * breakMin);
  Self.R_resource := EnsureRange(Self.R_resource, 0.0, 1.0);

  // Inertia trigger if break >= nap threshold
  if breakMin >= NAP_THRESHOLD_MIN then
  begin
    napFactor := EnsureRange((breakMin - 15.0) / 30.0, 0.0, 1.0);

    dt := TDateTime.CreateFromSystem();
    hourOfDay := dt.Hour + dt.Minute / 60.0;
    C_norm := Cos((2.0 * PI / 24.0) * (hourOfDay - Self.C_phaseHours));

    isCircadianLow := C_norm <= -0.6;
    isCircadianHigh := C_norm >= 0.6;
    highDebt := Self.D_debt >= 6.0;

    contextFactor := 1.0;
    if isCircadianLow then contextFactor := contextFactor + 0.4;
    if isCircadianHigh then contextFactor := contextFactor - 0.3;
    if highDebt then contextFactor := contextFactor + 0.3;
    contextFactor := EnsureRange(contextFactor, 0.5, 1.5);

    Self.I_current := Self.I_magnitude * napFactor * contextFactor;
    Self.LastWakeTime := Time();

    Logger.Info('Nap inertia - Duration:%.0fmin NapFactor:%.2f Context:%.2f Inertia:%.2f',
      [breakMin, napFactor, contextFactor, Self.I_current]);
  end;

  Self.Last := Time();
  Logger.Info('Break recovery - Resource: %.1f%% → %.1f%%', [beforeR * 100, Self.R_resource * 100]);
  Self.Update(True);
end;

procedure TFatigue.RecoverFromSleep(sleepDuration_ms: UInt64);
var
  sleepHours: Double;
  deficit, surplus: Double;
  beforeS, beforeD: Double;
  contextFactor: Double;
  isCircadianLow, highDebt: Boolean;
  C_norm, hourOfDay: Double;
  dt: TDateTime;
begin
  sleepHours := sleepDuration_ms / ONE_HOUR;
  beforeS := Self.S_homeostat;
  beforeD := Self.D_debt;

  // Homeostat recovery
  Self.S_homeostat := Self.S_min + (Self.S_homeostat - Self.S_min) * Exp(-sleepDuration_ms / S_TAU_SLEEP_MS);
  Self.S_homeostat := EnsureRange(Self.S_homeostat, Self.S_min, Self.S_max);

  // Debt repayment
  // RESEARCH MODEL: D(t+1) = λ*D(t) + Max(0, Required - Actual)
  deficit := Max(0.0, Self.D_required - sleepHours);
  surplus := Max(0, sleepHours - Self.D_required);
  Self.D_debt := Self.D_lambda * Self.D_debt + deficit - (Self.D_kpay * surplus);
  Self.D_debt := EnsureRange(Self.D_debt, 0.0, Self.D_max);

  // Full resource restoration
  Self.R_resource := 1.0;

  // Trigger inertia with context
  dt := TDateTime.CreateFromSystem();
  hourOfDay := dt.Hour + dt.Minute / 60.0;
  C_norm := Cos((2.0 * PI / 24.0) * (hourOfDay - Self.C_phaseHours));

  isCircadianLow := C_norm <= -0.6;
  highDebt := Self.D_debt >= 6.0;

  contextFactor := 1.0;
  if isCircadianLow then contextFactor := contextFactor + 0.4;
  if highDebt then contextFactor := contextFactor + 0.3;
  contextFactor := EnsureRange(contextFactor, 0.5, 1.5);

  Self.I_current := Self.I_magnitude * contextFactor;
  Self.LastWakeTime := Time();
  Self.LastSleepTime := Time() - sleepDuration_ms;

  Self.Last := Time();

  Logger.Info('Sleep recovery - %.1fh S:%.1f%%→%.1f%% Debt:%.1fh→%.1fh Inertia:%.2f',
    [sleepHours, beforeS * 100, Self.S_homeostat * 100, beforeD, Self.D_debt, Self.I_current]);
  Self.Update(True);
end;

property TFatigue.GetRTMulti: Double;
begin
  if PestControl.UserDisableFatigue then
    Exit(1.0);
  Self.Update();
  Result := 1.0 + (Self.RTMult - 1.0) * Self.F_total;
end;

property TFatigue.ShouldError: Boolean;
begin
  if PestControl.UserDisableFatigue then
    Exit(False);
  Self.Update();
  Result := Random() < (Self.ErrRate * Self.F_total);
end;

property TFatigue.GetErrRate: Double;
begin
  if PestControl.UserDisableFatigue then
    Exit(0.0);
  Self.Update();
  Result := Self.ErrRate * Self.F_total;
end;

property TFatigue.GetLvl: Double;
begin
  if PestControl.UserDisableFatigue then
    Exit(0.0);
  Self.Update();
  Result := Self.F_total;
end;

property TFatigue.GetBaseRT: Double;
begin
  if PestControl.UserDisableFatigue then
    Exit(PestControl.bRT);
  Result := PestControl.bRT * Self.GetRTMulti;
end;

procedure TConfigJSON.SetConfig(const key: String; value: Double); overload;
begin
  if not Self.Data.Has(key) then
    Self.Data.AddFloat(key, value)
  else
    Self.Data.Item[key].AsFloat := value;
end;

procedure TConfigJSON.SetConfig(const key: String; value: UInt64); overload;
begin
  if not Self.Data.Has(key) then
    Self.Data.AddInt(key, value)
  else
    Self.Data.Item[key].AsInt := value;
end;

procedure TConfigJSON.SetConfig(const key: String; value: Boolean); overload;
begin
  if not Self.Data.Has(key) then
    Self.Data.AddBool(key, value)
  else
    Self.Data.Item[key].AsBool := value;
end;

procedure TConfigJSON.SetConfig(const key: String; value: String); overload;
begin
  if not Self.Data.Has(key) then
    Self.Data.AddString(key, value)
  else
    Self.Data.Item[key].AsString := value;
end;

procedure TFatigue.SaveToConfig();
var
  testFloat: Double = 0.0;
begin
  if PestControl.UserDisableFatigue then
  begin
    Logger.Warn('TFatigue.SaveToConfig() - Self.UserDisableFatigue=true');
    Exit();
  end;
  WriteLn('[DEBUG SaveToConfig] LastWakeTime=', Self.LastWakeTime, ' D_debt=', Self.D_debt);

  if Self.Config.Data = nil then
  begin
    WriteLn('[ERROR] Self.Config.Data is nil!');
    Exit;
  end else
    Writeln(Self.Config.Data);

  Self.Config.SetConfig('fatigue_C_phaseHours', Self.C_phaseHours);
  Self.Config.SetConfig('fatigue_D_required', Self.D_required);
  Self.Config.SetConfig('fatigue_C_amplitude', Self.C_amplitude);
  Self.Config.SetConfig('fatigue_I_magnitude', Self.I_magnitude);
  Self.Config.SetConfig('fatigue_I_tau_ms', Self.I_tau);
  Self.Config.SetConfig('fatigue_D_lambda', Self.D_lambda);

  Self.Config.SetConfig('fatigue_K_circadian', Self.K_circadian);
  Self.Config.SetConfig('fatigue_CircMult_min', Self.CircMult_min);
  Self.Config.SetConfig('fatigue_CircMult_max', Self.CircMult_max);
  Self.Config.SetConfig('fatigue_S_min', Self.S_min);
  Self.Config.SetConfig('fatigue_S_max', Self.S_max);
  Self.Config.SetConfig('fatigue_D_max', Self.D_max);
  Self.Config.SetConfig('fatigue_Drift_range', Self.Drift_range);

  Self.Config.SetConfig('fatigue_last_wake_ms', Self.LastWakeTime);
  Self.Config.SetConfig('fatigue_sleep_debt', Self.D_debt);
  Self.Config.SetConfig('fatigue_sleep_repay', Self.D_kpay);

  WriteLn('[DEBUG After SetConfig] last_wake in data=', Self.Config.Data.Item['fatigue_last_wake_ms'].AsFloat);
end;

function TFatigue.LoadFromConfig(): Boolean;
begin
  if PestControl.UserDisableFatigue then
  begin
    Logger.Warn('TFatigue.LoadFromConfig() - Self.UserDisableFatigue=true');
    Exit();
  end;
  writeln('TFatigue.LoadFromConfig(): Boolean;');
  if not Self.Config.Data.Has('fatigue_sleep_repay') then Exit(False);

  Self.C_phaseHours := Self.Config.Data.Item['fatigue_C_phaseHours'].AsFloat;
  Self.D_required := Self.Config.Data.Item['fatigue_D_required'].AsFloat;
  Self.C_amplitude := Self.Config.Data.Item['fatigue_C_amplitude'].AsFloat;
  Self.I_magnitude := Self.Config.Data.Item['fatigue_I_magnitude'].AsFloat;
  Self.I_tau := Self.Config.Data.Item['fatigue_I_tau_ms'].AsFloat;
  Self.D_lambda := Self.Config.Data.Item['fatigue_D_lambda'].AsFloat;
  Self.D_debt := Self.Config.Data.Item['fatigue_sleep_debt'].AsFloat;
  Self.K_circadian := Self.Config.Data.Item['fatigue_K_circadian'].AsFloat;
  Self.CircMult_min := Self.Config.Data.Item['fatigue_CircMult_min'].AsFloat;
  Self.CircMult_max := Self.Config.Data.Item['fatigue_CircMult_max'].AsFloat;
  Self.S_min := Self.Config.Data.Item['fatigue_S_min'].AsFloat;
  Self.S_max := Self.Config.Data.Item['fatigue_S_max'].AsFloat;
  Self.D_max := Self.Config.Data.Item['fatigue_D_max'].AsFloat;
  Self.Drift_range := Self.Config.Data.Item['fatigue_Drift_range'].AsFloat;
  Self.D_debt := Self.Config.Data.Item['fatigue_sleep_debt'].AsFloat;
  Self.D_kpay := Self.Config.Data.Item['fatigue_sleep_repay'].AsFloat;
  Self.LastWakeTime := Round(Self.Config.Data.Item['fatigue_last_wake_ms'].AsFloat);

  // Validate loaded data
  if (Self.D_kpay = 0.0) or (Self.Drift_range = 0.0) or
    (Self.C_phaseHours = 0.0) then Exit(False);

  Result := True;
end;

procedure TFatigue.Init(profileName: String);
var
  hoursAwake: Double;
begin
  WriteLn('[DEBUG] TFatigue.Init() starting');
  Self.Config.Setup('jds-fatigue');
  if Self.Config.Data = nil then
    WriteLn('[ERROR] Self.Config.Data is nil in F.Init()!')
  else
    WriteLn('[OK] Self.Config.Data valid in F.Init()');
  Self.Start := Time();
  Self.Last := Time();
  Self.LastSave := Time();

  if not Self.LoadFromConfig() then
  begin
    Logger.Warn('No fatigue profile - generating new traits');
    Self.InitProfileTraits(profileName);

    if Length(Antiban.Sleeps) = 0 then
    begin
      PestControl.UserDisableFatigue := True;
      Logger.Warn('No sleep schedule - fatigue disabled');
      Exit;
    end;

    Self.LastWakeTime := Round(Time() - Antiban.Sleeps[0].Next - Random(Antiban.Sleeps[0].Length/3, Antiban.Sleeps[0].Length));
    Self.D_debt := 0.0;
  end;

  if Self.LastWakeTime = 0 then
    Self.LastWakeTime := Round(Time() - Antiban.Sleeps[0].Next - Random(Antiban.Sleeps[0].Length/3, Antiban.Sleeps[0].Length));

  Self.InitSessionTraits(profileName);

  Self.R_resource := 1.0;
  Self.R_driftCur := 0.0;
  Self.I_current := 0.0;

  hoursAwake := Max(0.0, (Time() - Self.LastWakeTime) / ONE_HOUR);
  Self.S_homeostat := Self.S_max - (Self.S_max - Self.S_min) * Exp(-hoursAwake * ONE_HOUR / S_TAU_WAKE_MS);
  Self.S_homeostat := EnsureRange(Self.S_homeostat, Self.S_min, Self.S_max);

  Self.BreakQuality := 0.7;//move to profile init or redesign

  Logger.Info('Fatigue init - Awake:%.2fh S:%.2f%% Debt:%.1fh',
    [hoursAwake, Self.S_homeostat * 100, Self.D_debt]);

  Self.SaveToConfig();
  Self.Config.Save();
end;

function ExpoGaussRT(mean: Double = PestControl.bRT): Double;
var
  mu, sigma, tau, f: Double;
begin
  if mean < 1 then mean := 1;

  f := PestControl.F.GetLvl;

  // Core latency increases gently with fatigue
  mu := mean * (1.0 + 0.10 * f);

  // Sigma: modest distribution spread
  sigma := mu * EnsureRange((0.10 + 0.10*PestControl.RT[0].U)
    * (1.0 + 0.30*f), 0.08, 0.28);

  // Tau: substantial tail growth with fatigue
  tau   := mu * EnsureRange((0.18 + 0.18*PestControl.RT[1].U)
    * (1.0 + 1.2*f), 0.12, 0.75);

  Result := ExpoGaussEx(mu, sigma, tau);
end;

function ExpoGaussRTInt(mean: Double): UInt64;
begin
  Result := Round(ExpoGaussRT(mean));
end;

// WEIBULL (math form):
//   CDF: 1 - exp(-(x/scale)^shape)
//   shape_k > 0, scale_lambda > 0
//   Useful for fatigue / hazard-rate modeling.
function WeibullEx(shape_k, scale_lambda: Double): Double;
var
  u: Double;
begin
  if shape_k <= 0 then
    shape_k := 0.000001;
  if scale_lambda <= 0 then
    scale_lambda := 0.000001;

  u := NZRandom; // uniform [0,1)

  // Inverse CDF
  Result := scale_lambda * Power(-Ln(u), 1.0 / shape_k);

  if Result < 0 then
    Result := 0;
end;

//override include to set zoom if it is wrong
function TRSOptions.GetZoomLevel(useCache: Boolean = True): Integer; override;
begin
  if useCache and (Self.ZoomLevel > -1) then
    Exit(Self.ZoomLevel);

  WriteLn GetDebugLn('Options', 'Unknown zoom level, reading from the gametab...');
  if Self.OpenTab(ERSOptionsTab.DISPLAY) then
    Self.ZoomLevel := Self.Sliders[ERSOptionsSlider.ZOOM].GetLevel();
  if Self.ZoomLevel = -1 then
    WriteLn GetDebugLn('Options', 'Failed to read zoom!', ELogLevel.ERROR)
  else
    WriteLn GetDebugLn('Options', 'Current zoom level: ' + ToString(Self.ZoomLevel), ELogLevel.SUCCESS);

  Result := Self.ZoomLevel;
  if InRange(Result, 30, 50) then exit;
  if Self.SetZoomLevel(RandomMode(35+Round(10*bhM.U), 30, 50)) then
  begin
    Result := Self.ZoomLevel;
    WriteLn GetDebugLn('Options', 'Zoom adjusted level: ' + ToString(Self.ZoomLevel), ELogLevel.SUCCESS);
  end;
end;

//override include
function TRSEntity._HoverHelper(action: TStringArray; attempts: Integer): Boolean; override;
var
  shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
  coordinates, tpa: TPointArray;
begin
  Result := Self._UpTextCheck(shouldExit, action);
  if shouldExit then Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(coordinates, atpa) then
    begin
      if Length(coordinates) <> Length(atpa) then
        raise 'SOMETHING WENT WRONG CACHING COORDINATES.';

      if attempt < 2 then i := 0
      else if Length(atpa) > (attempt - 2) then i := attempt - 2
      else i := Random(Low(atpa), High(atpa));

      tpa := atpa[i];
      Self.LastCoordinate := coordinates[i];

      Mouse.Move(tpa.RandomMean());

      if Self.UpText = [] then Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText) then Exit(True);

    if attempt <> (attempts - 1) then
      Continue;
    if not self.UpText.Contains('tack Shifter') then
      Minimap.CompassRadians := Minimap.CompassRadians + PI/3.6 * Random(-1,1);
  end;
end;

// =============================================================================
// PEST CONTROL METHODS
// =============================================================================

function TPestControl.GetReportValues(): TStringArray;
var
  playTime: UInt64;
  winsPerHour, ptsPerHour: Double;
  actionsStr, sleepInfo: String;
begin
  actionsStr := ToStr(Self.Actions);
  if Self.MaxActions <> 0 then
    actionsStr += '/' + ToStr(Self.MaxActions);

  if Antiban.Sleeps = [] then
    sleepInfo := 'No sleep'
  else
    sleepInfo := Antiban.TimeUntilSleep(Antiban.Sleeps.First, TIME_SHORT);

  playTime := Logger.TimeRunning.Elapsed;
  Self.GamesWon := Round(Self.PtsEarned/Self.PtsPerGame);
  winsPerHour := (Self.GamesWon / Max(1, playTime)) * ONE_HOUR;
  ptsPerHour := (Self.PtsEarned / Max(1, playTime)) * ONE_HOUR;


  Result := [
    GetTimeStamp(TIME_SHORT),
    Logger.TimeRunning.ElapsedFmt(TIME_SHORT),
    Antiban.TimeRunning.ElapsedFmt(TIME_SHORT),
    sleepInfo,
    ToStr(Self.GamesWon),
    FormatNumber(winsPerHour, 2),
    ToStr(Self.PtsEarned),
    FormatNumber(ptsPerHour, 2),
    actionsStr
  ];
end;

function TPestControl.InGame(): Boolean;
const
  sBox: Tbox = [11, 94, 49, 108];
begin
  result := Target.CountColor($CCCCCC, 0, sBox) > 35;
  if not result then Self.GameStarted := False;
end;

function TPestControl.ReadActivityBar(): Int32;
var
  greenCount: Int32;
  activBox: TBox = [368, 126, 508, 126];
begin
  result := -1;
  if not Self.InGame() then Exit;
  greenCount := Target.CountColor(PCData.OCR.ActivGreen, 0, activBox);
  Result := Round((greenCount / 141) * 100);
end;

function TPestControl.ReadKnightHP(): Int32;
begin
  Self.KnightHP := OCR.RecognizeNumber(PCData.OCR.KnightHP, RSFonts.PLAIN_11, [$00F800, $0000F8], 0);
  result := Self.KnightHP;
end;

function TPestControl.ReadPortalHP(): Int32;
begin
  Self.wHP := OCR.RecognizeNumber(PCData.OCR.W, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.eHP := OCR.RecognizeNumber(PCData.OCR.E, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.seHP := OCR.RecognizeNumber(PCData.OCR.SE, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.swHP := OCR.RecognizeNumber(PCData.OCR.SW, RSFonts.PLAIN_11, [$0000F8, $00F800], 0);
  Self.portalsHP := Self.wHP + Self.eHP + Self.seHP + Self.swHP;
  result := Self.portalsHP;
end;

procedure TPestControl.UpdatePortalShields();
const
  SHIELD_COLOR = $73737A;
  TOL = 1;
begin
  Self.ReadPortalHP();
  Self.WShielded := SimilarColors(Target.GetColor(Point(382, 95)), SHIELD_COLOR, TOL);
  Self.EShielded := SimilarColors(Target.GetColor(Point(420, 95)), SHIELD_COLOR, TOL);
  Self.SEShielded := SimilarColors(Target.GetColor(Point(457, 95)), SHIELD_COLOR, TOL);
  Self.SWShielded := SimilarColors(Target.GetColor(Point(495, 95)), SHIELD_COLOR, TOL);
  //writeln('W: ', Self.WShielded, '| E: ', Self.EShielded, '| SE: ', Self.SEShielded, '| SW: ', Self.SWShielded);
end;

function FmtTime(ms: Int64): String;
begin
  if ms < 60000 then
    Result := FormatFloat('0.0', ms / 1000) + 's'
  else if ms < 3600000 then
    Result := FormatMilliseconds(ms, 'm\m s\s')
  else
    Result := FormatMilliseconds(ms, 'h\h m\m');
end;

procedure TPestControl.UpdateAndDrawHUD(onBreak: Boolean = False; onSleep: Boolean = False; remaining: UInt64 = 0; Force: Boolean = False);
const
  REFRESH_RATE = 500;//milliseconds
  HUD_BG_COLOR = $181818;
  HUD_BORDER_COLOR = $404040;
  HUD_HEADER_TEXT = $3B9FFF;
  HUD_TEXT_COLOR = $F0F0F0;
  HUD_TEXT_MUTED = $A5A5A5;
  HUD_SEP_COLOR = $404040;
  HUD_ACTIVITY_RED = $0000F8;
  HUD_ACTIVITY_WARN = $57C8FF;
  HUD_ACTIVITY_GREEN = $47FF47;
  THRESHOLD_COLOR = $F0F0F0;
  TRACK_COLOR = $202020;
  PAD = 8;
  ROW_GAP = 11;
  SEP_MARGIN = 3;
  SEP_HEIGHT = 2;
var
  elapsed: UInt64;
  winsPerHour, ptsPerHour, xpPerHour: Double;
  abox, aboxBorder, headerBox, footerBox, barBox, barBorder, fillBox: TBox;
  xLabel, xVal, xRate, y, fullWidth, filledWidth, thrX, totalWidth: Int32;
  activityValue, runtimeStr, stateStr, winsStr, winsHrStr, ptsStr, ptsHrStr, portalStr: String;
  xpStr, xpHrStr, prayerStr, atkDelayStr, breakStr, sleepStr, maxActStr, maxTimeStr: String;
  breakRemain, sleepRemain: String;
  barColor, valueColor, actPercent, currentMinutes, xPos: Int32;

  function DrawSep(cy: Int32): Int32;
  begin
    Inc(cy, SEP_MARGIN);
    RSClient.Canvas.DrawColor := HUD_SEP_COLOR;
    RSClient.Canvas.DrawBoxFilled(Box(abox.X1 + 6, cy -1, abox.X2 - 6, cy + 1));
    Result := cy + SEP_HEIGHT + SEP_MARGIN;
  end;

  function DrawRow(const lbl, val: String; cy: Int32; const rate: String = ''): Int32;
  begin
    RSClient.Canvas.DrawColor := HUD_TEXT_MUTED;
    RSClient.Canvas.DrawText(lbl, Point(xLabel, cy));
    RSClient.Canvas.DrawColor := HUD_TEXT_COLOR;
    RSClient.Canvas.DrawText(val, Point(xVal, cy));
    if rate <> '' then
      RSClient.Canvas.DrawText(rate, Point(xRate, cy));
    Result := cy + ROW_GAP;
  end;

begin
  if Self.UserDisableHUD then Exit;
  if ((Time - Self.HUDLastUpdate) < REFRESH_RATE) and
    not Force then Exit;
  Self.HUDLastUpdate := Time;

  Self.PtsEarned := Self.PtsTotal - Self.PtsStart;
  Self.GamesWon := Round(Self.PtsEarned / Self.PtsPerGame);
  elapsed := Logger.TimeRunning.Elapsed;
  winsPerHour := (Self.GamesWon / Max(1, elapsed)) * ONE_HOUR;
  ptsPerHour := (Self.PtsEarned / Max(1, elapsed)) * ONE_HOUR;
  xpPerHour := (XPBar.TotalEarnedXP() / Max(1, elapsed)) * ONE_HOUR;

  runtimeStr := FormatMilliseconds(GetTimeRunning, TIME_SHORT);
  stateStr := ToStr(Self.State).After('EPestState.');

  breakRemain := '';
  sleepRemain := '';
  if onBreak then
  begin
    breakStr := FormatMilliseconds(remaining, TIME_SHORT);
    stateStr := 'ON_BREAK';
    breakRemain := 'remaining';
  end else
  begin
    breakStr := 'None';
    if Length(Antiban.Breaks) > 0 then
      breakStr := Antiban.TimeUntilBreak(Antiban.Breaks[0], TIME_SHORT);
  end;
  if onSleep then
  begin
    sleepStr := FormatMilliseconds(remaining, TIME_SHORT);
    stateStr := 'ON_SLEEP';
    sleepRemain := 'remaining';
  end else
  begin
    sleepStr := 'None';
    if Length(Antiban.Sleeps) > 0 then
      sleepStr := Antiban.TimeUntilSleep(Antiban.Sleeps[0], TIME_SHORT);
  end;

  winsStr := ToStr(Self.GamesWon);
  winsHrStr := FormatNumber(winsPerHour, 1);
  ptsStr := ToStr(Self.PtsEarned);
  ptsHrStr := FormatNumber(ptsPerHour, 0);
  xpStr := FormatNumber(XPBar.TotalEarnedXP(), 1);
  xpHrStr := FormatNumber(xpPerHour, 0);

  if (Self.LastXPTime + Self.XPAttkDelay) > Time then
    atkDelayStr := FormatFloat('#,##0', Round(Self.XPAttkDelay)) + 'ms'
  else
    atkDelayStr := FormatFloat('#,##0', Round(Self.NextAttkDelay)) + 'ms';

  prayerStr := 'N/A';
  if Self.UserQuickPrayer then
    prayerStr := FormatFloat('#,##0', Round(Self.PrayerEnableTime)) + 'ms';

  maxActStr := '';
  if Self.MaxActions > 0 then
    maxActStr := ToStr(Self.Actions) + '/' + ToStr(Self.MaxActions);

  maxTimeStr := '';
  if Self.MaxTime > 0 then
  begin
    currentMinutes := GetTimeRunning div 60000;
    maxTimeStr := ToStr(currentMinutes) + '/' + ToStr(Self.MaxTime div 60000);
  end;

  actPercent := Self.ReadActivityBar();
  if actPercent < 0 then
  begin
    activityValue := 'N/A';
    valueColor := HUD_TEXT_MUTED;
    barColor := HUD_ACTIVITY_WARN;
  end
  else
  begin
    activityValue := ToStr(actPercent)+'%';
    if actPercent < 30 then
    begin
      valueColor := HUD_ACTIVITY_RED;
      barColor := HUD_ACTIVITY_RED;
    end
    else if actPercent < Self.ActivityThresh then
    begin
      valueColor := HUD_ACTIVITY_WARN;
      barColor := HUD_ACTIVITY_WARN;
    end
    else
    begin
      valueColor := HUD_ACTIVITY_GREEN;
      barColor := HUD_ACTIVITY_GREEN;
    end;
  end;

  abox := Box(552, 206, 731, 463);
  aboxBorder := abox.Expand(2);
  headerBox := Box(abox.X1, abox.Y1, abox.X2, abox.Y1 + 24);
  footerBox := Box(abox.X1, abox.Y2 - 18, abox.X2, abox.Y2);
  xLabel := abox.X1 + PAD;
  xVal := abox.X1 + 55;
  xRate := abox.X2 - 55;

  with RSClient.Canvas do
  begin
    BeginUpdate();

    DrawColor := HUD_BORDER_COLOR;
    DrawBoxFilled(aboxBorder);
    DrawColor := HUD_BG_COLOR;
    DrawBoxFilled(abox);
    DrawBoxFilled(headerBox);
    DrawBoxFilled(footerBox);

    FontName := 'Segoe UI';
    FontAntialiasing := True;
    FontSize := 16;
    DrawColor := HUD_HEADER_TEXT;
    DrawText('Pest Control LITE', Point(headerBox.X1 + PAD, headerBox.Y1 + 4));

    barBox := Box(abox.X1 + PAD, headerBox.Y2, abox.X1 + PAD +
      TextWidth('Pest Control LITE'), headerBox.Y2 + 8);
    barBorder := barBox.Expand(2);

    DrawColor := TRACK_COLOR;
    DrawBoxFilled(barBox);
    fullWidth := barBox.X2 - barBox.X1;
    filledWidth := (fullWidth * EnsureRange(actPercent, 0, 100)) div 100;
    if filledWidth > 0 then
    begin
      fillBox := barBox;
      fillBox.X2 := fillBox.X1 + filledWidth;
      DrawColor := barColor;
      DrawBoxFilled(fillBox);
      DrawBox(barBorder);
    end;
    thrX := barBox.X1 + (fullWidth * EnsureRange(Self.ActivityThresh, 0, 100)) div 100;
    DrawColor := THRESHOLD_COLOR;
    DrawBoxFilled(Box(thrX, barBox.Y1, thrX + 1, barBox.Y2));

    FontSize := 16;
    DrawColor := valueColor;
    DrawText(activityValue, Point(barBox.X2 + 4, barBox.Y1-2));

    y := barBox.Y2 +4;
    y := DrawSep(y);
    FontSize := 12;
    y := DrawRow('Runtime', runtimeStr, y, 'F '+ FormatFloat('##0.0', Self.F.F_total*100)+'%');
    if stateStr.Contains('DEFEND') then
      y := DrawRow('State', stateStr, y, FmtTime(Time-Self.GameStart))
    else
      y := DrawRow('State', stateStr, y, FmtTime(Time-Self.StateT));
    y := DrawRow('Break', breakStr, y, breakRemain);
    y := DrawRow('Sleep', sleepStr, y, sleepRemain);
    y := DrawSep(y);
    y := DrawRow('Wins', winsStr, y, winsHrStr + '/hr');
    y := DrawRow('Points', ptsStr, y, ptsHrStr + '/hr');
    y := DrawRow('XP', xpStr, y, xpHrStr + '/hr');
    y := DrawSep(y);
    y := DrawRow('Prayer', prayerStr, y);
    DrawColor := HUD_TEXT_COLOR;
    if not onSleep and not onBreak then
      DrawText('Z: ' + ToStr(Options.ZoomLevel), Point(xRate, y - ROW_GAP));
    y := DrawRow('Attack', atkDelayStr, y);
    if Self.LeaveGameCount > 0 then
      DrawText('L''s: ' + ToStr(Self.LeaveGameCount), Point(xRate, y - ROW_GAP));
    y := DrawSep(y);
    y := DrawRow('Total', ToStr(Self.State).After('.'), y, FmtTime(Self.StateTimer.Times[Self.State]+ (Time - Self.StateT)));
    y := DrawRow('Total', 'Points', y, FormatFloat('#,##0', Self.PtsTotal));
    if Self.InGame() then
      y := DrawRow('Sort/idx', ToStr(Self.AttackChoice).After('.'), y, IntToStr(Self.AttackIndex));
    if maxActStr <> '' then y := DrawRow('Max', 'Actions', y, maxActStr);
    if maxTimeStr <> '' then y := DrawRow('Max', 'Time', y, maxTimeStr);

    if Self.InGame() then
    begin
      Self.UpdatePortalShields();

      //FontSize := 10;

      // Calculate total width for centering
      totalWidth := TextWidth('(W) 999|') + TextWidth('(E) 999|') +
                    TextWidth('(SE)999|') + TextWidth('(SW)999');
      xPos := (abox.X1 + abox.X2) div 2 - totalWidth div 2;

      // W portal
      DrawColor := 16711935;
      if Self.WShielded then DrawText('(W)', Point(xPos, y+1))
      else DrawText('W:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(W) '));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.wHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 16711935;
      DrawText('|', Point(xPos, y+1));
      Inc(xPos, TextWidth('|'));

      // E portal
      DrawColor := 16737894;
      if Self.EShielded then DrawText('(E)', Point(xPos, y+1))
      else DrawText('E:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(E) '));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.eHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 16737894;
      DrawText('|', Point(xPos, y+1));
      Inc(xPos, TextWidth('|'));

      // SE portal
      DrawColor := 65535;
      if Self.SEShielded then DrawText('(SE)', Point(xPos, y+1))
      else DrawText('SE:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(SE)'));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.seHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 65535;
      DrawText('|', Point(xPos, y+1));
      Inc(xPos, TextWidth('|'));

      // SW portal
      DrawColor := 3355647;
      if Self.SWShielded then DrawText('(SW)', Point(xPos, y+1))
      else DrawText('SW:', Point(xPos, y+1));
      Inc(xPos, TextWidth('(SW)'));
      DrawColor := HUD_TEXT_COLOR;
      DrawText(PadL(ToStr(Self.swHP), 3), Point(xPos, y+1));
      Inc(xPos, TextWidth(PadL('999', 3)));
      DrawColor := 3355647;
      DrawText('|', Point(xPos, y+1));

      FontSize := 12;
      y += ROW_GAP+2;
    end;

    DrawColor := HUD_SEP_COLOR;
    DrawBoxFilled(Box(abox.X1 + 6, footerBox.Y1, abox.X2 - 6, footerBox.Y1 + SEP_HEIGHT - 1));
    FontSize := 12;
    DrawColor := HUD_HEADER_TEXT;
    DrawText('Author: footballjds', Point(abox.X1 + PAD, footerBox.Y1 + 5));

    EndUpdate();
  end;
end;

function TPestControl.InBoat(): Boolean;
const
  ptsBox: TBox = [7, 62, 77, 80];
begin
  result := (target.CountColor(16777113, 0, ptsBox) = 140);
end;

procedure TPestControl.ReadPoints();
var
  blueNumber: Int32;
begin
  if not Self.InBoat() then Exit;
  blueNumber := OCR.RecognizeNumber(PCData.OCR.PointsBox, RSFonts.PLAIN_12, [16777113], 0);
  if self.PtsStart < 0 then
    self.PtsStart := blueNumber;
  self.PtsTotal := blueNumber;
  self.PtsEarned := self.PtsTotal-self.PtsStart;
end;

function TPestControl.PlatformCenter(var tpOut: TPoint): Boolean;
var
  platPts: TPointArray;
begin
  platPts := Target.FindColor(2782859, 0, Minimap.Bounds);
  if platPts.Length < 1300 then Exit;
  Result := true;
  tpOut := platPts.Mean();
end;

function TPestControl.AtKnight(): Boolean;
var
  platMean: TPoint;
begin
  if not Self.PlatformCenter(platMean) then Exit;
  Result := Distance(Minimap.Center, platMean)
          < 13 + 3 * bhM.U + Random(-1, 1);
end;

function TPestControl.AtBoatPlank(pos: TPoint): Boolean;
begin
  Result := Distance(pos, Self.AtPlank) < 5+5*bhM.U;
end;

procedure TPestControl.UpdateAttkDelay();
var
  candidate: Double;
begin
  candidate := ExpoGaussRT(Self.Tempo.LowMean);
  if Self.NextAttkDelay > 0 then
  begin
    if Random() < (0.10 + 0.05 * Self.RT[2].U) then
      Self.NextAttkDelay := candidate
    else
      Self.NextAttkDelay := Self.Tempo.LowStick * Self.NextAttkDelay + (1.0 - Self.Tempo.LowStick) * candidate;
  end else
    Self.NextAttkDelay := candidate;
  Logger.Info('UpdateAttkDelay: %.4f', [Self.NextAttkDelay]);
end;

procedure TPestControl.UpdateXPAttkDelay();
var
  candidate: Double;
begin
  candidate := ExpoGaussRT(Self.Tempo.XPMean);

  if Self.XPAttkDelay > 0 then
  begin
    if Random() < (0.10 + 0.05 * Self.RT[2].U) then
      Self.XPAttkDelay := candidate
    else
      Self.XPAttkDelay := Self.Tempo.XPStick * Self.XPAttkDelay + (1.0 - Self.Tempo.XPStick) * candidate;
  end else
    Self.XPAttkDelay := candidate;
  Logger.Info('New XP AttackDelay: %.4f', [Self.XPAttkDelay]);
end;

procedure TPestControl.UpdateActiveThresh();
begin
  Self.ActivityThresh := Self.UserActiveThreshold;
  Self.ActivityThresh := EnsureRange(Self.ActivityThresh, 50, 100);
end;

procedure TPestControl.UpdateXP();
var
  nXP: UInt64;
begin
  nXP := XPBar.Read;
  if nXP > Self.LastXP then
  begin
    if (Time-Self.LastXPTime) > Self.XPAttkDelay then
      Self.UpdateXPAttkDelay();
    Self.LastXP := nXP;
    Self.LastXPTime := Time;
  end;
end;

function TAntiban.TaskDue(): Boolean;
var
  i: Int32;
  activeTasks: PAntibanTaskArray;
begin
  if Self.DoingAntiban then
    Exit(False);

  activeTasks := Self.GetActiveTasks();
  for i := 0 to High(activeTasks) do
    if activeTasks[i]^.Countdown.Remaining = 0 then
      Exit(True);

  Result := False;
end;


function TAntiban.BreakDue(): Boolean;
var
  i: Int32;
  t: UInt64;
begin
  if Self.DoingAntiban then
    Exit(False);

  t := GetTimeRunning();
  for i := 0 to High(Self.Breaks) do
    if t > Self.Breaks[i].Next then
      Exit(True);

  Result := False;
end;


function TAntiban.SleepDue(): Boolean;
var
  i: Int32;
  t: UInt64;
begin
  if Self.DoingAntiban then
    Exit(False);

  t := GetTimeRunning();
  for i := 0 to High(Self.Sleeps) do
    if t > Self.Sleeps[i].Next then
      Exit(True);

  Result := False;
end;


function TPestControl.GetState(): EPestState;
var
  tmpP: TPoint;
begin
  if Activity.IsFinished then
    Exit(EPestState.NO_ACTIVITY);

  if (Self.MaxActions > 0) and (Self.Actions >= Self.MaxActions) then
    Exit(EPestState.MAX_ACTIONS);

  if (Self.MaxTime > 0) and (GetTimeRunning() >= Self.MaxTime) then
    Exit(EPestState.MAX_TIME);

  if not RSClient.IsLoggedIn() then
    Exit(EPestState.LOGIN);

  if Self.CombatLevel < 40 then
    Exit(EPestState.CMBT_LVL);

  if Antiban.TaskDue() then
    Exit(EPestState.ANTIBAN);

  if Antiban.BreakDue() then
    if not Self.InGame() then
      Exit(EPestState.BREAK);

  if Antiban.SleepDue() then
    if not Self.InGame() then
      Exit(EPestState.SLEEP);

  if Self.InBoat() then Exit(EPestState.IN_BOAT);

  if Self.InGame() then
  begin
    if not Self.UserDisableLeaveGame and not Self.Flag.NoLeave and (Self.ReadPortalHP >= 50+199*bhM.U)
      and (Self.ReadActivityBar() < 1) then
        Exit(EPestState.EXIT_GAME);
    if Self.AtKnight() then Exit(EPestState.DEFEND);
    Exit(EPestState.WALK_MID);
  end;
  tmpP := Map.Position();
  if Self.AtBoatPlank(tmpP) then
    Exit(EPestState.AT_PLANK);

  result := EPestState.UNKNOWN;
end;

function TPestControl.PrayerSample(): Double;
var
  shape, scale: Double;
begin
  // Shape: How decision probability builds over time
  shape := Random(1.4, 1.5) + 1 * Self.P[1].U;

  // Scale: Typical timing
  scale := Self.F.GetRTMulti * 5500 + GaussRand(400,125) + 6000 * Self.P[0].U;

  // Session variance: This game's randomness
  scale := scale * (0.8 + (0.4 + Self.P[2].U/5) * Random());

  // Sample from Weibull
  Result := WeibullEx(shape, scale);

  Logger.Info('PrayerSample: %.2fs (k=%.2f, λ=%.0fms)',
    [Result / 1000, shape, scale]);
end;

procedure TPestControl.UpdateCmbtLvl();
const
  cbBox: TBox = [661, 229, 682, 244];
begin
  if InRange(Self.UserCombatLevel, 40, 126) then
    Self.CombatLevel := Self.UserCombatLevel
  else
    if GameTabs.Open(ERSGameTab.COMBAT) then
    begin
      Sleep(ExpoGaussRTInt(Self.bRT));
      Self.CombatLevel := OCR.RecognizeNumber(cbBox.Expand(3), RSFonts.PLAIN_11, [2070783], 0);
    end;
  Logger.Info('Combat Level: %d', [Self.CombatLevel]);
  XPBar.Read;
  if Self.CombatLevel >= 100 then
  begin
    Self.BoatBox := PCData.Vet.BoatBox;
    Self.AtPlank := PCData.Vet.AtPlank;
    Self.CrossPlank := PCData.Vet.PlankObj;

    Self.Shifter.Finder.ColorClusters += [[
      [$33C1E7, 4.010, EColorSpace.HSL, [1.562, 0.510, 0.930]],
      [$223B53, 0.882, EColorSpace.HSL, [1.421, 1.254, 0.326]],
      3
    ]];
    Self.Shifter.Finder.ColorClusters += [[
      [$B0BBB7, 1.153, EColorSpace.HSL, [0.506, 1.932, 0.563]],
      [$8E848A, 0.757, EColorSpace.HSL, [0.911, 1.517, 0.574]],
      3
    ]];
  end
  else if Self.CombatLevel >= 70 then
  begin
    Self.BoatBox := PCData.Inter.BoatBox;
    Self.AtPlank := PCData.Inter.AtPlank;
    Self.CrossPlank := PCData.Inter.PlankObj;

    //gold and brown shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$243E56, 1.203, EColorSpace.HSL, [1.022, 1.336, 0.644]],
      [$23BEE5, 4.008, EColorSpace.HSL, [1.359, 0.417, 1.226]],
      3
    ]];

    //red and black shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$505061, 1.477, EColorSpace.HSV, [0.737, 1.700, 0.564]],
      [$2133BF, 0.717, EColorSpace.HSL, [1.267, 1.196, 0.539]],
      3
    ]];

    //green shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$137C71, 1.936, EColorSpace.RGB, [0.534, 0.511, 1.957]],
      [$3C5624, 0.965, EColorSpace.HSL, [1.251, 1.181, 0.570]],
      3
    ]];
  end
  else if Self.CombatLevel >= 40 then
  begin
    Self.BoatBox := PCData.Nov.BoatBox;
    Self.AtPlank := PCData.Nov.AtPlank;
    Self.CrossPlank := PCData.Nov.PlankObj;

    //red shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$2234C2, 0.738, EColorSpace.HSL, [1.289, 1.289, 0.424]],
      [$242B76, 0.689, EColorSpace.HSL, [1.510, 0.899, 0.593]],
      3
    ]];
    //green shifter
    Self.Shifter.Finder.ColorClusters += [[
      [$137C71, 1.936, EColorSpace.RGB, [0.534, 0.511, 1.957]],
      [$3C5624, 0.965, EColorSpace.HSL, [1.251, 1.181, 0.570]],
      3
    ]];
  end
  else
    TerminateScript('[INIT] Combat level too low: ' + ToStr(Self.CombatLevel));

  Self.Gangplank := TRSObject.Create(@Map.Walker, [1, 1, 1], [Self.CrossPlank], ['Cross Gang']);
end;

procedure TPestControl.MoveInBoat();
const
  BOAT_BEHAV_SOUTH     = 0.53;
  BOAT_BEHAV_OPPOSITE  = 0.70;
  BOAT_BEHAV_AWAYPLANK = 0.85;
var
  boatArea: TBox;
  current, target, mean: TPoint;
  destMS: TQuad;
  weight, bias: Single;
  primary, behavior: Int32;
begin
  if Self.Flag.NoBoatMove then Exit;
  if Time < (Self.LastBoatMove + Self.BoatMoveDelay) then Exit;
  if not Self.InBoat() then Exit;

  boatArea := Self.BoatBox.Expand(Random(-4, 6 - Round(4 * bhM.U)));
  current := Map.Position();

  if bhM.U < BOAT_BEHAV_SOUTH then primary := 0
  else if bhM.U < BOAT_BEHAV_OPPOSITE then primary := 1
  else if bhM.U < BOAT_BEHAV_AWAYPLANK then primary := 2
  else primary := 3;

  if Random() < 0.60 + 0.35 * bhM.U then
    behavior := primary
  else
    behavior := Biometrics.RandomModeInteger(primary, 0, 3);

  case behavior of
    0: mean := [boatArea.Center.X, boatArea.Y2 - boatArea.Height div 4];
    1: mean := [boatArea.X2 - (current.X - boatArea.X1), boatArea.Y2 - (current.Y - boatArea.Y1)];
    2: begin
         mean.X := EnsureRange(boatArea.X2 - (Self.AtPlank.X - boatArea.X1), boatArea.X1, boatArea.X2);
         mean.Y := EnsureRange(boatArea.Y2 - (Self.AtPlank.Y - boatArea.Y1), boatArea.Y1, boatArea.Y2);
       end;
    else mean := boatArea.RandomPoint();
  end;

  weight := 2 + 8 * bhM.U;      // 2-10
  bias := 0.5 + 1.0 * _bhM.U;   // 0.5-1.5

  target := boatArea.RandomWeightedPoint(mean, weight, bias);
  if current.DistanceTo(target) < 4 + 3 * bhM.U then
    target := boatArea.RandomWeightedPoint(
      [boatArea.X1 + boatArea.X2 - mean.X, boatArea.Y1 + boatArea.Y2 - mean.Y],
      weight * 0.5, bias * 1.5);

  destMS := Map.Walker.GetQuadMS(current, target, [1], Minimap.CompassRadians);
  if not Mainscreen.Bounds.ContainsQuad(destMS) then
    Exit;
  if randomBoolean(0.1+0.8*bhm.U) and RandomBoolean(0.03348) then
    Mouse.Move(Mainscreen.Bounds, True, EMouseDistribution.GAUSS)
  else
    Mouse.Move(destMS, True, EMouseDistribution.GAUSS);

  Sleep(ExpoGaussRTInt(Self.bRT * 0.8));
  if not Self.InBoat() then Exit;

  if MainScreen.IsUpText('Walk here') then
    Mouse.Click(EMouseButton.LEFT)
  else if ChooseOption.Open() then
    ChooseOption.Select('Walk here');

  Self.LastBoatMove := Time;
  Self.BoatMoveDelay := LogNormal(Self.F.GetBaseRT * 100 + Random(75, 100) * bhM.U, 0.27 + 0.1 * bhM.U);
  Logger.Info('BoatMoveDelay: %.4f', [Self.BoatMoveDelay]);
end;

procedure TPestControl.WhileInBoat();
begin
  if not Self.UserDisableMoveInBoat then Self.MoveInBoat();
  Sleep(ExpoGaussRTInt(Self.bRT));
end;

//function from include, I am not author
function TRSChat.ReadPointsOption(): String;
var
  option: TRSChatOption;
begin
  for option in Self.GetOptions([$000080]) do
  begin
    if Result <> '' then Result += LINE_SEP;
    Result += option.Text;
  end;
  result := ToStr(result.ExtractInteger());
end;

procedure TPestControl.SetPerGame();
begin
  Self.Flag.NoPray := RandomBoolean(0.001347 + 0.026438 * Self.Flag.Choices[0].U);
  Self.Flag.NoLeave := RandomBoolean(0.00173 + 0.09573 * Self.Flag.Choices[1].U);
  Self.Flag.NoBoatMove := (Self.Flag.Choices[2].U > 0.873) and (Random() < 0.05 + 0.05* Self.Flag.Choices[3].U);
  Self.Flag.DelayBoatMove := (Self.Flag.Choices[2].U < 0.973) and (Random() < 0.15 + 0.55* Self.Flag.Choices[4].U);

  Logger.Info('Self.Flag.NoPray: %s', [toStr(Self.Flag.NoPray)]);
  Logger.Info('Self.Flag.NoLeave: %s', [toStr(Self.Flag.NoLeave)]);
  Logger.Info('Self.Flag.NoBoatMove: %s', [toStr(Self.Flag.NoBoatMove)]);
  Logger.Info('Self.Flag.DelayBoatMove: %s', [toStr(Self.Flag.DelayBoatMove)]);

  Self.PrayerEnableTime := Self.PrayerSample();
  Logger.Info('Self.PrayerEnableTime: %.4f', [Self.PrayerEnableTime]);
  if Self.Flag.DelayBoatMove then
  begin
    Self.LastBoatMove := Time;
    Self.BoatMoveDelay := ExpoGaussRTInt(Self.bRT*Random(0.537, 5+5*bhM.U));
    Logger.Info('BoatMoveDelay: %.4f', [Self.BoatMoveDelay]);
  end;
  Self.ReadPoints();
  Activity.Restart();
  Self.Actions+=1;
  Self.ActivityThresh := EnsureRange(Self.UserActiveThreshold + Round(GaussRand(0, 2.5)), 50, 100);
end;

procedure TPestControl.EnterBoatFailsafe();
begin

end;

procedure TPestControl.EnterBoat();
begin
  Sleep(ExpoGaussRTInt(Self.bRT * 2.9));
  if Chat.IsTitle('~ Warning ~') then
    TerminateScript('Too many points '+Chat.ReadPointsOption());
  try
    if Self.Gangplank.Click(True, 1 + Round(3*bhM.U)) then
      if SleepUntil(Self.InBoat, 50, Round(GaussRand(3000, 200))) then
      begin
        Self.SetPerGame();
        Sleep(ExpoGaussRTInt(Self.bRT * 3.9));
        if not InRange(Options.GetZoomLevel(True), 30, 50) then
          if Options.SetZoomLevel(RandomMode(35+Round(10*bhM.U), 30, 50)) then
            WriteLn GetDebugLn('Options', 'Zoom adjusted level: ' + ToString(Options.ZoomLevel), ELogLevel.SUCCESS);
        Exit;
      end;
  except Logger.Error('Exception in EnterBoat: %s', [GetExceptionMessage]); end;
end;

procedure TPestControl.EnablePrayerCheck();
begin
  if (not Self.Flag.NoPray) and Self.UserQuickPrayer and Self.GameStarted and
    (not Minimap.PrayerEnabled) and Self.InGame() and
    (Time > (Self.GameStart + Self.PrayerEnableTime)) and
    (Self.ReadPortalHP > Round(50 + 150*bhM.U)) then
      if Minimap.EnablePrayer() then
      begin
        if Biometrics.RandomBoolean() then
          Sleep(ExpoGaussRTInt(Self.bRT*(0.3+random(0.01, 2.1))));
        if Biometrics.RandomBoolean(0.23) then
          Mouse.Move(Mainscreen.Bounds, True);
      end;
end;

procedure TPestControl.WalkToDefend();
var
  uniqueMiddle, midP, msP: TPoint;
begin
  Sleep(ExpoGaussRTInt(Self.bRT * 1.7));
  if Self.F.ShouldError then
    Sleep(LogNormalInt(Self.F.GetBaseRT, 0.35 + 0.1 * Self.RT[0].u));
  if not Self.InGame() then Exit;
  if not Self.GameStarted then
  begin
    Self.GameStarted := True;
    Self.GameStart := Time;
  end;

  Self.EnablePrayerCheck();
  if Self.PlatformCenter(midP) then
  begin
    uniqueMiddle := midP;
    uniqueMiddle.X += Biometrics.RandomModeInteger(9, -9, 9);
    uniqueMiddle.Y += Biometrics.RandomModeInteger(9, -9, 9);
    msP := Minimap.Point2MS(uniqueMiddle, Minimap.CompassRadians);
    if Mainscreen.Bounds.Contains(msP) then
    begin
      msP := [EnsureRange(msP.X + Random(-10, 10), MainScreen.Bounds.X1,
         MainScreen.Bounds.X2), EnsureRange(msP.Y + Random(-10, 10),
         MainScreen.Bounds.Y1, MainScreen.Bounds.Y2)];
      if Mainscreen.Bounds.Contains(msP) then
      begin
        Mouse.Click(msP, EMouseButton.LEFT);
        if RandomBoolean(0.63+30*bhM.U) and (_bhM.U < 0.933) then
        begin
          Minimap.WaitMoving(Round(Self.F.GetBaseRT*Random(50, 100)));
          Sleep(ExpoGaussRTInt(Self.bRT*RandomLeft(0.7, 3.1)));
        end else
          Sleep(ExpoGaussRTInt(Self.bRT*GaussRand(10, 2.5)));
        Exit;
      end;
    end;
  end;
  uniqueMiddle := PCData.Knight;
  uniqueMiddle.X += Biometrics.RandomModeInteger(5, -5, 5);
  uniqueMiddle.Y += Biometrics.RandomModeInteger(5, -5, 5);
  try
    Logger.Info('Walk to middle: ' + ToStr(Map.Walker.WebWalk(uniqueMiddle, 7+Round(5*bhM.U), 0.2+0.4*_bhM.U)));
  except Logger.Error('WalkToDefend exception: %s', [GetExceptionMessage]); end;
end;

procedure DebugShifterClusters(constref Shifter: TRSEntity);
var
  img: TImage;
  atpa: T2DPointArray;
  coordinates: TPointArray;
  i, totalPixels: Integer;
  avgSize, minSize, maxSize: Integer;
begin
  img := Target.GetImage();

  // Try to find shifters
  if Shifter.Find(coordinates, atpa) then
  begin
    WriteLn('=== SHIFTER DETECTION DEBUG ===');
    WriteLn('Found ', Length(atpa), ' potential shifter(s)');
    WriteLn();

    minSize := High(Integer);
    maxSize := 0;
    totalPixels := 0;

    // Analyze each detected cluster
    for i := 0 to High(atpa) do
    begin
      WriteLn('Cluster #', i + 1, ':');
      WriteLn('  Coordinate: ', coordinates[i]);
      WriteLn('  Pixel count: ', Length(atpa[i]));
      WriteLn('  Bounds: ', atpa[i].Bounds());
      WriteLn();

      totalPixels += Length(atpa[i]);
      if Length(atpa[i]) < minSize then minSize := Length(atpa[i]);
      if Length(atpa[i]) > maxSize then maxSize := Length(atpa[i]);

      // Draw on image
      img.DrawColor := $00FF00;
      img.DrawTPA(atpa[i]);
      img.DrawBox(atpa[i].Bounds());
      img.DrawText('Cluster ' + ToStr(i+1) + ': ' + ToStr(Length(atpa[i])) + 'px',
                   atpa[i].Bounds().TopLeft);
    end;

    if Length(atpa) > 0 then
    begin
      avgSize := totalPixels div Length(atpa);
      WriteLn('=== STATISTICS ===');
      WriteLn('Average cluster size: ', avgSize, ' pixels');
      WriteLn('Min cluster size: ', minSize, ' pixels');
      WriteLn('Max cluster size: ', maxSize, ' pixels');
      WriteLn();
      WriteLn('RECOMMENDATION:');
      if minSize > 50 then
        WriteLn('  Current ColorCluster "3" parameter might be too low.')
      else if maxSize < 20 then
        WriteLn('  Detection might be too sensitive. Consider stricter tolerances.')
      else
        WriteLn('  Cluster sizes look reasonable (', minSize, '-', maxSize, ' pixels)');
    end;
  end else
  begin
    WriteLn('NO SHIFTERS DETECTED');
    WriteLn('Check:');
    WriteLn('  1. Are you near shifters?');
    WriteLn('  2. Are colors correct for this boat tier?');
    WriteLn('  3. Try uncommenting Transformer settings');
  end;

  // Draw entity info
  img.DrawColor := $00FFFF;
  img.DrawText('ColorClusters: ' + ToStr(Length(Shifter.Finder.ColorClusters)), [10, 30]);
  img.DrawText('Transformer.Distance: ' + ToStr(Shifter.Finder.Transformer.Distance), [10, 50]);
  img.DrawText('Transformer.ShortSide.Min: ' + ToStr(Shifter.Finder.Transformer.ShortSide.Min), [10, 70]);

  img.Show();
end;

function TPestControl.MapPos: TPoint;
var
  radians: Single;
  platMM: TPoint;
begin
  if not Self.PlatformCenter(platMM) then
    Exit(Map.Position());
  radians := Minimap.CompassRadians;
  Result := Self.Center + Minimap.Center - platMM.Rotate(-radians, Minimap.Center);
end;

function TPestControl.FindShifters(out atpa: T2DPointArray): Boolean;
var
  coords: TPointArray;
  bounds: TPolygonArray;
begin
  Result := Self.Shifter.FindEx(Self.MapPos, bounds, coords, atpa);
end;

function TPestControl.ChooseStrategy(): EAttackChoice;
var
  r: Double;
begin
  if (Random() < Self.AttackStick) then
    Exit(Self.AttackChoice);

  r := Random();
  if r < Self.AttackWeights[0] then
    Result := EAttackChoice.Self
  else if r < (Self.AttackWeights[0] + Self.AttackWeights[1]) then
    Result := EAttackChoice.Knight
  else
    Result := EAttackChoice.Rand;
end;

procedure TPestControl.SortByStrategy(strategy: EAttackChoice; var atpa: T2DPointArray);
var
  platMM, knightMS: TPoint;
begin
  case strategy of
    EAttackChoice.Self:
      atpa := atpa.SortFrom(MainScreen.PlayerBox.Center);

    EAttackChoice.Knight:
      begin
        if Self.PlatformCenter(platMM) then
          knightMS := Minimap.Point2MS(platMM, Minimap.CompassRadians)
        else
          knightMS := MainScreen.Bounds.Center;
        atpa := atpa.SortFrom(knightMS);
      end;

    EAttackChoice.Rand:
      ; // No sorting needed
  end;
end;

function TPestControl.PickIndex(len: Int32; strategy: EAttackChoice): Int32;
var
  lambda, alpha, cumulative, r: Double;
  probs: TDoubleArray;
  i: Int32;
begin
  if len = 1 then Exit(0);
  if strategy = EAttackChoice.Rand then Exit(Random(len));

  SetLength(probs, len);

  // Calculate raw probabilities
  if Self.attkC[5].U < 0.5 then
  begin
    lambda := 0.3 + 1.7 * Self.attkC[6].U;
    for i := 0 to len - 1 do
      probs[i] := Exp(-lambda * i);
  end
  else
  begin
    alpha := 0.5 + 1.5 * Self.attkC[6].U;
    for i := 0 to len - 1 do
      probs[i] := 1.0 / Power(i + 1, alpha);
  end;

  // Normalize
  cumulative := 0;
  for i := 0 to len - 1 do
    cumulative += probs[i];
  for i := 0 to len - 1 do
    probs[i] := probs[i] / cumulative;

  // Sample using cumulative distribution
  r := Random();
  cumulative := 0;
  for i := 0 to len - 1 do
  begin
    cumulative += probs[i];
    if r < cumulative then
      Exit(i);
  end;

  Result := len - 1;
end;

function TPestControl.AttackShifter(debug: Boolean = False): Boolean;
var
  atpa: T2DPointArray;
  strategy: EAttackChoice;
  idx: Int32;
begin
  if debug then DebugShifterClusters(Self.Shifter);

  try
    if not Self.FindShifters(atpa) then Exit(False);
    Sleep(ExpoGaussRTInt(Self.bRT*0.7));

    strategy := Self.ChooseStrategy();
    Self.SortByStrategy(strategy, atpa);
    idx := Self.PickIndex(Length(atpa), strategy);

    Mouse.Move(atpa[idx].RandomMean());

    if MainScreen.IsUpText(Self.Shifter.UpText) then
      Result := Biometrics.RedClick(EMouseButton.LEFT);

    if Result then
    begin
      Self.AttackChoice := strategy;
      Self.AttackIndex := idx;
    end;

  except
    Logger.Error('AttackShifter exception: %s', [GetExceptionMessage]);
  end;
end;

procedure TPestControl.MaybeEmote();
begin

end;

procedure TPestControl.DefendKnight();
begin
  Sleep(ExpoGaussRTInt(Self.bRT*0.8));
  Self.UpdateXP();
  if (Time - Self.LastXPTime) < Self.XPAttkDelay then Exit;
  if (Time - Self.LastAttack) < Self.NextAttkDelay then Exit;
  if not Self.InGame() then Exit;
  if Biometrics.RandomBoolean(0.75) then
    Self.EnablePrayerCheck();

  if Self.AttackShifter({true}) then
  begin
    Activity.Restart();
    Self.LastAttack := Time;
    Self.UpdateAttkDelay();
    Sleep(ExpoGaussRTInt(Self.bRT*2.2));
  end;
  Self.EnablePrayerCheck();
end;

procedure TPestControl.LeaveTheGame();
begin
  if not Self.InGame() then Exit;
  Sleep(ExpoGaussRTInt(Self.bRT * 3.3));
  if not Self.InGame() then Exit;
  try
    Writeln('Distance to Squire: ', Self.Squire.DistanceTo(Map.Position()));
    if not Self.InGame() then Exit;
    if Self.Squire.DistanceTo(Map.Position()) > (8+Random(4)+Round(5*bhM.U)) then
      if Map.Walker.WebWalk(Self.Squire.Coordinates[0].Offset(Random(-5, 5),
        Random(5, 10)), 3+Round(3*(bhM.U)), 0.2+0.5*bhM.U) then
          Writeln('Walked towards Squire');
    if not Self.InGame() then Exit;
    if Self.Squire.Interact(['Leave Squire', 'eave Squire'], 1+Round(3*bhM.U)) then
    begin
      Self.LeaveGameCount+=1;
      WriteLn('Left game at ', FormatMilliseconds(GetTimeRunning, TIME_SHORT));
      SleepUntil(not Self.InGame(), Round(200+random(200)), Round(17000+9000*bhM.U));
    end else
      Writeln('Failed to leave game');
  except Writeln('TPestControl.LeaveTheGame - ', GetExceptionMessage); end;
end;

procedure TPestControl.OnWalkerEvent(walker: PRSWalker; position, destination: TPoint);
begin
  if not Self.InGame() then
  begin
    walker^.Walking := False;
    Exit;
  end;
  if (Self.State = EPestState.WALK_MID) then
    Self.EnablePrayerCheck();
  Self.UpdateAndDrawHUD();
end;

procedure TPestControl.SetAttackTempo();
var
  bhInt: Int32;
  xpVar, lowVar: Double;
begin
  bhInt := Trunc(bhM.U * 1000);

  // Session variance (±8%)
  xpVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);
  lowVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);

  Self.Tempo.XPMean := (2573 + 990 * bhM.U) * xpVar;
  Self.Tempo.XPStick := 0.20 + 0.18 * ((bhInt shr 5) mod 1000 / 1000.0);
  Self.XPAttkDelay := ExpoGaussRT(Self.Tempo.XPMean);

  Self.Tempo.LowMean := (750 + 350 * _bhM.U) * lowVar;
  Self.Tempo.LowStick := 0.20 + 0.18 * (((bhInt shr 5) xor 913) mod 1000 / 1000.0);
  Self.NextAttkDelay := ExpoGaussRT(Self.Tempo.LowMean);

  Logger.Info('Tempo - XP:%.0fms(x%.2f) Low:%.0fms(x%.2f)',
    [Self.Tempo.XPMean, xpVar, Self.Tempo.LowMean, lowVar]);
end;

procedure TStateTimer.Add(State: EPestState; Ms: Int64);
begin
  Self.Times[State] := Self.Times[State] + Ms;
end;

procedure TStateTimer.LogAll();
var
  State: EPestState;
begin
  WriteLn('=== State Time Report ===');
  for State := Low(EPestState) to High(EPestState) do
    if Self.Times[State] > 0 then
      WriteLn(PadR(ToStr(State), 15), ' : ', FmtTime(Self.Times[State]));
end;

procedure TPestControl.OnBreakStart(task: PBreakTask);
begin
  if not Self.UserDisableFatigue then
    Logger.Info('Break starting - Fatigue: %.1f%%', [Self.F.GetLvl * 100])
  else
    Logger.Info('Break starting: ' + FormatMilliseconds(Round(task^.Length), TIME_FORMAL));
end;

procedure TPestControl.OnSleepStart(task: PSleepTask);
begin
  if not Self.UserDisableFatigue then
    Logger.Info('Sleep starting - Fatigue: %.1f%%', [Self.F.GetLvl * 100])
  else
    Logger.Info('Sleep starting: ' + FormatMilliseconds(Round(task^.Length), TIME_FORMAL));
end;

procedure TPestControl.OnBreakEnd(task: PBreakTask);
var
  before: Double;
  length: UInt64;
begin
  Activity.Restart();
  if not Self.UserDisableFatigue then
  begin
    before := Self.F.GetLvl;
    length := Round(task^.Length);
    Self.F.RecoverFromBreak(length);
    Logger.Info('Break ended - Fatigue: %.1f%% → %.1f%% (recovered %.1f%%)',
      [before * 100, Self.F.F_total * 100, (before - Self.F.F_total) * 100]);
  end;

  Logger.Info('Break of ' + FormatMilliseconds(length, TIME_FORMAL) + ' ended');
end;

procedure TPestControl.OnSleepEnd(task: PSleepTask);
var
  before: Double;
  length: UInt64;
begin
  Activity.Restart();
  if not Self.UserDisableFatigue then
  begin
    before := Self.F.GetLvl;
    length := Round(task^.Length);
    Self.F.RecoverFromSleep(length);
    Logger.Info('Sleep ended - Fatigue: %.1f%% → %.1f%% (recovered %.1f%%)',
      [before * 100, Self.F.F_total * 100, (before - Self.F.F_total) * 100]);
  end;

  Logger.Info('Sleep of ' + FormatMilliseconds(length, TIME_FORMAL) + ' ended');
end;

procedure TPestControl.OnBreakingHud(task: PBreakTask; var countdown: TCountdown);
begin
  Self.UpdateAndDrawHUD(True, False, countdown.Remaining, True);
end;

procedure TPestControl.OnSleepingHud(task: PSleepTask; var countdown: TCountdown);
begin
  Self.UpdateAndDrawHUD(False, True, countdown.Remaining, True);
end;

procedure TPestControl._OnPause();
begin
  WriteLn ProgressReport.Generate(ProgressReport.ValueProvider());
  RSClient.EnableRealInput();
  RSClient.Canvas.Clear();
end;

procedure TPestControl._OnResume();
begin
  RSClient.DisableRealInput();
end;


procedure TPestControl._OnTermination();
begin
  WriteLn ProgressReport.Generate(ProgressReport.ValueProvider());
  Self.StateTimer.Add(Self.State, Time - Self.StateT);
  Self.StateTimer.LogAll();
  Writeln('STATE ON TERMINATION: '+ToStr(Self.State));
  RSClient.Canvas.Clear;
  RSClient.EnableRealInput();
end;

procedure _InitPCData();
begin
  PCData.GameIsland := [10498, 39938, 10749, 40189];
  PCData.OutpostIsland := [10501, 39700, 10736, 39916];


  PCData.Nov.AtPlank := [10630, 39874];
  PCData.Nov.PlankObj := [10633, 39874];
  PCData.Nov.BoatBox := [10640, 39856, 10655, 39879];

  PCData.Inter.AtPlank := [10578, 39854];
  PCData.Inter.PlankObj := [10572, 39854];
  PCData.Inter.BoatBox := [10552, 39840, 10567, 39863];

  PCData.Vet.AtPlank := [10554, 39818];
  PCData.Vet.PlankObj := [10548, 39818];
  PCData.Vet.BoatBox := [10524, 39810, 10544, 39838];

  PCData.Portals.W := [];
  PCData.Portals.SW := [];
  PCData.Portals.SE := [];
  PCData.Portals.E := [];

  PCData.Knight := [10626, 40061];
  PCData.Spawn := [10632, 39994];
  PCData.LeaveNPC := [10620, 40002];

  PCData.OCR.ActivBox := [365, 121, 511, 131];
  PCData.OCR.PointsBox := [72, 64, 123, 81];
  PCData.OCR.ActivGreen := 40704;
  PCData.OCR.ActivRed := 255;

  PCData.OCR.W := [370, 53, 396, 68];
  PCData.OCR.E := [406, 53, 434, 68];
  PCData.OCR.SE := [445, 53, 470, 68];
  PCData.OCR.SW := [484, 53, 507, 68];

  PCData.OCR.Shield_W := [];
  PCData.OCR.Shield_E := [];
  PCData.OCR.Shield_SE := [];
  PCData.OCR.Shield_SW := [];

  PCData.OCR.KnightHP := [34, 39, 61, 54];
end;

procedure TPestControl.InitAttackProfile();
var
  baseWeights: array[0..2] of Double;
  i: Int32;
  total: Double;
begin
  //0..7
  Self.attkC.Create(['profileU', 'selfU', 'knightU', 'randU', 'stickU', 'decayType', 'decayParam']);

  if Self.attkC[0].U < 0.5 then
    baseWeights := [55.0, 40.0, 5.0]  // Self-primary
  else
    baseWeights := [40.0, 55.0, 5.0]; // Knight-primary

  total := 0;
  for i := 0 to 2 do
  begin
    Self.AttackWeights[i] := baseWeights[i] * (0.67 + 0.66 * Self.attkC[i+1].U);
    Self.AttackWeights[i] *= EnsureRange(GaussRand(1.0, 0.04), 0.84, 1.16);
    total += Self.AttackWeights[i];
  end;

  for i := 0 to 2 do
    Self.AttackWeights[i] := Self.AttackWeights[i] / total;

  Self.AttackStick := 0.15 + 0.25 * Self.attkC[4].U;
  Self.AttackStick *= EnsureRange(GaussRand(1.0, 0.025), 0.925, 1.075);

  if Self.AttackWeights[0] > Self.AttackWeights[1] then
    Self.AttackChoice := EAttackChoice.Self
  else
    Self.AttackChoice := EAttackChoice.Knight;

  Logger.Info('Attack Profile - Self:%.1f%% Knight:%.1f%% Rand:%.1f%% Stick:%.1f%%',
    [Self.AttackWeights[0]*100, Self.AttackWeights[1]*100, Self.AttackWeights[2]*100, Self.AttackStick*100]);
end;

procedure TPestControl.SetupMouse();
var
  speedBase, gravBase, windBase: Double;
  clickMinBase, clickMaxBase: Int32;
  speedVar, gravVar, windVar, clickVar: Double;
begin
  Self.M.Create(['speed', 'gravity', 'wind', 'click min', 'click max', 'miss chance']);

  // Base values
  speedBase := 10.0 + 4.0 * Self.M[0].U;
  gravBase := 7.0 + 4.0 * Self.M[1].U;
  windBase := 3.0 + 4.0 * Self.M[2].U;
  clickMinBase := 50 + Round(30.0 * Self.M[3].U);
  clickMaxBase := 120 + Round(80.0 * Self.M[4].U);

  // Session variance (±8%)
  speedVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);
  gravVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);
  windVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);
  clickVar := EnsureRange(GaussRand(1.0, 0.04), 0.88, 1.12);

  // Apply variance
  Mouse.Speed := speedBase * speedVar;
  Mouse.Gravity := gravBase * gravVar;
  Mouse.Wind := windBase * windVar;
  Mouse.PressMin := Round(clickMinBase * clickVar);
  Mouse.PressMax := Round(clickMaxBase * clickVar);

  Mouse.MissChance := 0.01 + 0.03 * Self.M[5].U;

  Logger.Info('Mouse - Speed:%.1f Grav:%.1f Wind:%.1f Click:%d-%dms Miss:%.1f%%',
    [Mouse.Speed, Mouse.Gravity, Mouse.Wind, Mouse.PressMin, Mouse.PressMax, Mouse.MissChance*100]);
end;

procedure TPestControl.Init();
begin
  WriteLn('[INIT] Pest Control - SIMBA2000');
  Logger.Setup('Pest Control JDS');
  Logger.RepeatedMessages := True;

  if not Self.UserDisableFatigue then
    Self.F.Init(Profiles[ProfileIndex].Name + Profiles[ProfileIndex].Username);

  ProgressReport.Setup(
    'Pest Control JDS',
    [
      'Total   runtime:', 'Active  runtime:', 'Antiban runtime:',
      'Next sleep:', 'Games Won:', 'Wins/Hour:', 'Points Earned:',
      'Points/Hour:', 'Actions:'
    ],
    @Self.GetReportValues,
    Round(ONE_MINUTE*2.5)
  );

  Antiban.OnBreaking := @Self.OnBreakingHud;
  Antiban.OnSleeping := @Self.OnSleepingHud;
  Antiban.OnStartBreak := @Self.OnBreakStart;
  Antiban.OnStartSleep := @Self.OnSleepStart;
  Antiban.OnFinishBreak := @Self.OnBreakEnd;
  Antiban.OnFinishSleep := @Self.OnSleepEnd;
  AddOnTerminate(@Self._OnTermination);
  AddOnPause(@Self._OnPause);
  AddOnResume(@Self._OnResume);
  _InitPCData();

  Self.SetupMouse();

  bhM.Create('bhM');
  Self.Flag.Choices.Create(['NoPray', 'NoLeave', 'NoBoatMove1', 'NoBoatMove2', 'DelayBoatMove']);
  _bhM.Create('_bhM');
  Self.P.Create(['U_Prayer1', 'U_Prayer2', 'U_Prayer3']);
  Self.RT.Create(['RT_U1', 'RT_U2', 'RTC_U']);

  // Result: 160-336ms with Gaussian distribution around personality baseline
  self.bRT := TruncGauss(200, 30, 173, 227) + 123 * bhM.U * TruncGauss(1.0, 0.05, 0.85, 1.15);

  Self.InitAttackProfile();
  Self.SetAttackTempo();
  Self.ActivityThresh := EnsureRange(Self.UserActiveThreshold+Random(-7, 7), 50, 100);
  Self.PrayerEnableTime := Self.PrayerSample();
  // Map setup
  Map.Setup([Chunk(Box(40,41,41,41), 0)]); //pc boat area
  Map.Add([Chunk(Box(41,40,41,40), 0)]); //pc game area
  Map.Walker.OnWaitMovingEvent := @Self.OnWalkerEvent;
  Map.Walker.OnWalkEvent := @Self.OnWalkerEvent;
  Map.Walker.TargetUpText := ['tack Shifter', 'Attack Shifter'];
  Self.Center := PCData.Knight.Offset(2, 0);
  Self.Squire := TRSEntity.Create(@Map.Walker, [1, 1, 4], 5, [PCData.LeaveNPC], ['to Squire', 'Talk-to'], [ERSMinimapDot.NPC]);
  Self.Shifter := TRSEntity.Create(
    @Map.Walker,
    [1, 1, 1],
    14 + Round(3*bhM.U),
    [PCData.Knight],
    ['tack Shifter', 'Attack Shifter'],
    [ERSMinimapDot.NPC]
  );

  // Initialize stats
  Self.Start := Time;
  Self.GameStart := Time;
  Self.GamesWon := -1;
  Self.PtsTotal := -1;
  Self.PtsStart := -1;
  Self.CombatLevel := -1;
  
  // Antiban setup
  Antiban.Zoom.Min := 30;
  Antiban.Zoom.Max := 50;
  Antiban.Skills := [ERSSkill.RANGED, ERSSkill.MAGIC, ERSSkill.PRAYER, ERSSkill.ATTACK, ERSSkill.STRENGTH, ERSSkill.DEFENCE, ERSSkill.TOTAL];

  Activity.Restart();
  
  WriteLn('[INIT] Initialization complete');
end;

procedure TPestControl.Run();
var
  nState, sBeforeAntiban: EPestState;
  tRand: Int32;
  JustDidAntiban: Boolean;
begin
  Self.Init();
  tRand := Round(Random(0, 80+100*bhM.U));
  Profiles[ProfileIndex].Worlds := [344];

  Self.State := EPestState.INIT;
  sBeforeAntiban := EPestState.INIT;
  JustDidAntiban := False;

  repeat
    nState := Self.GetState();

    if nState <> Self.State then
    begin
      if Self.State <> EPestState.INIT then
        Self.StateTimer.Add(Self.State, Time - Self.StateT);

      if nState = EPestState.ANTIBAN then
      begin
        // Only save if interrupted state is gameplay state
        if Self.State in [EPestState.IN_BOAT, EPestState.WALK_MID,
                          EPestState.DEFEND, EPestState.AT_PLANK,
                          EPestState.EXIT_GAME] then
          sBeforeAntiban := Self.State
        else
          sBeforeAntiban := EPestState.UNKNOWN;
      end
      else if JustDidAntiban then
      begin
        if sBeforeAntiban <> EPestState.UNKNOWN then
          Self.StateTimer.Add(sBeforeAntiban, Time - Self.StateT);
        JustDidAntiban := False;
      end;

      Self.StateT := Time;
      Self.State := nState;
      Self.UpdateAndDrawHUD(False, False, 0, True);
      Logger.Info('[STATE] ' + ToStr(Self.State));
    end
    else
    begin
      Self.State := nState;
      Self.UpdateAndDrawHUD();
    end;

    ProgressReport.Print();

    case Self.State of
      EPestState.UNKNOWN:
        begin
          Sleep(LogNormalInt(500, 0.35));
          Writeln('[UNKNOWN STATE]', FormatMilliseconds(Logger.TimeRunning.Elapsed, TIME_SHORT));
        end;

      EPestState.LOGIN: Login.DoLogin();
      EPestState.CMBT_LVL: Self.UpdateCmbtLvl();

      EPestState.ANTIBAN:
        begin
          Antiban.DoTask();
          JustDidAntiban := True;
        end;

      EPestState.BREAK: Antiban.DoBreak();
      EPestState.SLEEP: Antiban.DoSleep();

      EPestState.IN_BOAT: Self.WhileInBoat();
      EPestState.WALK_MID: Self.WalkToDefend();
      EPestState.DEFEND: Self.DefendKnight();
      EPestState.EXIT_GAME: Self.LeaveTheGame();
      EPestState.AT_PLANK: Self.EnterBoat();

      EPestState.NO_ACTIVITY, EPestState.MAX_ACTIONS,
      EPestState.MAX_TIME, EPestState.END_SCRIPT: Exit;
    end;
  until Self.PtsTotal > (3800 + tRand);

  Writeln('Total Points: ', Self.PtsTotal, ' is more than: ', 3800 + tRand);
  WriteLn('[COMPLETE] Thank you for using Pest Control JDS');
  Self.StateTimer.LogAll();
end;

var
  PCConfig: TConfigJSON;

  Form: TScriptForm;
  AutoStartTimer: TLazTimer;
  CountdownLabel: TLazLabel;
  TimerStartTime: UInt64;
  DisplayTimer: TLazTimer;

  ChkQuickPrayer, ChkChillIfActive, ChkDisableFatigue: TLazCheckBox;
  ChkDisableHUD, ChkDisableMoveInBoat, ChkDisablePace, ChkDisableLeaveGame: TLazCheckBox;
  EditCombatLevel: TLazEdit;
  EditActiveThreshold: TLazEdit;
  TLTrackActiveThresh: TLazTrackBar;
  EditPointsPerWin: TLazComboBox;

procedure OnAnyInteraction(sender: TLazObject);
begin
  if AutoStartTimer <> nil then
  begin
    AutoStartTimer.Enabled := False;
    AutoStartTimer.Free();
    AutoStartTimer := nil;
  end;
  if DisplayTimer <> nil then
  begin
    DisplayTimer.Enabled := False;
    DisplayTimer.Free();
    DisplayTimer := nil;
  end;
  if CountdownLabel <> nil then
  begin
    CountdownLabel.Free();
    CountdownLabel := nil;
  end;
end;

procedure OnSliderChanged(sender: TLazObject);
begin
  EditActiveThreshold.text := IntToStr(EnsureRange(TLTrackActiveThresh.Position, 50, 100));
end;

procedure OnTimerTick(sender: TLazObject);
begin
  AutoStartTimer.Enabled := False;
  WriteLn('[AUTO-START] Starting script');
  Form.Start.Click();
end;

procedure UpdateCountdown(sender: TLazObject);
var
  elapsed, remaining: Int32;
begin
  elapsed := (Time - TimerStartTime) div 1000;
  remaining := AUTO_START_DELAY - elapsed;

  if remaining > 0 then
    CountdownLabel.Caption := 'Auto-start in ' + ToStr(remaining) + 's'
  else
    CountdownLabel.Caption := 'Starting...';
end;

procedure TScriptForm.StartAutoTimer(sender: TLazObject);
var
  bottomPanel: TLazPanel;
begin
  TimerStartTime := Time;

  AutoStartTimer := TLazTimer.Create(Self.Form);
  AutoStartTimer.Interval := AUTO_START_DELAY*ONE_SECOND;
  AutoStartTimer.OnTimer := @OnTimerTick;
  AutoStartTimer.Enabled := True;

  DisplayTimer := TLazTimer.Create(Self.Form);
  DisplayTimer.Interval := 1000;
  DisplayTimer.OnTimer := @UpdateCountdown;
  DisplayTimer.Enabled := True;

  // Find bottom panel (Start button's parent)
  bottomPanel := TLazPanel(Self.Start.Parent);

  CountdownLabel := TLazLabel.CreateEx(bottomPanel);
  CountdownLabel.Caption := 'Auto-start in ' + ToStr(AUTO_START_DELAY) + 's';
  CountdownLabel.Font.Size := 9;
  CountdownLabel.Font.Color := $0000FF;  // Red
  CountdownLabel.Transparent := True;
  CountdownLabel.Left := Self.Start.Left - 100;  // Left of Start button
  CountdownLabel.Top := (bottomPanel.Height - 16) div 2;  // Centered vertically
  CountdownLabel.Width := 100;
  CountdownLabel.Height := 16;
end;

procedure TScriptForm.OnStart(sender: TLazObject); override;
var
  GoalT, GoalA: UInt64;
begin
  inherited;
  RSClient.DisableRealInput();
  GoalA := Self.Goals.Actions.Value;
  GoalA := GoalA + Round(Random(GoalA*-0.13, GoalA*0.23));
  PestControl.MaxActions := GoalA;
  GoalT := Self.Goals.Time.Value * ONE_MINUTE;
  GoalT := GoalT + Round(Random(GoalT*-0.13, GoalT*0.23));
  PestControl.MaxTime := GoalT;

  PestControl.UserQuickPrayer := ChkQuickPrayer.IsChecked();
  PestControl.UserChillIfActive := ChkChillIfActive.IsChecked();
  PestControl.UserActiveThreshold := EnsureRange(StrToInt(EditActiveThreshold.Text, 50), 50, 100);
  PestControl.PtsPerGame := StrToInt(EditPointsPerWin.text, 7);
  PestControl.UserDisableHUD := ChkDisableHUD.IsChecked();
  PestControl.UserDisableMoveInBoat := ChkDisableMoveInBoat.IsChecked();
  PestControl.UserDisablePace := ChkDisablePace.IsChecked();
  PestControl.UserDisableLeaveGame := ChkDisableLeaveGame.IsChecked();
  PestControl.UserCombatLevel := StrToInt(EditCombatLevel.Text, 100);
  PestControl.UserDisableFatigue := ChkDisableFatigue.IsChecked();

  if PCConfig.Data.Has('goal_actions') then
    PCConfig.Data.Item['goal_actions'].AsInt := Self.Goals.Actions.Value
  else
    PCConfig.Data.AddInt('goal_actions', Self.Goals.Actions.Value);

  if PCConfig.Data.Has('goal_time') then
    PCConfig.Data.Item['goal_time'].AsInt := Self.Goals.Time.Value
  else
    PCConfig.Data.AddInt('goal_time', Self.Goals.Time.Value);

  if PCConfig.Data.Has('quick_prayer') then
    PCConfig.Data.Item['quick_prayer'].AsBool := PestControl.UserQuickPrayer
  else
    PCConfig.Data.AddBool('quick_prayer', PestControl.UserQuickPrayer);

  if PCConfig.Data.Has('chill_if_active') then
    PCConfig.Data.Item['chill_if_active'].AsBool := PestControl.UserChillIfActive
  else
    PCConfig.Data.AddBool('chill_if_active', PestControl.UserChillIfActive);

  if PCConfig.Data.Has('active_threshold') then
    PCConfig.Data.Item['active_threshold'].AsInt := PestControl.UserActiveThreshold
  else
    PCConfig.Data.AddInt('active_threshold', PestControl.UserActiveThreshold);

  if PCConfig.Data.Has('points_per_win') then
    PCConfig.Data.Item['points_per_win'].AsInt := PestControl.PtsPerGame
  else
    PCConfig.Data.AddInt('points_per_win', PestControl.PtsPerGame);

  if PCConfig.Data.Has('disable_hud') then
    PCConfig.Data.Item['disable_hud'].AsBool := PestControl.UserDisableHUD
  else
    PCConfig.Data.AddBool('disable_hud', PestControl.UserDisableHUD);

  if PCConfig.Data.Has('disable_move_in_boat') then
    PCConfig.Data.Item['disable_move_in_boat'].AsBool := PestControl.UserDisableMoveInBoat
  else
    PCConfig.Data.AddBool('disable_move_in_boat', PestControl.UserDisableMoveInBoat);

  if PCConfig.Data.Has('disable_pace') then
    PCConfig.Data.Item['disable_pace'].AsBool := PestControl.UserDisablePace
  else
    PCConfig.Data.AddBool('disable_pace', PestControl.UserDisablePace);

  if PCConfig.Data.Has('disable_leave_game') then
    PCConfig.Data.Item['disable_leave_game'].AsBool := PestControl.UserDisableLeaveGame
  else
    PCConfig.Data.AddBool('disable_leave_game', PestControl.UserDisableLeaveGame);

  if PCConfig.Data.Has('disable_fatigue') then
    PCConfig.Data.Item['disable_fatigue'].AsBool := PestControl.UserDisableFatigue
  else
    PCConfig.Data.AddBool('disable_fatigue', PestControl.UserDisableFatigue);

  if PCConfig.Data.Has('combat_level') then
    PCConfig.Data.Item['combat_level'].AsInt := PestControl.UserCombatLevel
  else
    PCConfig.Data.AddInt('combat_level', PestControl.UserCombatLevel);

  PCConfig.Save();
end;

procedure TScriptForm.Init();
var
  tab: TLazTabSheet;
  goalsPanel: TLazPanel;
  lblQuickPrayer, lblCombatLevel, lblChillActive, lblActiveThresh, lblPointsPerWin, titleLabel, authorLabel: TLazLabel;
  bgImage: TLazImage;
  y: Int32;
begin
  PCConfig.Setup('jds-pestcontrol');
  Self.Setup('Pest Control LITE', PCConfig.Data);

  if USE_AUTO_START then
    Self.Form.OnShow := @Self.StartAutoTimer;

  // ===== Settings Tab =====
  tab := Self.CreateTab('Settings');
  tab.Color := $1A1A1A;

  if not FileExists(SimbaEnv.DataPath+'jdsBackground.png') then
    URLFetchToFile('https://i.imgur.com/xN2rmA4.png', SimbaEnv.DataPath+'jdsBackground.png');

  // Background image
  bgImage := TLazImage.CreateEx(tab);
  bgImage.Align := ELazAlign.Client;
  bgImage.Picture.LoadFromFile(SimbaEnv.DataPath + 'jdsBackground.png');
  bgImage.Stretch := True;
  bgImage.Proportional := False;
  bgImage.SendToBack();

  y := 20;

  // Quick Prayer
  lblQuickPrayer := TLazLabel.CreateEx(tab, 'Quick Prayer:', '', 20, y, 140, 30);
  lblQuickPrayer.Font.Size := 14;
  lblQuickPrayer.Font.Color := $F0F0F0;
  lblQuickPrayer.Color := $2A2A2A;
  lblQuickPrayer.Transparent := False;
  lblQuickPrayer.Alignment := ELazAlignment.Center;
  lblQuickPrayer.Layout := ELazTextLayout.Center;

  ChkQuickPrayer := TLazCheckBox.CreateEx(tab);
  ChkQuickPrayer.SetBounds(170, y, 560, 30);
  ChkQuickPrayer.Caption := 'Enable quick prayers during combat';
  ChkQuickPrayer.Font.Size := 14;
  ChkQuickPrayer.Font.Color := $F0F0F0;
  ChkQuickPrayer.SetChecked(True);
  Inc(y, 40);

  // Chill if Active
  lblChillActive := TLazLabel.CreateEx(tab, 'Chill Mode:', '', 20, y, 140, 30);
  lblChillActive.Font.Size := 14;
  lblChillActive.Font.Color := $F0F0F0;
  lblChillActive.Color := $2A2A2A;
  lblChillActive.Transparent := False;
  lblChillActive.Alignment := ELazAlignment.Center;
  lblChillActive.Layout := ELazTextLayout.Center;

  ChkChillIfActive := TLazCheckBox.CreateEx(tab);
  ChkChillIfActive.SetBounds(170, y, 560, 30);
  ChkChillIfActive.Caption := 'Reduce activity if above threshold';
  ChkChillIfActive.Font.Size := 14;
  ChkChillIfActive.Font.Color := $F0F0F0;
  ChkChillIfActive.SetChecked(False);
  Inc(y, 40);

  // Activity Threshold
  lblActiveThresh := TLazLabel.CreateEx(tab, 'Activity Threshold:', '', 20, y, 180, 30);
  lblActiveThresh.Font.Size := 14;
  lblActiveThresh.Font.Color := $F0F0F0;
  lblActiveThresh.Color := $2A2A2A;
  lblActiveThresh.Transparent := False;
  lblActiveThresh.Alignment := ELazAlignment.Center;
  lblActiveThresh.Layout := ELazTextLayout.Center;

  EditActiveThreshold := TLazEdit.CreateEx(tab);
  EditActiveThreshold.SetBounds(210, y, 60, 30);
  EditActiveThreshold.Text := '75';
  EditActiveThreshold.Font.Size := 14;
  EditActiveThreshold.Font.Color := $F0F0F0;
  EditActiveThreshold.Color := $2A2A2A;

  TLTrackActiveThresh := TLazTrackBar.CreateEx(tab);
  TLTrackActiveThresh.Frequency := 1;
  TLTrackActiveThresh.SelStart := 50;
  TLTrackActiveThresh.SelEnd := 100;
  TLTrackActiveThresh.Min := 50;
  TLTrackActiveThresh.Max := 100;
  TLTrackActiveThresh.TickStyle := ELazStickStyle.None;
  TLTrackActiveThresh.SetBounds(280, y, 300, 30);
  TLTrackActiveThresh.ShowSelRange := True;
  TLTrackActiveThresh.OnChange := @OnSliderChanged;
  Inc(y, 45);

  // Points Per Win
  lblPointsPerWin := TLazLabel.CreateEx(tab, 'Points/Win:', '', 20, y, 140, 30);
  lblPointsPerWin.Font.Size := 14;
  lblPointsPerWin.Font.Color := $F0F0F0;
  lblPointsPerWin.Color := $2A2A2A;
  lblPointsPerWin.Transparent := False;
  lblPointsPerWin.Alignment := ELazAlignment.Center;
  lblPointsPerWin.Layout := ELazTextLayout.Center;

  EditPointsPerWin := TLazComboBox.CreateEx(tab);
  EditPointsPerWin.SetBounds(170, y, 100, 30);
  EditPointsPerWin.Items.AddStrings(['3', '4', '5', '6', '7', '8']);
  EditPointsPerWin.Text := '7';
  EditPointsPerWin.Font.Size := 14;
  EditPointsPerWin.Font.Color := $F0F0F0;
  EditPointsPerWin.Color := $2A2A2A;
  Inc(y, 50);

  // Combat Level
  lblCombatLevel := TLazLabel.CreateEx(tab, 'Combat Level:', '', 20, y, 140, 30);
  lblCombatLevel.Font.Size := 14;
  lblCombatLevel.Font.Color := $F0F0F0;
  lblCombatLevel.Color := $2A2A2A;
  lblCombatLevel.Transparent := False;
  lblCombatLevel.Alignment := ELazAlignment.Center;
  lblCombatLevel.Layout := ELazTextLayout.Center;

  EditCombatLevel := TLazEdit.CreateEx(tab);
  EditCombatLevel.SetBounds(170, y, 100, 30);
  EditCombatLevel.Text := '-1';
  EditCombatLevel.Font.Size := 14;
  EditCombatLevel.Font.Color := $F0F0F0;
  EditCombatLevel.Color := $2A2A2A;
  Inc(y, 50);

  // === Advanced Options Header ===
  lblQuickPrayer := TLazLabel.CreateEx(tab, 'Advanced Options', '', 20, y, 220, 30);
  lblQuickPrayer.Font.Size := 14;
  lblQuickPrayer.Font.Color := $3B9FFF;
  lblQuickPrayer.Font.Style := [ELazFontStyles.Bold];
  lblQuickPrayer.Color := $2A2A2A;
  lblQuickPrayer.Transparent := False;
  lblQuickPrayer.Alignment := ELazAlignment.Center;
  lblQuickPrayer.Layout := ELazTextLayout.Center;
  Inc(y, 40);

  // Disable HUD
  ChkDisableHUD := TLazCheckBox.CreateEx(tab);
  ChkDisableHUD.SetBounds(20, y, 300, 30);
  ChkDisableHUD.Caption := 'Disable HUD';
  ChkDisableHUD.Hint := 'Turn off in-game overlay';
  ChkDisableHUD.ShowHint := True;
  ChkDisableHUD.Font.Size := 14;
  ChkDisableHUD.Font.Color := $F0F0F0;
  ChkDisableHUD.SetChecked(False);

  // Disable Boat Movement
  ChkDisableMoveInBoat := TLazCheckBox.CreateEx(tab);
  ChkDisableMoveInBoat.SetBounds(390, y, 330, 30);
  ChkDisableMoveInBoat.Caption := 'Disable Boat Move';
  ChkDisableMoveInBoat.Hint := 'Disable boat movement entirely';
  ChkDisableMoveInBoat.ShowHint := True;
  ChkDisableMoveInBoat.Font.Size := 14;
  ChkDisableMoveInBoat.Font.Color := $F0F0F0;
  ChkDisableMoveInBoat.SetChecked(False);
  Inc(y, 35);

  // Disable Pacing
  ChkDisablePace := TLazCheckBox.CreateEx(tab);
  ChkDisablePace.SetBounds(20, y, 300, 30);
  ChkDisablePace.Caption := 'Disable Pacing';
  ChkDisablePace.Hint := 'Disable game movement entirely';
  ChkDisablePace.ShowHint := True;
  ChkDisablePace.Font.Size := 14;
  ChkDisablePace.Font.Color := $F0F0F0;
  ChkDisablePace.SetChecked(False);

  // Disable Leave Game
  ChkDisableLeaveGame := TLazCheckBox.CreateEx(tab);
  ChkDisableLeaveGame.SetBounds(390, y, 330, 30);
  ChkDisableLeaveGame.Caption := 'Disable Auto-Leave';
  ChkDisableLeaveGame.Hint := 'Never leave a game, even if activity drops';
  ChkDisableLeaveGame.ShowHint := True;
  ChkDisableLeaveGame.Font.Size := 14;
  ChkDisableLeaveGame.Font.Color := $F0F0F0;
  ChkDisableLeaveGame.SetChecked(False);
  Inc(y, 35);

  // Disable Fatigue
  ChkDisableFatigue := TLazCheckBox.CreateEx(tab);
  ChkDisableFatigue.SetBounds(20, y, 300, 30);
  ChkDisableFatigue.Caption := 'Disable Fatigue';
  ChkDisableFatigue.Hint := 'Disable fatigue system';
  ChkDisableFatigue.ShowHint := True;
  ChkDisableFatigue.Font.Size := 14;
  ChkDisableFatigue.Font.Color := $F0F0F0;
  ChkDisableFatigue.SetChecked(False);

  // Title and Author in bottom right
  titleLabel := TLazLabel.CreateEx(tab, 'Pest Control LITE', '', 520, 420, 250, 35);
  titleLabel.Font.Size := 24;
  titleLabel.Font.Color := $3B9FFF;
  titleLabel.Font.Style := [ELazFontStyles.Bold];
  titleLabel.Transparent := True;
  titleLabel.Alignment := ELazAlignment.RightJustify;

  authorLabel := TLazLabel.CreateEx(tab, 'by footballjds', '', 580, 455, 190, 20);
  authorLabel.Font.Size := 12;
  authorLabel.Font.Color := $3B9FFF;
  authorLabel.Transparent := True;
  authorLabel.Alignment := ELazAlignment.RightJustify;

  // Load saved config
  if PCConfig.Data.Has('quick_prayer') then
    ChkQuickPrayer.SetChecked(PCConfig.Data.Item['quick_prayer'].AsBool);
  if PCConfig.Data.Has('chill_if_active') then
    ChkChillIfActive.SetChecked(PCConfig.Data.Item['chill_if_active'].AsBool);
  if PCConfig.Data.Has('active_threshold') then
  begin
    EditActiveThreshold.Text := ToStr(PCConfig.Data.Item['active_threshold'].AsInt);
    TLTrackActiveThresh.Position := PCConfig.Data.Item['active_threshold'].AsInt;
  end;
  if PCConfig.Data.Has('points_per_win') then
    EditPointsPerWin.Text := ToStr(PCConfig.Data.Item['points_per_win'].AsInt);

  if PCConfig.Data.Has('disable_hud') then
    ChkDisableHUD.SetChecked(PCConfig.Data.Item['disable_hud'].AsBool);
  if PCConfig.Data.Has('disable_move_in_boat') then
    ChkDisableMoveInBoat.SetChecked(PCConfig.Data.Item['disable_move_in_boat'].AsBool);
  if PCConfig.Data.Has('disable_pace') then
    ChkDisablePace.SetChecked(PCConfig.Data.Item['disable_pace'].AsBool);
  if PCConfig.Data.Has('disable_leave_game') then
    ChkDisableLeaveGame.SetChecked(PCConfig.Data.Item['disable_leave_game'].AsBool);
  if PCConfig.Data.Has('disable_fatigue') then
    ChkDisableFatigue.SetChecked(PCConfig.Data.Item['disable_fatigue'].AsBool);
  if PCConfig.Data.Has('combat_level') then
    EditCombatLevel.Text := ToStr(PCConfig.Data.Item['combat_level'].AsInt);

  // Goals panel at bottom
  goalsPanel := Self.CreateGoals(tab, True, True, False, EOrientation.HORIZONTAL);
  goalsPanel.Align := ELazAlign.Bottom;
  goalsPanel.Color := $3B9FFF;
  goalsPanel.Font.Style := [ELazFontStyles.Bold];
  goalsPanel.Font.Color := $000000;

  if PCConfig.Data.Has('goal_actions') then
    Self.Goals.Actions.Value := PCConfig.Data.Item['goal_actions'].AsInt;
  if PCConfig.Data.Has('goal_time') then
    Self.Goals.Time.Value := PCConfig.Data.Item['goal_time'].AsInt;

  // ===== Antiban Tab =====
  Self.CreateAntibanTab();

  // Hook interactions
  ChkQuickPrayer.OnChange := @OnAnyInteraction;
  ChkChillIfActive.OnChange := @OnAnyInteraction;
  EditActiveThreshold.OnChange := @OnAnyInteraction;
  EditPointsPerWin.OnChange := @OnAnyInteraction;
  ChkDisableHUD.OnChange := @OnAnyInteraction;
  ChkDisableMoveInBoat.OnChange := @OnAnyInteraction;
  ChkDisablePace.OnChange := @OnAnyInteraction;
  ChkDisableLeaveGame.OnChange := @OnAnyInteraction;
  EditCombatLevel.OnChange := @OnAnyInteraction;
  Self.Goals.Actions.OnChange := @OnAnyInteraction;
  Self.Goals.Time.OnChange := @OnAnyInteraction;

  Form.Run();
end;

begin
  ClearSimbaOutput();
  Form.Init();
  PestControl.Run();
end.
